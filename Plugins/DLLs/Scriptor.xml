<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Scriptor</name>
    </assembly>
    <members>
        <member name="T:Scriptor.Analysis.SemanticTokenTypes">
            <summary>
            Helpers for semantic token types.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Type">
            <summary>
            A type, eg. `int.`
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Method">
            <summary>
            A class method.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Function">
            <summary>
            A function.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Operator">
            <summary>
            An operator, eg. `+`.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Parameter">
            <summary>
            A parameter/argument.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Variable">
            <summary>
            A variable.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.EnumMember">
            <summary>
            An enum member.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Keyword">
            <summary>
            A keyword, eg. `var`.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.String">
            <summary>
            A string, eg. `"hello world"`.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Number">
            <summary>
            A number, eg. `3.0`.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.SemanticTokenTypes.Values">
            <summary>
            All valid semantic token types.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.SemanticTokenTypes.MethodType(Scriptor.Reflection.IMethodSignature)">
            <summary>
            Get the semantic token type for a method.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.DebugHelpers">
            <summary>
            Helpers for reading debug information from language constructs.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.DebugHelpers.DebugRootEf(System.Text.StringBuilder,Scriptor.Analysis.EnvFrame)">
            <summary>
            Debug the contents of an EnvFrame.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.DebugHelpers.Print(System.Object)">
            <summary>
            Print a simple representation of an object for debugging purposes.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.DeclarationLookup">
            <summary>
            Flags for configuring how a declaration is looked up in lexical scopes.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.DeclarationLookup.CONSTANT">
            <summary>
            A declaration with a constant value (declared via const var).
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.DeclarationLookup.LEXICAL_SCOPE">
            <summary>
            A lexically scoped declaration.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.DeclarationLookup.DYNAMIC_SCOPE">
            <summary>
            A dynamically scoped declaration.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.DeclarationLookup.ConstOnly">
            <inheritdoc cref="F:Scriptor.Analysis.DeclarationLookup.CONSTANT"/>
        </member>
        <member name="F:Scriptor.Analysis.DeclarationLookup.Standard">
            <summary>
            Lexically scoped or constant declarations.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.DeclarationLookup.Dynamic">
            <summary>
            Dynamically scoped, lexically scoped, or constant declarations.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.UntypedVariable">
            <summary>
            Type unification error for untyped variables.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.UntypedVariable.#ctor(Scriptor.Analysis.VarDecl)">
            <summary>
            Type unification error for untyped variables.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.VoidTypedVariable">
            <summary>
            Type unification error for variables with inferred type `void`.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.VoidTypedVariable.#ctor(Scriptor.Analysis.VarDecl)">
            <summary>
            Type unification error for variables with inferred type `void`.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.IDeclaration">
            <summary>
            Interface for declared variables, functions, or parameters.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.IDeclaration.Position">
            <summary>
            Position of the declaration.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.IDeclaration.Name">
            <summary>
            Name of the declared object.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.IDeclaration.Hoisted">
            <summary>
            True if this variable should be hoisted into the parent scope of the location where its declaration occured.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.IDeclaration.DeclarationScope">
            <summary>
            The scope in which this variable is declared. Assigned by <see cref="M:Scriptor.Analysis.LexicalScope.Declare(Scriptor.Analysis.IDeclaration)"/>
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.IDeclaration.DocComment">
            <summary>
            An optional comment describing the declaration.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.IDeclaration.FinalizeType(BagoumLib.Unification.Unifier)">
            <summary>
            Try to finalize the type of this declaration. Called during lexical scope type finalization.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.IDeclaration.TrySetDocComment(Scriptor.Definition.LexerMetadata)">
            <summary>
            Set a doc comment from the provided lexer metadata if applicable.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.VarDecl">
            <summary>
            A declaration of a variable.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.Position">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.Hoisted">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.Constant">
            <summary>
            If true, then this declaration has a constant value.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.ConstantValue">
            <summary>
            If <see cref="P:Scriptor.Analysis.VarDecl.Constant"/> is true, then this stores the constant value of the declaration during execution.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.KnownType">
            <summary>
            The type of this variable as provided in the declaration. May be empty, in which case it will be inferred.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.Name">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.TypeDesignation">
            <summary>
            The type designation of this variable (either a known type or a variable that will be resolved).
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.SourceImplicit">
            <summary>
            If present, then this VarDecl is copied into an EnvFrame from the arguments of a function.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.DeclarationScope">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.DocComment">
            <inheritdoc/>
        </member>
        <member name="F:Scriptor.Analysis.VarDecl._parameter">
            <summary>
            The expression pointing to this variable (null if the scope is an Ex.Block scope).
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.FinalizedTypeDesignation">
            <summary>
            The final non-ambiguous type of this variable. Only present after <see cref="M:Scriptor.Analysis.VarDecl.FinalizeType(BagoumLib.Unification.Unifier)"/> is called.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.FinalizedType">
            <summary>
            The final non-ambiguous type of this variable. Only present after <see cref="M:Scriptor.Analysis.VarDecl.FinalizeType(BagoumLib.Unification.Unifier)"/> is called.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.TypeIndex">
            <summary>
            The index of this declaration's type among the types of all declarations in the same <see cref="T:Scriptor.Analysis.LexicalScope"/>.
            <br/>The ordering of indexes is arbitrary and may not correspond to the order of declarations.
            <br/>Assigned by <see cref="M:Scriptor.Analysis.LexicalScope.FinalizeVariableTypes(BagoumLib.Unification.Unifier)"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.Index">
            <summary>
            The index of this declaration among all declarations
             with the same <see cref="P:Scriptor.Analysis.VarDecl.FinalizedType"/> declared in the same <see cref="T:Scriptor.Analysis.LexicalScope"/>.
            <br/>The ordering of indexes is arbitrary and may not correspond to the order of declarations.
            <br/>Assigned by <see cref="M:Scriptor.Analysis.LexicalScope.FinalizeVariableTypes(BagoumLib.Unification.Unifier)"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.Assignments">
            <summary>
            The number of times this declaration receives an assignment.
            <br/>Set during the AST <see cref="M:Scriptor.Compile.IAST.Verify"/> step.
            <br/>This should always be at least 1.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.VarDecl.#ctor(Mizuhashi.PositionRange,System.Boolean,System.Type,System.String,Scriptor.Analysis.ImplicitArgDecl)">
            <summary>
            A declaration of a variable.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.VarDecl.DeclaredParameter(Scriptor.Expressions.TExArgCtx)">
            <summary>
            If this is a local variable for an Ex.Block (rather than an implicit variable),
            return the parameter definition.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.VarDecl.Value(System.Linq.Expressions.Expression,Scriptor.Expressions.TExArgCtx)">
            <summary>
            Get the read/write expression representing this variable, where `envFrame`'s scope is the scope in which
             this variable was declared (and tac.EnvFrame is the frame of usage).
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.VarDecl.FinalizeType(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.VarDecl.AsParam">
            <summary>
            Show this declaration in the format `Type Name`.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.ImplicitArgDecl">
            <summary>
            A declaration implicitly provided through TExArgCtx or a fixed expression.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl.DeclaredParameter(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl.Value(System.Linq.Expressions.Expression,Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl.#ctor(Mizuhashi.PositionRange,System.Type,System.String)">
            <inheritdoc cref="T:Scriptor.Analysis.ImplicitArgDecl"/>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl.MakeTExArg(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl.MakeImplicitArgDecl">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Analysis.ImplicitArgDecl`1">
            <inheritdoc cref="T:Scriptor.Analysis.ImplicitArgDecl"/>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl`1.#ctor(Mizuhashi.PositionRange,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.ImplicitArgDecl`1.MakeTExArg(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Analysis.ScriptFnDecl">
            <summary>
            Declaration of a script function.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.Name">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.Hoisted">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.Args">
            <summary>
            Arguments to the script function.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.Defaults">
            <summary>
            Default values of script function arguments.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.Tree">
            <summary>
            AST representing the script function.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.CallType">
            <summary>
            Type of this script function.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.IsConstant">
            <summary>
            If true, then invocations of this function should be extracted as constants.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.Position">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.DeclarationScope">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.DocComment">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.FuncType">
            <summary>
            The type of this script function as a Func or Action.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.ScriptFnDecl.#ctor(Scriptor.Compile.AST.ScriptFunctionDef,System.Boolean,System.String,Scriptor.Analysis.ImplicitArgDecl[],Scriptor.Compile.IAST[],BagoumLib.Unification.TypeDesignation.Dummy)">
            <inheritdoc cref="T:Scriptor.Analysis.ScriptFnDecl"/>
        </member>
        <member name="M:Scriptor.Analysis.ScriptFnDecl.Compile(Scriptor.Expressions.TExArgCtx)">
            <summary>
            Compile this script function into a delegate and return an expression pointing to it.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.ReturnType">
            <summary>
            The return type of this function.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.ScriptFnDecl.AsSignature(System.String)">
            <summary>
            Print the signature of this function, in the format `ReturnType Name(Type1 Arg1, Type2 Arg2...)`
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptFnDecl.TypeOnlySignature">
            <summary>
            Print the signature of this function, in the format `(Type1, Type2...): ReturnType`
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.ScriptFnDecl.FinalizeType(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.ScriptFnDecl.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Analysis.MacroDecl">
            <summary>
            Definition of a macro.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.MacroDecl.#ctor(Scriptor.Compile.ST.MacroDef,System.String,System.String[],Scriptor.Compile.ST[])">
            <summary>
            Definition of a macro.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.MacroDecl.Position">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.MacroDecl.Hoisted">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.MacroDecl.DeclarationScope">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.MacroDecl.DocComment">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.MacroDecl.FinalizeType(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Analysis.ScriptImport">
            <summary>
            An import declaration.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.ScriptImport.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.EnvFrame,System.String,System.String,System.String)">
            <summary>
            An import declaration.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ScriptImport.Name">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptImport.Hoisted">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptImport.DeclarationScope">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Analysis.ScriptImport.DocComment">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.ScriptImport.FinalizeType(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Analysis.IAutoVars">
            <summary>
            Interface for automatic variable declarations in lexical scope. Should be extended by customizers.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.EnvFrame">
            <summary>
            An environment frame, storing the local variables for an instantiated lexical scope,
            in script code execution.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.EnvFrame.ClearCache">
            <summary>
            An event for when envframe and framevar caches should be cleared.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.EnvFrame.Created">
            <summary>
            Number of envframes that have been created (including from cache).
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.EnvFrame.Cloned">
            <summary>
            Number of envframes that have been cloned (including from cache).
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.EnvFrame.Disposed">
            <summary>
            Number of envframes that have been returned to cache.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.EnvFrame.Empty">
            <summary>
            An empty envframe using the global lexical scope.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.EnvFrame.Ctr">
            <summary>
            The counter id for this envframe.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.EnvFrame.Parent">
            <summary>
            The environment frame that contains this one.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.EnvFrame.Scope">
            <summary>
            The lexical scope for which this envframe is instantiated.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.EnvFrame.Variables">
            <summary>
            The variables stored in this environment frame.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.EnvFrame.Item(System.Int32)">
            <summary>
            Get the i'th parent of this envframe.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.Create(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.EnvFrame)">
            <summary>
            Creates a new environment frame in the provided scope, as a child of the parent frame.
            <br/>If the provided scope disallows instantiating environment frames (<see cref="P:Scriptor.Analysis.LexicalScope.UseEF"/> false),
             or the provided scope is the same as the parent scope,
             then transparently clones the parent frame instead.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.MaybeGetValue``1(System.String)">
            <summary>
            Get a value stored in this envframe or a parent envframe.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.Value``1(System.String)">
            <summary>
            Get a reference to a value stored in this envframe or a parent envframe.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.Value``1(Scriptor.Analysis.VarDecl)">
            <summary>
            Get a reference to a value stored in this envframe or a parent envframe.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.NonRefValue``1(Scriptor.Analysis.VarDecl)">
            <summary>
            Get a value stored in this envframe or a parent envframe.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.FrameVarValues(Scriptor.Analysis.LexicalScope,System.Linq.Expressions.Expression,System.Int32,System.Type)">
            <summary>
            For an envFrame in the provided scope, get the type variables in the ancestor scope `parentage` levels up.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.FrameVarValues(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Get the local type variables for an envFrame.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.Value(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Get the value of a local variable for an envFrame.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.Free">
            <summary>
            Free this EnvFrame. It will only be returned to the cache when all dependencies have freed it.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.Mirror">
            <summary>
            Return this envframe, but mark an additional owner such that the envframe will only be disposed
             when both owners are finished using it.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EnvFrame.Clone">
            <summary>
            Copy all the values inside this envframe into a new envframe. The parent frame is shared, but the
             local values are not.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.FrameVars">
            <summary>
            Variables of a specific type stored in an <see cref="T:Scriptor.Analysis.EnvFrame"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.FrameVars.Type">
            <summary>
            Type of the stored variables.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars.AssertLength(System.Int32)">
            <summary>
            Called before storing variable data.
            Ensure that there is enough allocated space to store the provided number of variables.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars.Cache">
            <summary>
            Dispose of this instance by returning it to a cache.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars.Clone">
            <summary>
            Copy the values in this variable store.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars.GetVarStoreType(System.Type)">
            <summary>
            Get the type FrameVars{t}.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars.Create(System.Type)">
            <summary>
            Get an instance of object FrameVars{t}.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.FrameVars`1">
            <inheritdoc cref="T:Scriptor.Analysis.FrameVars"/>
        </member>
        <member name="P:Scriptor.Analysis.FrameVars`1.Type">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars`1.Create">
            <summary>
            Create an instance of <see cref="T:Scriptor.Analysis.FrameVars`1"/>.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.FrameVars`1.Values">
            <summary>
            Values of the stored variables.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars`1.AssertLength(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars`1.Cache">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Analysis.FrameVars`1.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Analysis.IVariableStoreCreator">
            <summary>
            Helper interface/class for creating an instance of FrameVars{T}.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.IVariableStoreCreator.Create">
            <summary>
            Create an instance of FrameVars{T}.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.VariableStoreCreator`1">
            <inheritdoc cref="T:Scriptor.Analysis.IVariableStoreCreator"/>
        </member>
        <member name="T:Scriptor.Analysis.EFArrayPool`1">
            <summary>
            Cache for storing arrays of small length, for use by <see cref="T:Scriptor.Analysis.FrameVars`1"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EFArrayPool`1.Return(`0[])">
            <summary>
            Return an array to the cache.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.EFArrayPool`1.Rent(System.Int32,System.Boolean)">
            <summary>
            Rent an array from the cache, and if required, clear its data to 0.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.GlobalScope">
            <summary>
            A global scope used for base lexical scope resolution.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.GlobalScope.Singleton">
            <summary>
            Singleton instance of the global scope.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.GlobalScope.Resolver">
            <inheritdoc cref="T:BagoumLib.Unification.TypeResolver"/>
        </member>
        <member name="P:Scriptor.Analysis.GlobalScope.EnumResolver">
            <summary>
            Enum values that can be referenced without the enum type. 
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.GlobalScope.extensionMethods">
            <summary>
            Recorded extension methods.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.#ctor(System.Type[])">
            <inheritdoc cref="T:Scriptor.Analysis.GlobalScope"/>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.ConfigureEnum``1(System.ValueTuple{System.String,``0}[])">
            <summary>
            Configure support for an enum in <see cref="P:Scriptor.Analysis.GlobalScope.EnumResolver"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.StaticMethodDeclaration(System.String)">
            <summary>
            Find a static method by name.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.ExtensionMethods(System.Type,System.String)">
            <summary>
            Find all extension methods on a given type, filtering by name if provided.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.TryFindConversion(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Try to find a conversion between the two types. Checks <see cref="M:Scriptor.Analysis.GlobalScope.GetConverterForCompiledExpressionType(System.Type)"/>
             as well as conversion rules in <see cref="P:Scriptor.Analysis.GlobalScope.Resolver"/>. Used when casting the output type of a script.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.GetConverterForCompiledExpressionType(System.Type)">
            <summary>
            If the provided type is a compiled expression type, then return a type converter that compiles an expression.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.TryFindLowPriorityConversion(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Try looking for a low-priority type conversion between the two types.
            Used when casting the output type of a script, only if <see cref="M:Scriptor.Analysis.GlobalScope.TryFindConversion(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)"/> fails.
            <br/>Low-priority conversions should not be mirrored in <see cref="P:Scriptor.Analysis.GlobalScope.Resolver"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.GlobalScope.FindExtensionMethods(System.Type[])">
            <summary>
            Lookup all extension methods in the provided classes.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.IFlattenDocSymbolArray">
            <summary>
            If a type T implements this interface, the type T[] will be flattened when generating document symbols.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.LangServHelpers">
            <summary>
            Helper functions for analyzing ASTs, consumed by the language server.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LangServHelpers.Symbol(BagoumLib.Reflection.TypeMember)">
            <summary>
            Get the <see cref="T:LanguageServer.VsCode.Contracts.SymbolKind"/> for a <see cref="T:BagoumLib.Reflection.TypeMember"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LangServHelpers.ToPosition(Mizuhashi.Position)">
            <summary>
            Convert a script position into a VSCode position.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LangServHelpers.ToDMKPosition(LanguageServer.VsCode.Contracts.Position,System.String)">
            <summary>
            Convert a VSCode position into a script position.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LangServHelpers.ToRange(Scriptor.Compile.IDebugAST[])">
            <summary>
            Get a script position range encompassing a set of ASTs.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LangServHelpers.ToRange(Mizuhashi.PositionRange)">
            <summary>
            Convert a script position range into a VSCode position range.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LangServHelpers.ToDMKRange(LanguageServer.VsCode.Contracts.Range,System.String)">
            <summary>
            Convert a VSCode position range into a script position range.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LangServHelpers.ToDiagnostic``1(Mizuhashi.LocatedParserError,Mizuhashi.InputStream{``0})">
            <summary>
            Convert a parsing error into a VSCode diagnostic.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.LexicalScopeType">
            <summary>
            Enum describing the type and visibility of a lexical scope.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.LexicalScopeType.Standard">
            <summary>
            A scope in the script code created by standard code flow controls that is always visible.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.LexicalScopeType.MethodScope">
            <summary>
            A scope resulting from <see cref="T:Scriptor.CreatesInternalScopeAttribute"/>; ie. a scope on a method call.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.LexicalScopeType.ExpressionBlock">
            <summary>
            A scope within a compiled expression tree, whose variables are realized as Ex.Block parameters.
            </summary>
        </member>
        <member name="F:Scriptor.Analysis.LexicalScopeType.ExpressionEF">
            <summary>
            A scope within a compiled expression tree that uses EnvFrames to realize parameters.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.UntypedReturn">
            <summary>
            Type error resulting from a return statement whose type could not be determined.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.UntypedReturn.#ctor(Scriptor.Analysis.ReturnStatementConfig)">
            <summary>
            Type error resulting from a return statement whose type could not be determined.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.ReturnStatementConfig">
            <summary>
            Configuration for a return statement in a <see cref="T:Scriptor.Compile.AST.ScriptFunctionDef"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ReturnStatementConfig.Scope">
            <summary>
            Local scope of the function for return statement.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ReturnStatementConfig.Type">
            <summary>
            The type returned by this return statement.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ReturnStatementConfig.Function">
            <summary>
            The linked <see cref="T:Scriptor.Analysis.ScriptFnDecl"/> enclosing this return statement.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.ReturnStatementConfig.FinalizedType">
            <inheritdoc cref="P:Scriptor.Analysis.ReturnStatementConfig.Type"/>
        </member>
        <member name="P:Scriptor.Analysis.ReturnStatementConfig.Label">
            <summary>
            The jump label used for this return statement.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.ReturnStatementConfig.#ctor(Scriptor.Analysis.LexicalScope,System.Type)">
            <inheritdoc cref="T:Scriptor.Analysis.ReturnStatementConfig"/>
        </member>
        <member name="M:Scriptor.Analysis.ReturnStatementConfig.FinalizeType(BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:Scriptor.Analysis.IDeclaration.FinalizeType(BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="T:Scriptor.Analysis.LexicalScope">
            <summary>
            A lexical scope in script code.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.NewTopLevelScope">
            <summary>
            Create a top-level scope for script compilation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.NewTopLevelDynamicScope">
            <summary>
            Create a dynamic top-level scope for script compilation.
            <br/>Use this if the script returns a lambda-like that can run on arbitrary envFrames.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.GlobalRoot">
            <summary>
            The global scope defining static methods, etc. For now, must be the same as <see cref="P:Scriptor.Analysis.GlobalScope.Singleton"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.ScriptRoot">
            <summary>
            The top-level scope for this script.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.Depth">
            <summary>
            Number of ancestors of this lexical scope. (GlobalScope.Singleton has depth 0).
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.Parent">
            <summary>
            The parent scope. Always nonnull except for GlobalScope.Singleton.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.variableDecls">
            <summary>
            All variable declarations in this scope.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.functionDecls">
            <summary>
            All function declarations in this scope.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.ImportDecls">
            <summary>
            All imports in this script.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.MacroDecls">
            <summary>
            All macros in this script.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.AllVarsInDescendantScopes">
            <summary>
            All variable declarations in this scope or child scopes.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.AllFnsInDescendantScopes">
            <summary>
            All function declarations in this scope or child scopes.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.AllVisibleVars">
            <summary>
            All variable declarations in this scope or ancestor scopes.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.AllVisibleScriptFns">
            <summary>
            All function declarations in this scope or ancestor scopes.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.AutoVars">
            <summary>
            A list of variables automatically declared in this scope.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.NearestAutoVars">
            <summary>
            The first <see cref="T:Scriptor.Analysis.IAutoVars"/> in this scope or the nearest parent scope.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.ContinueBreak">
            <summary>
            If this lexical scope is a loop definition, contains the continue/break/base loop scope data.
            <br/>NB: loopScope always is this.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.Return">
            <summary>
            The return statement for this lexical scope (if this is a function scope).
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.NearestReturn">
            <summary>
            The return statement for this lexical scope or a parent lexical scope (if this is enclosed within a function
             scope without crossing a compilation boundary).
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.NearestContinueBreak">
            <summary>
            If this lexical scope is enclosed within a loop definition without crossing a compilation boundary,
             contains the continue/break/base loop scope data.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.UseConverter(Scriptor.Reflection.IScopedTypeConverter)">
            <summary>
            Mark that this lexical scope is immediately enclosed by a conversion operation.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.Type">
            <inheritdoc cref="T:Scriptor.Analysis.LexicalScopeType"/>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.IsConstScope">
            <summary>
            If true, then content within this scope can only see constant declarations outside this scope.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.WithinExpressionBlockScope">
            <summary>
            True iff this scope is or is contained within a compiled expression that uses Ex.Block in place of
             environment frames.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.WithinAnyExpressionScope">
            <summary>
            True iff this scope is or is contained within any compiled expression scope.
            <br/>If this is false (ie. there are only standard and method scopes until the root),
             then references in this scope cannot see declarations made in <see cref="F:Scriptor.Analysis.LexicalScopeType.MethodScope"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.GeneratedByConversion">
            <summary>
            True iff this lexical scope is generated by a compilation or conversion operation, rather than
             a lexical structure in the source code.
            <br/>Such generated scopes may be destroyed if not required.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.UseEF">
            <summary>
            True iff this scope is instantiated by an environment frame
            (false if it is instantiated by Expression.Block or has no variables).
            <br/>This is finalized in <see cref="M:Scriptor.Analysis.LexicalScope.FinalizeVariableTypes(BagoumLib.Unification.Unifier)"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.VariableDecls">
            <summary>
            The final set of variables declared in this scope (not including function parameters).
            <br/>This is only non-empty after <see cref="M:Scriptor.Analysis.LexicalScope.FinalizeVariableTypes(BagoumLib.Unification.Unifier)"/> is called.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.TypeIndexMap">
            <summary>
            The map of types to their index in <see cref="P:Scriptor.Analysis.LexicalScope.VariableDecls"/>.
            <br/>This is only non-empty after <see cref="M:Scriptor.Analysis.LexicalScope.FinalizeVariableTypes(BagoumLib.Unification.Unifier)"/> is called.
            </summary>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.DynRealizeSource">
            <summary>
            The dynamic scope that instantiated this one for a particular caller, if such a dynamic scope exists.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.#ctor(Scriptor.Analysis.DynamicLexicalScope,Scriptor.Analysis.LexicalScope)">
            <inheritdoc cref="T:Scriptor.Analysis.LexicalScope"/>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.#ctor">
            <summary>
            Constructor for global scopes.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.#ctor(Scriptor.Analysis.LexicalScope)">
            <inheritdoc cref="T:Scriptor.Analysis.LexicalScope"/>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.Derive(Scriptor.Analysis.LexicalScope,Scriptor.Reflection.IScopedTypeConverter)">
            <summary>
            Create a lexical scope that is a child of the provided parent scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.UpdateParent(Scriptor.Analysis.LexicalScope)">
            <summary>
            Change the parent scope of this scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.Declare(Scriptor.Analysis.IDeclaration)">
            <summary>
            Declare a variable or function in this lexical scope.
            <br/>This variable/function can shadow variables/functions from parent scopes, but cannot redeclare a name already used in this scope.
            </summary>
            <returns>Left if declaration succeeded; Right if a variable or function already exists with the same name local to this scope.</returns>
        </member>
        <member name="P:Scriptor.Analysis.LexicalScope.HoistedScope">
            <summary>
            The scope used for hoisted declarations. Generally just the parent scope, unless this
             is already a top-level scope, in which case it is this scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.DeclareOrThrow``1(``0)">
            <summary>
            Declare a variable or function in this lexical scope.
            <br/>This variable/function can shadow variables/functions from parent scopes, but will throw if
             it is already declared in this scope.
            </summary>
            <returns>The provided declaration.</returns>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.SetAutovars(Scriptor.Analysis.IAutoVars)">
            <summary>
            Set <see cref="P:Scriptor.Analysis.LexicalScope.AutoVars"/>, or throw an exception if it is already set.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.FreeEfs(System.Linq.Expressions.Expression,System.Func{Scriptor.Analysis.LexicalScope,System.Boolean})">
            <summary>
            Get a list of expressions representing freeing environment frames
             for each scope, going upwards, until (and not including) the scope that does not satisfy the condition.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.IsIssueOf(Scriptor.Analysis.LexicalScope)">
            <summary>
            Return true if `ancestor` is this lexical scope or an ancestor of this lexical scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.FindVariable(System.String,Scriptor.Analysis.DeclarationLookup)">
            <summary>
            Find a declared variable in this scope or any parent scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.FindScopedVariable(System.String,Scriptor.Analysis.DeclarationLookup)">
            <summary>
            Find a declared variable in this scope or any parent scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.FindScopedFunction(System.String,Scriptor.Analysis.DeclarationLookup)">
            <summary>
            Find a declared script function in this scope or any parent scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.FinalizeVariableTypes(BagoumLib.Unification.Unifier)">
            <summary>
            Finalize the type of all variables in this lexical scope. Called as the final step in typechecking.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.LocalOrParentVariable(Scriptor.Expressions.TExArgCtx,System.Linq.Expressions.Expression,Scriptor.Analysis.VarDecl)">
            <summary>
            Get an expression representing a readable/writeable variable
             stored locally in an environment frame for this scope,
             or stored locally in any parent environment frame.
            <br/>The returned expression is in the form
             `(envFrame.Parent.Parent....FrameVars[i] as FrameVars{T}).Values[j]`.
            <br/>Note that MSIL will optimize out the common frameVars access if many variables are referenced.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.TryGetLocalOrParentVariable(Scriptor.Expressions.TExArgCtx,System.Type,System.String,Scriptor.Analysis.VarDecl@)">
            <inheritdoc cref="M:Scriptor.Analysis.LexicalScope.LocalOrParentVariable(Scriptor.Expressions.TExArgCtx,System.Linq.Expressions.Expression,Scriptor.Analysis.VarDecl)"/>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.LocalOrParentFunctionEf(System.Linq.Expressions.Expression,Scriptor.Analysis.ScriptFnDecl)">
            <summary>
            Raise the provided envframe to the correct parent level for calling the provided script function.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.DynamicVariableLookup(Scriptor.Expressions.TExArgCtx,System.Linq.Expressions.Expression,System.String,System.Type,System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            Create an expression representing dynamically looking up a variable that may reside in any ancestor
             of the caller's EnvFrame.
            <br/>NB: The expression is not writeable, but `opOnValue` allows writing to the expression.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.FunctionWithoutLexicalScope(Scriptor.Expressions.TExArgCtx,Scriptor.Analysis.ScriptFnDecl,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
            <summary>
            Create an expression representing dynamically invoking a function that may reside in any ancestor
             of the caller's EnvFrame.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.GetLocalOrParentInstructions(System.ValueTuple{System.String,System.Type},System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Get instructions on how to access the provided variable from an EnvFrame of this scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.GetParentageToScriptFn(Scriptor.Analysis.ScriptFnDecl)">
            <summary>
            Get instructions on how to access the provided script function from an EnvFrame of this scope.
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.LexicalScope.SetDocComments(Scriptor.Definition.LexerMetadata)">
            <summary>
            Attach doc comments to all declarations in this scope or child scopes.
            </summary>
        </member>
        <member name="T:Scriptor.Analysis.DynamicLexicalScope">
            <summary>
            A lexical scope that can be realized with a parent envFrame from *any* scope
             (by default, the parent envFrame must be from this scope's parent).
            </summary>
        </member>
        <member name="M:Scriptor.Analysis.DynamicLexicalScope.#ctor(Scriptor.Analysis.LexicalScope)">
            <inheritdoc cref="T:Scriptor.Analysis.DynamicLexicalScope"/>
        </member>
        <member name="M:Scriptor.Analysis.DynamicLexicalScope.RealizeScope(Scriptor.Analysis.LexicalScope)">
            <summary>
            Create a non-dynamic lexical scope that has the same content as this one.
            </summary>
        </member>
        <member name="T:Scriptor.ExpressionBoundaryAttribute">
            <summary>
            A reflection method that takes expressions/expression functions as arguments (such as ExTP)
             and returns something that is not expression based (such as TP or RootedVTP).
            <br/>If this occurs alongside <see cref="T:Scriptor.FallthroughAttribute"/>,
             then it is treated as an expression compiler in BDSL1.
            <br/>Replaces ExprCompilerAttribute.
            </summary>
        </member>
        <member name="T:Scriptor.RestrictTypesAttribute">
            <summary>
            Attribute marking that the `typeIndex`th generic variable in this method should only be allowed
             to take on one of the provided `possibleTypes`.
            </summary>
        </member>
        <member name="M:Scriptor.RestrictTypesAttribute.#ctor(System.Int32,System.Type[])">
            <summary></summary>
        </member>
        <member name="M:Scriptor.FileLinkAttribute.#ctor(System.String,System.String,System.Int32)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.ConstableAttribute">
            <summary>
            Mark that this function (or all methods in this class) can be converted into a constant expression in BDSL2 reflection.
            </summary>
        </member>
        <member name="M:Scriptor.ConstableAttribute.#ctor(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.AliasAttribute">
            <summary>
            Attribute marking a reflection alias for this method.
            </summary>
        </member>
        <member name="M:Scriptor.AliasAttribute.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.ReflectAttribute">
            <summary>
            On an assembly, Reflect marks that classes in the assembly should be examined for possible reflection.
            <br/>If the assembly is marked, then on a class, Reflect marks that the methods in the class should be reflected.
            </summary>
        </member>
        <member name="M:Scriptor.ReflectAttribute.#ctor(System.Type,System.String,System.String,System.Int32)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.FallthroughAttribute">
            <summary>
            Attribute marking a reflection method that is automatically applied if none other match.
            </summary>
        </member>
        <member name="M:Scriptor.FallthroughAttribute.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.CreatesInternalScopeAttribute">
            <summary>
            (BDSL2) The marked method has a lexical scope governing its arguments.
            <br/>It may have automatically-defined variables, as defined by AutoVarMethod in provider code.
            <br/>If any of the arguments are GenCtxProperty or GenCtxProperties, then the compiler
             will assign the lexical scope to the constructed properties.
            </summary>
        </member>
        <member name="M:Scriptor.CreatesInternalScopeAttribute.#ctor(System.Int32,System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.ExtendsInternalScopeAttribute">
            <summary>
            (BDSL2) The marked method automatically declared variables in its enclosing lexical scope.
            </summary>
        </member>
        <member name="M:Scriptor.ExtendsInternalScopeAttribute.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.AssignsAttribute">
            <summary>
            The marked method is an expression function that modifies some of its arguments.
            </summary>
        </member>
        <member name="M:Scriptor.AssignsAttribute.#ctor(System.Int32[])">
            <summary></summary>
        </member>
        <member name="T:Scriptor.BDSL2OnlyAttribute">
            <summary>
            The marked method can only be reflected in BDSL2.
            </summary>
        </member>
        <member name="T:Scriptor.BDSL2OperatorAttribute">
            <summary>
            The marked method is a BDSL2 operator. It should not be permitted for reflection in BDSL2.
            </summary>
        </member>
        <member name="T:Scriptor.BDSL2MULTIPLY_OPERATORAttribute">
            <summary>
            Special workaround for handling the multiply operator in BDSL2. Some overloads
             should be skipped if any of the argument types are int.
            </summary>
        </member>
        <member name="M:Scriptor.BDSL2MULTIPLY_OPERATORAttribute.#ctor(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:Scriptor.OperatorAttribute">
            <summary>
            (Informational) The marked method is, semantically speaking, an operator.
            </summary>
        </member>
        <member name="T:Scriptor.BDSL1AutoSpecializeAttribute">
            <summary>
            For methods that cannot be specialized by their return type in BDSL1 (eg. equality has type (T,T)->bool),
             automatically specialize the generic type at the provided index with the provided type.
            </summary>
        </member>
        <member name="M:Scriptor.BDSL1AutoSpecializeAttribute.#ctor(System.Int32,System.Type)">
            <summary></summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Position">
            <inheritdoc cref="!:IAST.Position"/>
        </member>
        <member name="P:Scriptor.Compile.AST.EnclosingScope">
            <inheritdoc cref="P:Scriptor.Compile.IAST.EnclosingScope"/>
        </member>
        <member name="P:Scriptor.Compile.AST.LocalScope">
            <summary>
            The lexical scope that this AST creates for any nested ASTs.
            <br/>This is either null or a direct child of <see cref="P:Scriptor.Compile.AST.EnclosingScope"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Scope">
            <summary>
            The local scope or the enclosing scope.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.ImplicitCast">
            <inheritdoc cref="P:BagoumLib.Unification.ITypeTree.ImplicitCast"/>
        </member>
        <member name="P:Scriptor.Compile.AST.SameTypeCast">
            <summary>
            An implicit cast that converts a type to itself. Used to attach metadata.
            <br/>Applied before ImplicitCast.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Params">
            <inheritdoc cref="P:Scriptor.Compile.IAST.Params"/>
        </member>
        <member name="M:Scriptor.Compile.AST.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)">
            <inheritdoc cref="M:Scriptor.Compile.IAST.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.WillSelectOverload(Scriptor.Reflection.InvokedMethod,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.IMethodTypeTree`1.WillSelectOverload(`0,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.WillSelectOverload(BagoumLib.Unification.TypeDesignation.Dummy,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.IMethodTypeTree`1.WillSelectOverload(`0,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.WillSelectOverload(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.IAtomicTypeTree.WillSelectOverload(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.Realize(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc cref="M:Scriptor.Compile.IAST.Realize(Scriptor.Expressions.TExArgCtx)"/>
        </member>
        <member name="M:Scriptor.Compile.AST._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <summary>
            Create a TEx&lt;T&gt; representing the contents of this AST.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.ReturnType(BagoumLib.Unification.TypeDesignation)">
            <summary>
            The return type of this AST (unlifted, not including implicit casts).
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.SetDiagnostics(Scriptor.Reflection.ReflectDiagnostic[])">
            <inheritdoc cref="M:Scriptor.Compile.IAST.SetDiagnostics(Scriptor.Reflection.ReflectDiagnostic[])"/>
        </member>
        <member name="M:Scriptor.Compile.AST.WarnUsage">
            <inheritdoc cref="M:Scriptor.Compile.IAST.WarnUsage"/>
        </member>
        <member name="M:Scriptor.Compile.AST.ToSymbolTree(System.String)">
            <inheritdoc cref="!:IAST.ToSymbolTree"/>
        </member>
        <member name="M:Scriptor.Compile.AST._ToSymbolTree(System.String)">
            <inheritdoc cref="M:Scriptor.Compile.AST.ToSymbolTree(System.String)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.ToSemanticTokens">
            <inheritdoc cref="!:IAST.ToSemanticTokens"/>
        </member>
        <member name="M:Scriptor.Compile.AST._ToSemanticTokens">
            <inheritdoc cref="M:Scriptor.Compile.AST.ToSemanticTokens"/>
        </member>
        <member name="M:Scriptor.Compile.AST.NarrowestASTForPosition(Mizuhashi.PositionRange)">
            <inheritdoc cref="!:IAST.NarrowestASTForPosition"/>
        </member>
        <member name="M:Scriptor.Compile.AST.FlattenParams(System.Func{Scriptor.Compile.IAST,System.Int32,LanguageServer.VsCode.Contracts.DocumentSymbol})">
            <summary>
            Yield the list of child parameters' document symbols. If any of them are arrays of flattenable types,
             then flatten the array into the list.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.AST.Reference">
            <summary>
            A reference to a declaration of a variable, function, enum value, etc, that is used as a value (eg. in `x`++ or `f`(2)).
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.Reference.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Analysis.ScriptImport,System.String,BagoumLib.Functional.Either{Scriptor.Analysis.VarDecl,System.Collections.Generic.List{System.ValueTuple{System.Type,System.Object}}})">
            <inheritdoc cref="T:Scriptor.Compile.AST.Reference"/>
        </member>
        <member name="P:Scriptor.Compile.AST.Reference.SelectedOverload">
            <inheritdoc cref="P:BagoumLib.Unification.IAtomicTypeTree.SelectedOverload"/>
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Reference.PossibleTypes">
            <inheritdoc cref="P:BagoumLib.Unification.IAtomicTypeTree.PossibleTypes"/>
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Reference._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Reference.Explain">
            <inheritdoc/>
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Reference._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Reference._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Reference.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.WeakReference">
            <summary>
            A reference to a dynamically-scoped variable.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.WeakReference.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,System.String,System.Type)">
            <inheritdoc cref="T:Scriptor.Compile.AST.WeakReference"/>
        </member>
        <member name="P:Scriptor.Compile.AST.WeakReference.SelectedOverload">
            <inheritdoc cref="P:BagoumLib.Unification.IAtomicTypeTree.SelectedOverload"/>
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.WeakReference.PossibleTypes">
            <inheritdoc cref="P:BagoumLib.Unification.IAtomicTypeTree.PossibleTypes"/>
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.WeakReference._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.WeakReference.RealizeAsWeakWriteable(Scriptor.Expressions.TExArgCtx,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            Special handling for writing to a dynamically-scoped variable, which is nontrivial
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.WeakReference.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.WeakReference._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.WeakReference._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.WeakReference.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.TypeAs">
            <summary>
            A typecast operation `x as Type`.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.TypeAs.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,System.Type,Scriptor.Compile.IAST)">
            <summary>
            A typecast operation `x as Type`.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.TypeAs.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.TypeAs.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.TypeAs.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.TypeAs.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypeAs._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypeAs.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypeAs._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.MethodCall">
            <summary>
            An AST that invokes (possibly overloaded) methods.
            <br/>Methods may be lifted; ie. for a recorded method `R member (A, B, C...)`,
             given parameters of type F(A), F(B), F(C) (lifted over (T->), eg. T->A, T->B, T->C),
             this AST may construct a function T->R that uses T to realize the parameters and pass them to `member`.
            <br/>Methods may be generic.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall.#ctor(Mizuhashi.PositionRange,Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Reflection.InvokedMethod[],Scriptor.Compile.IAST[])">
            <summary>
            An AST that invokes (possibly overloaded) methods.
            <br/>Methods may be lifted; ie. for a recorded method `R member (A, B, C...)`,
             given parameters of type F(A), F(B), F(C) (lifted over (T->), eg. T->A, T->B, T->C),
             this AST may construct a function T->R that uses T to realize the parameters and pass them to `member`.
            <br/>Methods may be generic.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.MethodCall.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.MethodCall.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.MethodCall.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.MethodCall.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.MethodCall.OverloadsAreInterchangeable">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.MethodCall.AllowInvokeAsConst">
            <summary>
            If true, this method can be converted to a constant expression before being compiled.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.MethodCall.AddMethodSemanticToken">
            <summary>
            If true, adds a semantic token representing this method.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall.Make(Mizuhashi.PositionRange,Mizuhashi.PositionRange,Scriptor.Compile.STAnnotater,Scriptor.Reflection.InvokedMethod[],System.Collections.Generic.IEnumerable{Scriptor.Compile.ST},System.Boolean)">
            <param name="Position">Position of the entire method call, including all arguments (ie. all of `MethodName(arg1, arg2)`)</param>
            <param name="MethodPosition">Position of the method name alone (ie. just `MethodName`)</param>
            <param name="EnclosingScope">The lexical scope in which this function is called. Certain functions may also create a <see cref="P:Scriptor.Compile.AST.LocalScope"/></param>.
            <param name="Methods">Method signatures. These may be generic, requiring specialization before invocation.</param>
            <param name="Params">Arguments to the method</param>
            <param name="overloadsEq"><see cref="P:Scriptor.Compile.AST.MethodCall.OverloadsAreInterchangeable"/></param>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall.ImplicitParameterCast(Scriptor.Reflection.InvokedMethod,System.Int32)">
            <inheritdoc cref="M:BagoumLib.Unification.IMethodTypeTree`1.ImplicitParameterCast(`0,System.Int32)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall.WillSelectOverload(Scriptor.Reflection.InvokedMethod,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.IMethodTypeTree`1.WillSelectOverload(`0,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)" />
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall.RealizeMethod(Scriptor.Compile.IAST,Scriptor.Reflection.IMethodSignature,Scriptor.Expressions.TExArgCtx,System.Func{System.Int32,Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx},System.Boolean)">
            <summary>
            Realize a method call as an expression.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.MethodCall.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.InstanceMethodCall">
            <summary>
            An AST that invokes (possibly overloaded) instance methods, fields, or properties.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.InstanceMethodCall.#ctor(Mizuhashi.PositionRange,Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,System.String,Scriptor.Compile.IAST[])">
            <summary>
            An AST that invokes (possibly overloaded) instance methods, fields, or properties.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.InstanceMethodCall.Arg0PossibleTypes">
            <summary>
            The possible types for the instance.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.InstanceMethodCall.ImplicitParameterCast(Scriptor.Reflection.InvokedMethod,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.Indexer">
            <summary>
            An indexing expression `x[i]`.
            </summary>
            <param name="Object">The object to be indexed.</param>
            <param name="Index">The index.</param>
        </member>
        <member name="M:Scriptor.Compile.AST.Indexer.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Compile.IAST,Scriptor.Compile.IAST)">
            <summary>
            An indexing expression `x[i]`.
            </summary>
            <param name="Object">The object to be indexed.</param>
            <param name="Index">The index.</param>
        </member>
        <member name="P:Scriptor.Compile.AST.Indexer.Object">
            <summary>The object to be indexed.</summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Indexer.Index">
            <summary>The index.</summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Indexer.AddMethodSemanticToken">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialInvokedMethod.Method">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.PartialLambdaCall">
            <summary>
            A partial invocation of a lambda object.
            <br/> eg. var a = $(staticMethod, x); var b = $(a, y).
            <br/> $(a, y) is a PartialLambdaCall (and $(staticMethod, x) is a PartialMethodCall).
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialLambdaCall.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Compile.IAST[])">
            <summary>
            A partial invocation of a lambda object.
            <br/> eg. var a = $(staticMethod, x); var b = $(a, y).
            <br/> $(a, y) is a PartialLambdaCall (and $(staticMethod, x) is a PartialMethodCall).
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialLambdaCall.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialLambdaCall.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialLambdaCall.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialLambdaCall.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialLambdaCall._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialLambdaCall.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialLambdaCall._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.LambdaCall">
            <summary>
            An invocation of a lambda object.
            <br/> eg. var a = $(staticMethod, x, y); print(a(z)).
            <br/> a(z) is a LambdaCall.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.LambdaCall.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Compile.IAST[])">
            <summary>
            An invocation of a lambda object.
            <br/> eg. var a = $(staticMethod, x, y); print(a(z)).
            <br/> a(z) is a LambdaCall.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.LambdaCall.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.LambdaCall.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.LambdaCall.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.LambdaCall.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.LambdaCall._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.LambdaCall.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.LambdaCall._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.PartialMethodCall">
            <summary>
            A partial invocation of a static method (that would otherwise be a <see cref="T:Scriptor.Compile.AST.MethodCall"/>).
            <br/>In the form $(staticMethod, x, y).
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialMethodCall.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialMethodCall.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialMethodCall.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialMethodCall.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialMethodCall._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialMethodCall.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialMethodCall._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialMethodCall._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.PartialScriptFunctionCall">
            <summary>
            A partial invocation of a script function (that would otherwise be a <see cref="T:Scriptor.Compile.AST.ScriptFunctionCall"/>).
            <br/>In the form $(scriptFunction, x, y).
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialScriptFunctionCall.#ctor(Mizuhashi.PositionRange,Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Analysis.ScriptImport,Scriptor.Analysis.ScriptFnDecl,Scriptor.Compile.IAST[])">
            <summary>
            A partial invocation of a script function (that would otherwise be a <see cref="T:Scriptor.Compile.AST.ScriptFunctionCall"/>).
            <br/>In the form $(scriptFunction, x, y).
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialScriptFunctionCall.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialScriptFunctionCall.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialScriptFunctionCall.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.PartialScriptFunctionCall.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialScriptFunctionCall._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialScriptFunctionCall.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialScriptFunctionCall._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.PartialScriptFunctionCall._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionCall.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionCall.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionCall.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionCall.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.ScriptFunctionCall._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.ScriptFunctionCall.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.ScriptFunctionCall._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.ScriptFunctionCall._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionDef.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionDef.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionDef.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.ScriptFunctionDef.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.ScriptFunctionDef._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.ScriptFunctionDef.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.ScriptFunctionDef._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.Return">
            <summary>
            A return statement in a function definition.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.Return.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Compile.IAST)">
            <summary>
            A return statement in a function definition.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Return.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Return.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Return.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Return.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Return._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Return.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)">
            <inheritdoc cref="M:Scriptor.Compile.AST.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.Return.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Return._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.Conditional">
            <summary>
            A conditional expression (x ? y : z) or an if statement (if (x) { y; } else { z; }).
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Conditional.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Conditional.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Conditional.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Conditional.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Conditional._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Conditional.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Conditional._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Conditional.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.Loop">
            <summary>
            A for or while loop.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Loop.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Loop.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Loop.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Loop.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Loop.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope,Scriptor.Compile.IAST,Scriptor.Compile.IAST,Scriptor.Compile.IAST,Scriptor.Compile.IAST)">
            <summary>
            A for or while loop.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.Loop._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Loop.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Loop._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Loop.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.Continue">
            <summary>
            A continue statement in a for/while loop.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.Continue.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope)">
            <summary>
            A continue statement in a for/while loop.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Continue.PossibleTypes">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Continue.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Continue._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Continue.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)">
            <inheritdoc cref="M:Scriptor.Compile.AST.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.Continue.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Continue._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Continue._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.AST.Break">
            <summary>
            A break statement in a for/while loop.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.Break.#ctor(Mizuhashi.PositionRange,Scriptor.Analysis.LexicalScope)">
            <summary>
            A break statement in a for/while loop.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Break.PossibleTypes">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Break.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Break._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Break.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)">
            <inheritdoc cref="M:Scriptor.Compile.AST.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)"/>
        </member>
        <member name="M:Scriptor.Compile.AST.Break.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Break._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Break._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Block.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Block.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Block.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Block.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Block.EndWithLabel">
            <summary>
            A label placed right before envframe freeing and returns.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Block.FinalCast">
            <summary>
            The cast applied to the last argument of the block (False by default).
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.Block.FinalizeUnifiers(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Block._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Block.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Block._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Block.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Array.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Array.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Array.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Array.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Array._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Array.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Array._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Array.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Tuple.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Tuple.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Tuple.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Tuple.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Tuple._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Tuple.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Tuple._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Tuple.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Number.PossibleTypes">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Number.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Number._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Number.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Number._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Number._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Number.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.DefaultValue.PossibleTypes">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.DefaultValue.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.DefaultValue._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.DefaultValue.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.DefaultValue._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.DefaultValue._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.DefaultValue.NarrowestASTForPosition(Mizuhashi.PositionRange)">
            <inheritdoc/>
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.TypedValue`1.PossibleTypes">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.TypedValue`1.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypedValue`1._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypedValue`1.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypedValue`1._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypedValue`1._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.TypedValue`1.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InvokedMacro.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InvokedMacro.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InvokedMacro.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InvokedMacro.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InvokedMacro._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InvokedMacro.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InvokedMacro._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InvokedMacro._ToSemanticTokens">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InstanceFailure.Overloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InstanceFailure.Arguments">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InstanceFailure.RealizableOverloads">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.InstanceFailure.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InstanceFailure.FirstPassExceptions">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InstanceFailure.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InstanceFailure._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.InstanceFailure._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Failure.PossibleTypes">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Failure.SelectedOverload">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.AST.Failure.Completions">
            <summary>
            Completion information for language server.
            <br/>Left: A list of methods for completion, or if null, all possible completions.
            <br/>Right: A failed member access for Type.Name.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.AST.Failure.IsTypeCompletion">
            <summary>
            Completion information for language server.
            True if this error was due to a type that could not be parsed.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.AST.Failure.FirstPassExceptions">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Failure.Explain">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Failure._ToSymbolTree(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.AST.Failure._RealizeWithoutCast(Scriptor.Expressions.TExArgCtx)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ScriptFn`1">
            <summary>
            A script function that returns a value of type T.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.ErasedScriptFn">
            <summary>
            A script function whose return value is ignored.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.CompileHelpers">
            <summary>
            Helpers for end-to-end script compilation.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.CompileHelpers.OutEnvFrameArg">
            <summary>
            `out EnvFrame $scriptEf` argument.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.Parse(System.String@,Scriptor.Definition.LexerMetadata@)">
            <summary>
            (Stage 0) Convert the provided script into an ST.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.ParseAnnotate(System.String@,Scriptor.Reflection.IDelegateArg[])">
            <summary>
            (Stage 1) Convert the provided script into an ST, then annotate it into an AST.
            <br/>This does not perform typechecking (<see cref="M:Scriptor.Compile.CompileHelpers.Typecheck(Scriptor.Compile.IAST,Scriptor.Analysis.LexicalScope,System.Type,System.Type@)"/>).
            <br/>The AST may have errors (<see cref="M:Scriptor.Compile.IAST.FirstPassExceptions"/>). However, these can be thrown *after*
             initial typechecking.
            </summary>
            <param name="source">Script code</param>
            <param name="args">Top-level script arguments</param>
            <returns></returns>
            <exception cref="T:Scriptor.ReflectionException">Thrown when the script could not be parsed or there are basic errors in the AST.</exception>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.Typecheck(Scriptor.Compile.IAST,Scriptor.Analysis.LexicalScope,System.Type,System.Type@)">
            <summary>
            (Stage 2) Typecheck the provided AST. 
            </summary>
            <param name="ast">The AST to typecheck (as returned by <see cref="M:Scriptor.Compile.CompileHelpers.ParseAnnotate(System.String@,Scriptor.Reflection.IDelegateArg[])"/>).</param>
            <param name="rootScope">The top-level scope of the AST (as returned by <see cref="M:Scriptor.Compile.CompileHelpers.ParseAnnotate(System.String@,Scriptor.Reflection.IDelegateArg[])"/>).</param>
            <param name="finalType">The required output type of the AST (eg. Vector3 or TP or StateMachine).</param>
            <param name="resultType">The actual output type of the AST (eg. Vector3 or TP or StateMachine).</param>
            <returns>The typechecked AST.</returns>
            <exception cref="T:System.Exception">Thrown when there are typechecking errors or if there are <see cref="M:Scriptor.Compile.IAST.FirstPassExceptions"/> errors.</exception>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.Finalize(Scriptor.Compile.IAST)">
            <inheritdoc cref="M:Scriptor.Compile.IAST.Verify"/>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.Compile``1(Scriptor.Compile.IAST,Scriptor.Reflection.IDelegateArg[])">
            <summary>
            (Stage 4) Realize the AST into an expression function, then compile it into a delegate.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.ParseAndCompileDelegate``1(System.String,Scriptor.Reflection.IDelegateArg[])">
            <summary>
            Runs all four stages of script parsing (<see cref="M:Scriptor.Compile.CompileHelpers.ParseAnnotate(System.String@,Scriptor.Reflection.IDelegateArg[])"/>, <see cref="M:Scriptor.Compile.CompileHelpers.Typecheck(Scriptor.Compile.IAST,Scriptor.Analysis.LexicalScope,System.Type,System.Type@)"/>,
            <see cref="M:Scriptor.Compile.CompileHelpers.Finalize(Scriptor.Compile.IAST)"/>, <see cref="M:Scriptor.Compile.CompileHelpers.Compile``1(Scriptor.Compile.IAST,Scriptor.Reflection.IDelegateArg[])"/>) on a script.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.ParseAndCompileValue``1(System.String)">
            <summary>
            Parse a script as `ScriptFn{T}`, then execute it and return the object + EF.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.CompileHelpers.ParseAndCompileErased(System.String)">
            <summary>
            Parse a script as `ErasedScriptFn`, then execute it and return the EF.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.DefaultGlobalScope">
            <summary>
            A basic implementation of <see cref="T:Scriptor.Analysis.GlobalScope"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.DefaultGlobalScope.ExtensionTypes">
            <summary>
            Types queried for extension methods.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.DefaultGlobalScope.Resolver">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultGlobalScope.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultGlobalScope.StaticMethodDeclaration(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultGlobalScope.GetConverterForCompiledExpressionType(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultGlobalScope.TryFindLowPriorityConversion(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.DefaultLangCustomizer">
            <summary>
            A basic implementation of <see cref="T:Scriptor.Compile.ILangCustomizer"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.#ctor">
            <inheritdoc cref="T:Scriptor.Compile.DefaultLangCustomizer"/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#CompileDelegate``1(System.Func{Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx},Scriptor.Reflection.IDelegateArg[])">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#Import">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#AOTMode">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#TryFindLocalizedStringReference(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#Declare(Scriptor.Analysis.LexicalScope,Mizuhashi.PositionRange,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#Extend(Scriptor.Analysis.LexicalScope,Mizuhashi.PositionRange,System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#AttachEFToLambdaLikeObject(Scriptor.Compile.AST,BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#AttachScopeToScopeAwareObject(Scriptor.Expressions.TExArgCtx,System.Linq.Expressions.Expression,System.Type,Scriptor.Analysis.LexicalScope)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#CustomSymbolTree(Scriptor.Compile.IDebugAST)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.DefaultLangCustomizer.Scriptor#Compile#ILangCustomizer#FromMethod(Scriptor.Reflection.IMethodSignature,Mizuhashi.PositionRange,System.String,System.Type)">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.IAST.Params">
            <summary>
            All ASTs that are direct children of this.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.IAST.EnclosingScope">
            <summary>
            The scope inside which this AST is declared.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.EnumeratePreorder">
            <summary>
            Get all nodes in this tree, enumerated in preorder.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.EnumerateByLevel">
            <summary>
            Get all nodes in this tree, enumerated breadth-first.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.SetDiagnostics(Scriptor.Reflection.ReflectDiagnostic[])">
            <summary>
            Set warnings and other non-fatal messages on this level of the AST.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.WarnUsage">
            <summary>
            Report warnings and other non-fatal messages on all nested levels of the AST.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.FirstPassExceptions">
            <summary>
            (Stage 1) Returns all errors in the parse tree that prevent it from being typechecked.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.Typecheck(Scriptor.Compile.IAST,BagoumLib.Unification.TypeResolver,Scriptor.Analysis.LexicalScope,System.Type)">
            <summary>
            (Stage 2) A function called on the root AST to typecheck the entire structure.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.Verify">
            <summary>
            (Stage 3) Verify that types, declarations, etc. are sound, and make simplifications/specializations based on the full AST context.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.ReplaceScope(Scriptor.Analysis.LexicalScope,Scriptor.Analysis.LexicalScope)">
            <summary>
            Call this function to insert a scope `inserted` below the scope `prev` in descendants of this tree.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IAST.Realize(Scriptor.Expressions.TExArgCtx)">
            <summary>
            (Stage 4) Create an executable script out of this AST. Specifically, if the return type provided to
             <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/> is T, then this function returns a TEx&lt;T&gt;,
             which the caller can be compile into a delegate with any top-level arguments.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.IDebugAST.Position">
            <summary>
            Position of the code that will generate this object.
            <br/>This is used for debugging/logging/error messaging.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IDebugAST.NarrowestASTForPosition(Mizuhashi.PositionRange)">
            <summary>
            Return the furthest-down AST in the tree that encloses the given position,
            then its ancestors up to the root.
            <br/>Each element is paired with the index of the child that preceded it,
             or null if it is the lowermost AST returned.
            <br/>Returns null if the AST does not enclose the given position.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IDebugAST.Explain">
            <summary>
            Print out a readable, preferably one-line description of the AST (not including its children). Consumed by language server.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IDebugAST.ToSymbolTree(System.String)">
            <summary>
            Return a parse tree for the AST. Consumed by language server.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.IDebugAST.ToSemanticTokens">
            <summary>
            Describe the semantics of all the parsed tokens in the source code.
            Consumed by language server.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.SemanticToken">
            <summary>
            A lexed parsing token that has a purpose.
            </summary>
            <param name="Position">Position of the token in the source code</param>
            <param name="TokenType">Token type</param>
            <param name="TokenMods">Token modifiers</param>
        </member>
        <member name="M:Scriptor.Compile.SemanticToken.#ctor(Mizuhashi.PositionRange,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            A lexed parsing token that has a purpose.
            </summary>
            <param name="Position">Position of the token in the source code</param>
            <param name="TokenType">Token type</param>
            <param name="TokenMods">Token modifiers</param>
        </member>
        <member name="P:Scriptor.Compile.SemanticToken.Position">
            <summary>Position of the token in the source code</summary>
        </member>
        <member name="P:Scriptor.Compile.SemanticToken.TokenType">
            <summary>Token type</summary>
        </member>
        <member name="P:Scriptor.Compile.SemanticToken.TokenMods">
            <summary>Token modifiers</summary>
        </member>
        <member name="M:Scriptor.Compile.SemanticToken.WithConst(System.Boolean)">
            <summary>
            Create a semantic token that is the same as this, but is marked as constant.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.ILangCustomizer">
            <summary>
            An external provider for language customization and expression-to-delegate compilation.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.CompileDelegate``1(System.Func{Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx},Scriptor.Reflection.IDelegateArg[])">
            <inheritdoc cref="M:Scriptor.Compile.ILangCustomizer.CompileDelegate(System.Type,System.Func{Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx},Scriptor.Reflection.IDelegateArg[])"/>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.CompileDelegate(System.Type,System.Func{Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx},Scriptor.Reflection.IDelegateArg[])">
            <summary>
            Compile a delegate from an expression.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.ILangCustomizer.Import">
            <summary>
            Execute an import configured in <see cref="T:Scriptor.Compile.ST.Import"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.ILangCustomizer.AOTMode">
            <inheritdoc cref="T:Scriptor.AOTMode"/>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.TryFindLocalizedStringReference(System.String)">
            <summary>
            Try to retrieve the localized string with the key configured by `content`.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.Declare(Scriptor.Analysis.LexicalScope,Mizuhashi.PositionRange,System.Int32)">
            <summary>
            Auto-declare variables in a lexical scope based on an int key.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.Extend(Scriptor.Analysis.LexicalScope,Mizuhashi.PositionRange,System.Int32,System.String)">
            <summary>
            Auto-extend declared variables in a lexical scope based on an int key.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.AttachEFToLambdaLikeObject(Scriptor.Compile.AST,BagoumLib.Unification.Unifier)">
            <summary>
            If this AST has a local scope, then modify the highest non-assign method calls returning a lambda-like object
             immediately within this local scope such that the executing EnvFrame is attached to them.
            <br/>In DMK, lambda-like types are StateMachine, AsyncPattern, and SyncPattern.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.AttachScopeToScopeAwareObject(Scriptor.Expressions.TExArgCtx,System.Linq.Expressions.Expression,System.Type,Scriptor.Analysis.LexicalScope)">
            <summary>
            For a method call defining a local scope,
             attach that local scope to the values constructed by direct children if they are scope-aware.
            <br/>In DMK, scope-aware types are StateMachine and GenCtxProperties.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.CustomSymbolTree(Scriptor.Compile.IDebugAST)">
            <summary>
            Implement custom logic for generating a symbol tree in the language server.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ILangCustomizer.FromMethod(Scriptor.Reflection.IMethodSignature,Mizuhashi.PositionRange,System.String,System.Type)">
            <summary>
            Create a semantic token for a method invocation.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.PartialFn">
            <summary>
            Helpers for partial function compilation/execution.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.PartialFn.Execute(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Boolean)">
            <inheritdoc cref="M:Scriptor.Compile.PartialFn.Execute(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])"/>
        </member>
        <member name="M:Scriptor.Compile.PartialFn.Execute(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <summary>
            Create an expression representing the execution of an Action/Func.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.PartialFn.PartiallyApply(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
            <summary>
            Create an expression representing the partial application of an Action/Func.
            <br/>eg. PartiallyApply(Func{int,string,bool}, int) => Func{string,bool}
            </summary>
        </member>
        <member name="M:Scriptor.Compile.PartialFn.PartiallyApply(BagoumLib.Unification.TypeDesignation.Dummy,System.Int32,System.Boolean)">
            <summary>
            Given a function type (A,B,C...)->X, return a partially applied type
                (A,B)->Func&lt;C...X&gt;.
            <br/>If prependOriginal is set, returns the general partial application type 
                (Func&lt;A,B,C...X&gt;,A,B)->Func&lt;C...X&gt;.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.PartialFn.PartiallyUnApply(BagoumLib.Unification.TypeDesignation.Dummy,System.Int32,System.Boolean)">
            <summary>
            Undo <see cref="M:Scriptor.Compile.PartialFn.PartiallyApply(BagoumLib.Unification.TypeDesignation.Dummy,System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.PartialFn.MakeFuncType(BagoumLib.Unification.TypeDesignation[])">
            <summary>
            Return a TypeDesignation representing a C# Func type (or Action type if typeArgs[^1] = void).
            </summary>
        </member>
        <member name="T:Scriptor.Compile.ST">
            <summary>
            A syntax tree formed by parsing.
            <br/>The syntax tree has no knowledge of bindings or types that are not explicitly declared,
            but it can be transformed into an <see cref="T:Scriptor.Compile.IAST"/> that does.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.#ctor(Mizuhashi.PositionRange)">
            <summary>
            A syntax tree formed by parsing.
            <br/>The syntax tree has no knowledge of bindings or types that are not explicitly declared,
            but it can be transformed into an <see cref="T:Scriptor.Compile.IAST"/> that does.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc cref="M:Scriptor.Compile.ST.Annotate(Scriptor.Compile.STAnnotater)"/>
        </member>
        <member name="M:Scriptor.Compile.ST.Annotate(Scriptor.Compile.STAnnotater)">
            <summary>
            Annotate this syntax tree with types and bindings.
            The resulting AST may contain <see cref="T:Scriptor.Compile.AST.Failure"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.DebugPrint">
            <summary>
            Print a readable description of the entire syntax tree.
            </summary>
        </member>
        <member name="T:Scriptor.Compile.ST.Ident">
            <summary>
            An identifier that may be for a function or variable or type, etc.
            </summary>
            <param name="Position">Position of the identifier in the source.</param>
            <param name="Name">Name of the identifier.</param>
            <param name="Generic">Whether this identifier is generic, ie. contains &lt;&gt; or array markings []. A generic identifier cannot be a variable.</param>
        </member>
        <member name="M:Scriptor.Compile.ST.Ident.#ctor(Mizuhashi.PositionRange,System.String,System.Boolean)">
            <summary>
            An identifier that may be for a function or variable or type, etc.
            </summary>
            <param name="Position">Position of the identifier in the source.</param>
            <param name="Name">Name of the identifier.</param>
            <param name="Generic">Whether this identifier is generic, ie. contains &lt;&gt; or array markings []. A generic identifier cannot be a variable.</param>
        </member>
        <member name="P:Scriptor.Compile.ST.Ident.Name">
            <summary>Name of the identifier.</summary>
        </member>
        <member name="P:Scriptor.Compile.ST.Ident.Generic">
            <summary>Whether this identifier is generic, ie. contains &lt;&gt; or array markings []. A generic identifier cannot be a variable.</summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Ident.TryFindVariable(Mizuhashi.PositionRange,Scriptor.Compile.ST.Ident,Scriptor.Analysis.ScriptImport,Scriptor.Analysis.LexicalScope)">
            <summary>
            Try to reference the variable with name `id`, defined in the scope of `inImport` (if provided)
             else in `scope`.
            <br/>If there is no such script function, return null.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Ident._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Ident.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.FnIdent">
            <summary>
            An identifier that is known to be for a static method. This is generally only constructed by operators.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.FnIdent.#ctor(Mizuhashi.PositionRange,Scriptor.Reflection.InvokedMethod[])">
            <summary>
            An identifier that is known to be for a static method. This is generally only constructed by operators.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.FnIdent._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.FnIdent.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Import._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Import.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Return">
            <summary>
            A return statement.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Return.#ctor(Mizuhashi.PositionRange,Scriptor.Compile.ST)">
            <summary>
            A return statement.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Return._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Return.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Continue">
            <summary>
            A continue statement.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Continue.#ctor(Mizuhashi.PositionRange)">
            <summary>
            A continue statement.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Continue._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Continue.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Break">
            <summary>
            A break statement.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Break.#ctor(Mizuhashi.PositionRange)">
            <summary>
            A break statement.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Break._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Break.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.VarDeclAssign">
            <summary>
            A joint declaration-assignment, such as `var x = 5`.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.VarDeclAssign.#ctor(Scriptor.Definition.Lexer.Token,Scriptor.Definition.Lexer.Token,System.Nullable{Scriptor.Definition.Lexer.Token},Mizuhashi.PositionRange,Scriptor.Compile.ST)">
            <summary>
            A joint declaration-assignment, such as `var x = 5`.
            </summary>
        </member>
        <member name="F:Scriptor.Compile.ST.VarDeclAssign.VarInitialize">
            <inheritdoc cref="M:Scriptor.Math.ExMAssign.VariableInitialize``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})"/>
        </member>
        <member name="M:Scriptor.Compile.ST.VarDeclAssign._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.VarDeclAssign.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.MemberAccess">
            <summary>
            A member access `x.y`.
            `x` may be an import name, in which case this is an imported script member,
            or `x` may be a type name, in which case this is a static member,
            or `x` may be a variable, in which case this is an instance member.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.MemberAccess.#ctor(Scriptor.Compile.ST,Scriptor.Compile.ST.Ident)">
            <summary>
            A member access `x.y`.
            `x` may be an import name, in which case this is an imported script member,
            or `x` may be a type name, in which case this is a static member,
            or `x` may be a variable, in which case this is an instance member.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.MemberAccess._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.MemberAccess.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.MemberFunction">
            <summary>
            A member function call `x.f(y)`.
            `x` may be an import name, in which case this is an imported script function,
            or `x` may be a type name, in which case this is a static function,
            or `x` may be a variable, in which case this is an instance function.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.MemberFunction.#ctor(Mizuhashi.PositionRange,Scriptor.Compile.ST,Scriptor.Compile.ST.Ident,System.Collections.Generic.List{Scriptor.Compile.ST})">
            <summary>
            A member function call `x.f(y)`.
            `x` may be an import name, in which case this is an imported script function,
            or `x` may be a type name, in which case this is a static function,
            or `x` may be a variable, in which case this is an instance function.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.MemberFunction._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.MemberFunction.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Indexer._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Indexer.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.FunctionCall">
            <summary>
            A C#-style function call with parentheses and commas, such as `f(x, y)`,
             or an operator-based function call such as `x + y`.
            <br/>Note that there must be no spaces before the parentheses.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.FunctionCall.#ctor(Mizuhashi.PositionRange,Scriptor.Compile.ST,Scriptor.Compile.ST[])">
            <summary>
            A C#-style function call with parentheses and commas, such as `f(x, y)`,
             or an operator-based function call such as `x + y`.
            <br/>Note that there must be no spaces before the parentheses.
            </summary>
        </member>
        <member name="P:Scriptor.Compile.ST.FunctionCall.OverloadsInterchangeable">
            <inheritdoc cref="P:BagoumLib.Unification.IMethodTypeTree`1.OverloadsAreInterchangeable"/>
        </member>
        <member name="M:Scriptor.Compile.ST.FunctionCall.LoadScriptFnDecl(Mizuhashi.PositionRange,Scriptor.Compile.ST.Ident,Scriptor.Analysis.ScriptImport,Scriptor.Compile.STAnnotater,System.Collections.Generic.IReadOnlyList{Scriptor.Compile.ST})">
            <summary>
            Try to invoke the script function with name `id`, defined in the ann.Scope of `inImport` (if provided)
             else in `scope`.
            <br/>If there is no such script function, return null.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.FunctionCall._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.FunctionCall.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Constructor._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Constructor.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.PartialFunctionCall">
            <summary>
            A function call that explicitly declares possibly fewer arguments than required by the function.
            <br/>In the form $(f, a1, a2, a3); where in this case function f requires 3 or more arguments.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.PartialFunctionCall.#ctor(Mizuhashi.PositionRange,Scriptor.Compile.ST,Scriptor.Compile.ST[])">
            <summary>
            A function call that explicitly declares possibly fewer arguments than required by the function.
            <br/>In the form $(f, a1, a2, a3); where in this case function f requires 3 or more arguments.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.PartialFunctionCall._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.PartialFunctionCall.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.CurriedFunctionCall">
            <summary>
            A Haskell-style curried function call, such as `f x`.
            <br/>In cases where multiple arguments are applied, this is constructed left-associatively as
             `f x y z` = P(P(P(f, x), y), z).
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.CurriedFunctionCall.#ctor(Scriptor.Compile.ST,Scriptor.Compile.ST)">
            <summary>
            A Haskell-style curried function call, such as `f x`.
            <br/>In cases where multiple arguments are applied, this is constructed left-associatively as
             `f x y z` = P(P(P(f, x), y), z).
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.CurriedFunctionCall._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.CurriedFunctionCall.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.TypeAs._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.TypeAs.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.MacroDef._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.MacroDef.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Compile.ST.FunctionDef.ConstKwPos">
            <summary>
            Position of the `const` keyword for this function def, if it exists.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.FunctionDef._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.FunctionDef.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Block">
            <summary>
            A block of statements.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Block.#ctor(Mizuhashi.PositionRange,System.Collections.Generic.IReadOnlyList{Scriptor.Compile.ST})">
            <summary>
            A block of statements.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Block._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Block.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.IfExpression">
            <summary>
            An if expression (x ? y : z) that returns one of two values.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.IfExpression.#ctor(Scriptor.Compile.ST,Scriptor.Compile.ST,Scriptor.Compile.ST)">
            <summary>
            An if expression (x ? y : z) that returns one of two values.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.IfExpression._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.IfExpression.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.IfStatement">
            <summary>
            An if statement (if (x) { y; } else { z; }) with an optional else.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.IfStatement.#ctor(Mizuhashi.PositionRange,System.Nullable{Mizuhashi.PositionRange},Scriptor.Compile.ST,Scriptor.Compile.ST.Block,Scriptor.Compile.ST)">
            <summary>
            An if statement (if (x) { y; } else { z; }) with an optional else.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.IfStatement._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.IfStatement.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Loop">
            <summary>
            An for or while loop.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Loop.#ctor(Mizuhashi.PositionRange,Scriptor.Compile.ST,Scriptor.Compile.ST,Scriptor.Compile.ST,Scriptor.Compile.ST.Block)">
            <summary>
            An for or while loop.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Loop._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Loop.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Array">
            <summary>
            An array of items with the same type.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Array.#ctor(Mizuhashi.PositionRange,System.Nullable{Scriptor.Definition.Lexer.Token},Scriptor.Compile.ST[])">
            <summary>
            An array of items with the same type.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Array._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Array.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Number">
            <summary>
            A number such as `5.0`. This is not included in TypedValue since numbers can have their type
             auto-determined (eg. float vs int) based on usage.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Number.#ctor(Mizuhashi.PositionRange,System.String)">
            <summary>
            A number such as `5.0`. This is not included in TypedValue since numbers can have their type
             auto-determined (eg. float vs int) based on usage.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Number._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Number.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.DefaultValue">
            <summary>
            A keyword returning either the default value of an optional function argument or the default value of a type.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.DefaultValue.#ctor(Mizuhashi.PositionRange,System.Nullable{Scriptor.Definition.Lexer.Token},System.Boolean)">
            <summary>
            A keyword returning either the default value of an optional function argument or the default value of a type.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.DefaultValue._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.DefaultValue.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.TypedValue`1">
            <summary>
            A fixed value of a type not subject to type auto-determination, such as strings, but not numbers.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.TypedValue`1.#ctor(Mizuhashi.PositionRange,`0)">
            <summary>
            A fixed value of a type not subject to type auto-determination, such as strings, but not numbers.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.TypedValue`1._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.TypedValue`1.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Tuple">
            <summary>
            A tuple.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Tuple.#ctor(Mizuhashi.PositionRange,System.Collections.Generic.List{Scriptor.Compile.ST})">
            <summary>
            A tuple.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Tuple._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Tuple.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Compile.ST.Failure">
            <summary>
            A failed syntax tree parse.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Failure.#ctor(Mizuhashi.PositionRange,System.String)">
            <summary>
            A failed syntax tree parse.
            </summary>
        </member>
        <member name="M:Scriptor.Compile.ST.Failure._AnnotateInner(Scriptor.Compile.STAnnotater)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Compile.ST.Failure.DebugPrint">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Definition.LangParser">
            <summary>
            Parser for BDSL2.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Scriptor.Definition.LangParser.SoftFailOnUnmatchedLString" -->
        <member name="M:Scriptor.Definition.LangParser.TypeFromString(System.String)">
            <summary>
            Try to parse a string as a C# type; otherwise, return an error string.
            </summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.Meth(System.Type,System.String)">
            <summary>
            Create a <see cref="T:Scriptor.Reflection.MethodSignature"/> for the method on type `t` named `method`.
            </summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.Parse(System.String,Scriptor.Definition.Lexer.Token[],Mizuhashi.InputStream{Scriptor.Definition.Lexer.Token}@)">
            <summary>
            Parse the provided tokens into a syntax tree.
            </summary>
        </member>
        <member name="T:Scriptor.Definition.LangParser.TypeDef">
            <summary>
            A descriptor of an uncompiled type.
            </summary>
        </member>
        <member name="P:Scriptor.Definition.LangParser.TypeDef.GenericToType">
            <summary>
            Mapping from count to all types with that number of generic type parameters.
            </summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.TypeDef.TryCompile">
            <summary>
            Compile this descriptor into a type, or return an error message.
            </summary>
        </member>
        <member name="T:Scriptor.Definition.LangParser.TypeDef.Atom">
            <summary>
            An atomic type.
            </summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.TypeDef.Atom.#ctor(System.String)">
            <summary>
            An atomic type.
            </summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.TypeDef.Atom.TryCompile">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Definition.LangParser.TypeDef.Generic">
            <summary>
            A type T&lt;T1,T2..&gt;
            </summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.TypeDef.Generic.#ctor(System.String,System.Collections.Generic.List{Scriptor.Definition.LangParser.TypeDef})">
            <summary>
            A type T&lt;T1,T2..&gt;
            </summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.TypeDef.Generic.TryCompile">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Definition.LangParser.TypeDef.Array">
            <summary>
            A type T[].
            </summary>
            <param name="Arg"></param>
        </member>
        <member name="M:Scriptor.Definition.LangParser.TypeDef.Array.#ctor(Scriptor.Definition.LangParser.TypeDef)">
            <summary>
            A type T[].
            </summary>
            <param name="Arg"></param>
        </member>
        <member name="P:Scriptor.Definition.LangParser.TypeDef.Array.Arg">
            <summary></summary>
        </member>
        <member name="M:Scriptor.Definition.LangParser.TypeDef.Array.TryCompile">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Definition.Lexer">
            <summary>
            Lexer for BDSL2.
            </summary>
        </member>
        <member name="T:Scriptor.Definition.Lexer.TokenFlags">
            <summary>
            A set of flags describing lexical features about the token.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenFlags.PrecededByNewline">
            <summary>
            This token is preceded by no tokens other than whitespace until the previous newline.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenFlags.PrecededByWhitespace">
            <summary>
            This token is directly preceded by whitespace or a newline.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenFlags.PostcededByWhitespace">
            <summary>
            This token is directly postceded by whitespace or a newline.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenFlags.ImplicitBreak">
            <summary>
            This token is preceded by an implicit semicolon/comma due to indenting layout rules,
             and therefore should not be taken as a partial function application argument.
            </summary>
        </member>
        <member name="T:Scriptor.Definition.Lexer.TokenType">
            <summary>
            The type of the token.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.InlineWhitespace">
            <summary>
            Non-newline whitespaces.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.Newline">
            <summary>
            Newline whitespace (only \n).
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.Comment">
            <summary>
            Comment (either /* block comment */ or  // one-line comment).
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.Keyword">
            <summary>
            A reserved keyword (that would otherwise be parsed as an identifier).
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.ValueKeyword">
            <summary>
            Value-based keywords except for "null" (ie. just "true" and "false").
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.NullKeyword">
            <summary>
            The keyword "null".
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.DefaultKeyword">
            <summary>
            The keyword "default", used for default function parameters.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.SpecialOperator">
            <summary>
            A special operator, such as :: or ->, which has functionality more
             advanced than calling a function.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.Operator">
            <summary>
            A operator that calls a function, such as + or *.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.OpenParen">
            <summary>
            Open parentheses, (
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.CloseParen">
            <summary>
            Close parentheses, )
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.OpenBracket">
            <summary>
            Open bracket, [
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.CloseBracket">
            <summary>
            Close bracket, ]
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.OpenBrace">
            <summary>
            Open brace, {
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.CloseBrace">
            <summary>
            Close brace, }
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.Identifier">
            <summary>
            An identifier that may be for a variable or method or class or type, etc.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.TypeIdentifier">
            <summary>
            An identifier that must be for a method or class or type, and not for a variable.
            <br/>Might be generic (eg. List&lt;int&gt;) or array-typed (eg. int[]) or some combination thereof.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.V2RV2">
            <summary>
            A V2RV2 in the format &lt;NX;NY:RX;RY:ANG&gt;.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.Number">
            <summary>
            A number (integer or float). Can be preceded by signs and postceded by numerical multipliers pi, p, h, c, s.
            <br/>Can also be the code `inf`.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.String">
            <summary>
            Strings, bounded by " ".
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.Char">
            <summary>
            Chars, bounded by ' '.
            </summary>
        </member>
        <member name="F:Scriptor.Definition.Lexer.TokenType.LString">
            <summary>
            Localized strings, prefixed with :.
            </summary>
        </member>
        <member name="P:Scriptor.Definition.Lexer.Token.Position">
            <summary>
            The position of this token in the source string.
            </summary>
        </member>
        <member name="P:Scriptor.Definition.Lexer.Token.Type">
            <inheritdoc cref="T:Scriptor.Definition.Lexer.TokenType"/>
        </member>
        <member name="P:Scriptor.Definition.Lexer.Token.Flags">
            <inheritdoc cref="T:Scriptor.Definition.Lexer.TokenFlags"/>
        </member>
        <member name="P:Scriptor.Definition.Lexer.Token.Index">
            <summary>
            The starting index of this token in the source string.
            </summary>
        </member>
        <member name="M:Scriptor.Definition.Lexer.Lex(System.String@,Scriptor.Definition.LexerMetadata@)">
            <summary>
            Lex the string into a sequence of tokens, discarding whitespace/newlines
             and throwing exceptions if parentheses are unbalanced.
            </summary>
            <param name="source">Source string</param>
            <param name="metadata">Metadata produced by lexing that is not critical to parsing (eg. comments)</param>
        </member>
        <member name="M:Scriptor.Definition.Lexer.Lex(System.String)">
            <inheritdoc cref="M:Scriptor.Definition.Lexer.Lex(System.String@,Scriptor.Definition.LexerMetadata@)"/>
        </member>
        <member name="M:Scriptor.Definition.Lexer.Lex(System.String@,Mizuhashi.InputStream{Scriptor.Definition.Lexer.Token}@,Scriptor.Definition.LexerMetadata@)">
            <inheritdoc cref="M:Scriptor.Definition.Lexer.Lex(System.String@,Scriptor.Definition.LexerMetadata@)"/>
        </member>
        <member name="T:Scriptor.AOTMode">
            <summary>
            The type of AOT compilation being used.
            </summary>
        </member>
        <member name="F:Scriptor.AOTMode.None">
            <summary>
            Not AOT. Expression compilation is fully allowed.
            </summary>
        </member>
        <member name="F:Scriptor.AOTMode.Save">
            <summary>
            Pre-compiling expressions for eventual AOT usage.
            </summary>
        </member>
        <member name="F:Scriptor.AOTMode.Load">
            <summary>
            In an AOT context, loading pre-compiled expressions.
            </summary>
        </member>
        <member name="T:Scriptor.MethodFlags">
            <summary>
            Flags attached to a <see cref="T:Scriptor.Reflection.IMethodSignature"/>.
            </summary>
        </member>
        <member name="F:Scriptor.MethodFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:Scriptor.MethodFlags.ConstableAny">
            <summary>
            The method can be treated as a constant function in AOT or non-AOT contexts.
            <br/>If set to true, the return value of this method must be printable by expression-to-code converters.
            </summary>
        </member>
        <member name="F:Scriptor.MethodFlags.ConstableNonAOT">
            <summary>
            The method can be treated as a constant function in non-AOT contexts only.
            </summary>
        </member>
        <member name="T:Scriptor.StaticException">
            <summary>
            An exception thrown due incorrect compile-time behavior.
            </summary>
        </member>
        <member name="T:Scriptor.ReflectionException">
            <summary>
            An exception thrown due to problems in reflection or script parsing.
            </summary>
        </member>
        <member name="T:Scriptor.BadTypeException">
            <summary>
            An exception thrown when the type of an expression is incorrect.
            </summary>
        </member>
        <member name="T:Scriptor.CompileException">
            <summary>
            An exception thrown due a failure in expression compilation.
            </summary>
        </member>
        <member name="T:Scriptor.Expressions.ExBakeTracker">
            <summary>
            Helper class for tracking AOT compilation data.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExBakeTracker.NextProxyArg">
            <summary>
            The next identifier for a proxy argument.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Expressions.ExBakeTracker.Proxy(System.Object,System.Type)">
            <summary>
            Store a non-printable argument so it can be used to generate
             a script as a function or provide arguments to such a function.
            </summary>
        </member>
        <member name="T:Scriptor.Expressions.ExBakeTracker.None">
            <summary>
            No support for AOT compilation.
            </summary>
        </member>
        <member name="T:Scriptor.Expressions.ExBakeTracker.Save">
            <summary>
            AOT compilation in save mode, tracking replacements and declarations
             in order to allow printing expressions into code.
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.ExBakeTracker.Save.HoistedVariables">
            <summary>
            Variable declarations hoisted above the lambdas of compiled expressions.
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.ExBakeTracker.Save.HoistedReplacements">
            <summary>
            Replacements matching an expression in the source tree to a simplified expression
             (eg. to a hoisted variable declaration or function argument).
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.ExBakeTracker.Save.HoistedConstants">
            <summary>
            Replacements matching a constant value that may occur in ConstantExpression to a simplified expression
             (eg. to a hoisted variable declaration or function argument).
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.ExBakeTracker.Save.RecursiveFunctions">
            <summary>
            Replacements matching an expression for calling a function recursively to its script declaration.
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.ExBakeTracker.Save.ProxyTypes">
            <summary>
            The types and names of the arguments used if this represents a function.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExBakeTracker.Save.Proxy(System.Object,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Expressions.ExBakeTracker.Load">
            <summary>
            AOT compilation in load mode, tracking proxy arguments to provide
             to pre-compiled functions from <see cref="T:Scriptor.Expressions.ExBakeTracker.Save"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.ExBakeTracker.Load.ProxyArguments">
            <summary>
            Arguments to be provided to a pre-compiled function.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExBakeTracker.Load.Proxy(System.Object,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Expressions.ExHelpers">
            <summary>
            Helper methods for expressions.
            </summary>
        </member>
        <member name="F:Scriptor.Expressions.ExHelpers.tfloat">
            <summary>
            typeof(float)
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExHelpers.MakeArg``1(System.String,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Scriptor.Expressions.ExHelpers.MakeAnyArg(System.Type,System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Scriptor.Expressions.ExHelpers.MakeAnyArg(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configure an argument for <see cref="T:Scriptor.Expressions.TExArgCtx"/>.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExHelpers.TryFlattenConversion(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            If `body` is a constant, then cast it to type `toTyp` and return a constant expression.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExHelpers.VFloat(System.String)">
            <summary>
            Create a float variable.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExHelpers.AssertWriteable(System.Int32,System.Object)">
            <summary>
            Return an exception if the provided expression is not writeable.
            <br/>Implementation based on https://source.dot.net/#System.Linq.Expressions/System/Linq/Expressions/Expression.cs,241
            </summary>
        </member>
        <member name="T:Scriptor.Expressions.ExMHelpers">
            <summary>
            Expression helpers for mathematical operations.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExMHelpers.ExC(System.Object)">
            <inheritdoc cref="M:System.Linq.Expressions.Expression.Constant(System.Object)"/>
        </member>
        <member name="M:Scriptor.Expressions.ExMHelpers.OfDFD(BagoumLib.Expressions.ExFunction,System.Linq.Expressions.Expression)">
            <summary>
            For a function f of type double->double, call it with any numeric argument
            and cast the result back to type float.
            <br/>This is what most Unity Mathf functions do internally.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExMHelpers.OfDFD(BagoumLib.Expressions.ExFunction,System.Linq.Expressions.Expression[])">
            <summary>
            For a function f of type (double,double...)->double, call it with any numeric arguments
            and cast the result back to type float.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.ExMHelpers.OfDTD``1(BagoumLib.Expressions.ExFunction,System.Linq.Expressions.Expression[])">
            <summary>
            For a function f of type (double,double...)->double, call it with any numeric arguments
            and cast the result back to type T.
            </summary>
        </member>
        <member name="T:Scriptor.Expressions.TEx">
            <summary>
            Base class for <see cref="T:Scriptor.Expressions.TEx`1"/> used for type constraints.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.TEx.Resolve``3(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``1},Scriptor.Expressions.TEx{``2},System.Func{Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``1},Scriptor.Expressions.TEx{``2},System.Linq.Expressions.Expression})">
            <summary>
            Copy the provided expressions into temporary variables that can be reused without recalculating the expression.
            </summary>
        </member>
        <member name="T:Scriptor.Expressions.TEx`1">
            <summary>
            A typed expression.
            <br/>This typing is syntactic sugar: any expression, regardless of type, can be cast as eg. TEx{float}.
            <br/>However, constructing a parameter expression via TEx{T} will type the expression appropriately.
            By default, creates a ParameterExpression.
            </summary>
            <typeparam name="T">Type of expression eg(float).</typeparam>
        </member>
        <member name="T:Scriptor.Expressions.TExArgCtx">
            <summary>
            An arbitrary set of arguments to an expression function.
            <br/>Expression functions are written in the general form Func&lt;TExArgCtx, TEx&lt;R&gt;&gt;
             and compiled to Func&lt;T1, T2..., R&gt;, where T1,T2... are types that have stored their information in TExArgCtx,
             and R is some standard return type like float or Vector2.
            </summary>
        </member>
        <member name="T:Scriptor.Expressions.TExArgCtx.RootCtx">
            <summary>
            Context that is shared by any copies of this.
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.TExArgCtx.RootCtx.AliasStack">
            <summary>
            Local variable aliases.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.TExArgCtx.RootCtx.NameWithSuffix(System.String)">
            <summary>
            Get a unique name for a variable declared in this compilation scope.
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.TExArgCtx.RootCtx.BakeTracker">
            <inheritdoc cref="T:Scriptor.Expressions.ExBakeTracker"/>
        </member>
        <member name="P:Scriptor.Expressions.TExArgCtx.RootCtx.CompileToField">
            <summary>
            If true, AOT compilation should store the compiled expression as a field.
            </summary>
        </member>
        <member name="P:Scriptor.Expressions.TExArgCtx.RootCtx.CompileAsScriptFn">
            <summary>
            If true, AOT compilation should store the compiled expression as a script function. 
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.TExArgCtx.RootCtx.#ctor">
            <inheritdoc cref="T:Scriptor.Expressions.TExArgCtx.RootCtx"/>
        </member>
        <member name="M:Scriptor.Expressions.TExArgCtx.Proxy``1(``0)">
            <summary>
            Handle baking/loading an argument to an expression-reflected function that is not itself an expression
             and cannot be trivially converted into a code representation.
            <br/>Returns the argument for chaining convenience.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.TExArgCtx.Proxy(System.Object)">
            <inheritdoc cref="M:Scriptor.Expressions.TExArgCtx.Proxy``1(``0)"/>
        </member>
        <member name="T:Scriptor.Expressions.TExExtensions">
            <summary>
            Extensions for TEx.
            </summary>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.TryAsConst``1(Scriptor.Expressions.TEx{``0},``0@)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.TryAsConst``1(System.Linq.Expressions.Expression,``0@)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Is``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Is(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Add``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Mul``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Mul(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Add``1(Scriptor.Expressions.TEx{``0},System.Single)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Add(System.Linq.Expressions.Expression,System.Single)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Sub``1(Scriptor.Expressions.TEx{``0},System.Single)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Sub(System.Linq.Expressions.Expression,System.Single)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Mul``1(Scriptor.Expressions.TEx{``0},System.Single)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Mul(System.Linq.Expressions.Expression,System.Single)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Sub``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Sub(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Div``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Div(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.LT``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.LT(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Leq``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.LT0``1(Scriptor.Expressions.TEx{``0})">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.LT0(System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.GT``1(Scriptor.Expressions.TEx{``0},System.Linq.Expressions.Expression)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.GT(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.GT0``1(Scriptor.Expressions.TEx{``0})">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.GT0(System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Expressions.TExExtensions.Field``1(Scriptor.Expressions.TEx{``0},System.String)">
            <inheritdoc cref="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)"/>
        </member>
        <member name="T:Scriptor.Extensions">
            <summary>
            Extensions for type manipulation in reflection.
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.DocCommentDisplay(Scriptor.Analysis.IDeclaration)">
            <summary>
            Render the doc comment for a declaration for language server consumption.
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.SimpRName(BagoumLib.Unification.TypeDesignation)">
            <summary>
            Get a simple description of the type `t`.
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.IsTExOrTExFuncType(System.Type,System.Type@)">
            <summary>
            If this type is of the form TEx&lt;R&gt; or TExArgCtx->TEx&lt;R&gt;, then return true and set inner to R.
            <br/>If this type is TEx or TExArgCtx->TEx, then return true and set inner to void.
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.IsTExType(System.Type,System.Type@)">
            <summary>
            If this type is of the form TEx&lt;R&gt;, then return true and set inner to R.
            <br/>If this type is TEx, then return true and set inner to void.
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.IsTExFuncType(System.Type,System.Type@)">
            <summary>
            If this type is of the form TExArgCtx->TEx&lt;R&gt;, then return true and set inner to R.
            <br/>If this type is TExArgCtx->TEx, then return true and set inner to void.
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.GetTExType(System.Type)">
            <summary>
            For a type T, get the type TEx&lt;T&gt; and its constructor.
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.MakeTypedTEx(System.Type,System.Linq.Expressions.Expression)">
            <summary>
            Cast an expression to the type TEx&lt;T&gt;. (If t is void, then cast the expression to type TEx.)
            </summary>
        </member>
        <member name="M:Scriptor.Extensions.MakeTypedLambda(System.Type,System.Func{Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx})">
            <summary>
            Retype the provided function as TExArgCtx -> TEx{T}. (If t is void, don't retype it.)
            </summary>
        </member>
        <member name="T:Scriptor.TExLambdaTyper">
            <summary>
            Convert Func&lt;TExArgCtx, TEx&gt; to Func&lt;TExArgCtx, TEx&lt;T&gt;&gt;.
            </summary>
        </member>
        <member name="M:Scriptor.TExLambdaTyper.Convert``1(System.Func{Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx})">
            <summary>
            Convert Func&lt;TExArgCtx, TEx&gt; to Func&lt;TExArgCtx, TEx&lt;T&gt;&gt; for a compile-time
             known type T.
            </summary>
        </member>
        <member name="M:Scriptor.TExLambdaTyper.ConvertForType(System.Type,System.Func{Scriptor.Expressions.TExArgCtx,Scriptor.Expressions.TEx})">
            <summary>
            Convert Func&lt;TExArgCtx, TEx&gt; to Func&lt;TExArgCtx, TEx&lt;T&gt;&gt; for a dynamically
             determined type t using reflection.
            </summary>
        </member>
        <member name="M:Scriptor.IDebugPrint.DebugPrint">
            <summary>
            Print a readable description of the entire AST.
            </summary>
        </member>
        <member name="T:Scriptor.Math.ExMAssign">
            <summary>
            This class contains functions related to assignment.
            It is not reflected as it is only for use with BDSL2, which calls them explicitly.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMAssign.Assign``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Assign x = y.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMAssign.VariableInitialize``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Assign x = y. Used only for variable initialization.
            </summary>
        </member>
        <member name="T:Scriptor.Math.ExMOperators">
            <summary>
            Functions that are operators in BDSL2.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Negate``1(Scriptor.Expressions.TEx{``0})">
            <summary>
            Returns -x.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Not(Scriptor.Expressions.TEx{System.Boolean})">
            <summary>
            Return true iff the argument is false.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Pow``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Returns (bas)^(exp).
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.PowSub(Scriptor.Expressions.TEx{System.Single},Scriptor.Expressions.TEx{System.Single})">
            <summary>
            Returns one function raised to the power of the other, subtracted by the first function. (Alias: ^- bas exp)
            Useful for getting polynomial curves that start at zero, eg. ^- t 1.1
            </summary>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.NPow(Scriptor.Expressions.TEx{System.Single},Scriptor.Expressions.TEx{System.Single})">
            <summary>
            Returns one number raised to the power of the other.
            If bas is negative, then returns - (-bas)^exp. This allows fractional powers on negatives.
            (Alias: ^^ bas exp)
            </summary>
            <param name="bas">Base</param>
            <param name="exp">Exponent</param>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Modulo``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <inheritdoc cref="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Mul``1(Scriptor.Expressions.TEx{System.Single},Scriptor.Expressions.TEx{``0})">
            <summary>
            Multiply a vectype by a number.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.MulRev``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{System.Single})">
            <inheritdoc cref="M:Scriptor.Math.ExMOperators.Mul``1(Scriptor.Expressions.TEx{System.Single},Scriptor.Expressions.TEx{``0})"/>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.MulFloat(Scriptor.Expressions.TEx{System.Single},Scriptor.Expressions.TEx{System.Single})">
            <inheritdoc cref="M:Scriptor.Math.ExMOperators.Mul``1(Scriptor.Expressions.TEx{System.Single},Scriptor.Expressions.TEx{``0})"/>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.MulInt(Scriptor.Expressions.TEx{System.Int32},Scriptor.Expressions.TEx{System.Int32})">
            <inheritdoc cref="M:Scriptor.Math.ExMOperators.Mul``1(Scriptor.Expressions.TEx{System.Single},Scriptor.Expressions.TEx{``0})"/>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Div``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{System.Single})">
            <summary>
            Divide a vectype by a number. Alias: / x y
            </summary>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Add``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Add two vectypes.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Sub``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Subtract two vectypes.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.And(Scriptor.Expressions.TEx{System.Boolean},Scriptor.Expressions.TEx{System.Boolean})">
            <summary>
            Return true iff both arguments are true.
            </summary>
            <param name="pr1">First predicate</param>
            <param name="pr2">Second predicate</param>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Or(Scriptor.Expressions.TEx{System.Boolean},Scriptor.Expressions.TEx{System.Boolean})">
            <summary>
            Return true iff one or more arguments are true.
            </summary>
            <param name="pr1">First predicate</param>
            <param name="pr2">Second predicate</param>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Eq``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Return true iff the first argument is equal to the second.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Neq``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Return true iff the first argument is not equal to the second.
            </summary>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Gt``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Return true iff the first argument is greater than the second.
            </summary>
            <param name="b1">First BPY function</param>
            <param name="b2">Second BPY function</param>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Geq``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Return true iff the first argument is greater than or equal to the second.
            </summary>
            <param name="b1">First BPY function</param>
            <param name="b2">Second BPY function</param>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Lt``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Return true iff the first argument is less than the second.
            </summary>
            <param name="b1">First BPY function</param>
            <param name="b2">Second BPY function</param>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.Leq``1(Scriptor.Expressions.TEx{``0},Scriptor.Expressions.TEx{``0})">
            <summary>
            Return true iff the first argument is less than or equal to the second.
            </summary>
            <param name="b1">First BPY function</param>
            <param name="b2">Second BPY function</param>
            <returns></returns>
        </member>
        <member name="M:Scriptor.Math.ExMOperators.ArrayIndex``1(Scriptor.Expressions.TEx{``0[]},Scriptor.Expressions.TEx{System.Int32})">
            <summary>
            Array indexing operator arr[index].
            </summary>
        </member>
        <member name="T:Scriptor.Math.SimpleParser">
            <summary>
            Helper methods for parsing simple values from strings.
            </summary>
        </member>
        <member name="M:Scriptor.Math.SimpleParser.Float(System.String)">
            <summary>
            Parse a float value. Supported shortcuts:
            <para>Up to two +- signs at the front</para>
            <para>Multiplier suffixes: p=phi, h=1/phi, f=1/120 (frame time), s=120 (fps)</para>
            <para>Effect suffixes: c = return 360h/x</para>
            </summary>
        </member>
        <member name="M:Scriptor.Math.SimpleParser.TryFloat(System.String,System.Single@)">
            <inheritdoc cref="M:Scriptor.Math.SimpleParser.Float(System.String)"/>
        </member>
        <member name="M:Scriptor.Math.SimpleParser.Float(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:Scriptor.Math.SimpleParser.Float(System.String)"/>
        </member>
        <member name="M:Scriptor.Math.SimpleParser.ParseV2RV2(System.String)">
            <summary>
            Parse a V2RV2 in the format &lt;nx;ny:rx;ry:angle&gt;.
            </summary>
        </member>
        <member name="M:Scriptor.Math.SimpleParser.TryFloat(System.String,System.Int32,System.Int32,System.Single@)">
            <inheritdoc cref="M:Scriptor.Math.SimpleParser.Float(System.String)"/>
        </member>
        <member name="T:Scriptor.ScriptorAssemblyMarker">
            <summary></summary>
        </member>
        <member name="T:Scriptor.Reflection.IDelegateArg">
            <summary>
            Description of an argument to a delegate or lexical scope.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IDelegateArg.MakeTExArg(System.Int32)">
            <summary>
            Create an <see cref="T:Scriptor.Expressions.TExArgCtx.Arg"/> representing this argument, if it is at the
             provided index in the arguments list.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IDelegateArg.MakeImplicitArgDecl">
            <summary>
            Convert this argument into an implicit declaration.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IDelegateArg.Name">
            <summary>
            Name of the argument.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IDelegateArg.Type">
            <summary>
            Type of function argument, on the level of typeof(float).
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.DelegateArg">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.DelegateArg.Name">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.DelegateArg.Type">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.DelegateArg.#ctor(System.String,System.Type,System.Boolean,System.Boolean)">
            <inheritdoc cref="T:Scriptor.Reflection.DelegateArg"/>
        </member>
        <member name="M:Scriptor.Reflection.DelegateArg.MakeTExArg(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.DelegateArg.MakeImplicitArgDecl">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Reflection.DelegateArg`1">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.DelegateArg`1.Name">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.DelegateArg`1.Type">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.DelegateArg`1.#ctor(System.String,System.Boolean,System.Boolean)">
            <inheritdoc cref="T:Scriptor.Reflection.DelegateArg`1"/>
        </member>
        <member name="M:Scriptor.Reflection.DelegateArg`1.MakeTExArg(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.DelegateArg`1.MakeImplicitArgDecl">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.SharedType">
            <summary>
            Get a representation of this method's type. This should not directly be used for unification, as
             its variable types should not be shared between all invocations.
             Call <see cref="M:BagoumLib.Unification.TypeDesignation.RecreateVariables"/> before using for unification.
            <br/>Note that lifted methods do NOT return a lifted type here. The types here are *unlifted*
             over the TExArgCtx->TEx&lt;&gt; functor.
            <br/>Note that instance methods should prepend the instance type at the beginning of the argument array.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.Flags">
            <inheritdoc cref="T:Scriptor.MethodFlags"/>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.Params">
            <summary>
            Simplified description of the method parameters. Lifted methods have lifted parameters.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.Member">
            <summary>Executable information for the method/constructor/field/property.</summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.IsFallthrough">
            <summary>
            True if this is a fallthrough method (BDSL1 only).
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.IsCtor">
            <summary>
            True if this method is a constructor.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.IsStatic">
            <summary>
            True if this is a static method.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.ReturnType">
            <summary>
            The return type of this method.
            <br/>Lifted methods return a lifted return type.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.DeclaringType">
            <summary>
            The type declaring this method.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.AsSignature">
            <summary>
            Show the signature of this method.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.AsSignatureWithRestrictions">
            <summary>
            Show the signature of this method, including type restrictions.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.TypeOnlySignature">
            <summary>
            Show the signature of this method, only including types and not names.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IMethodSignature.GetAttribute``1">
            <summary>
            Get an attribute defined on the method.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IMethodSignature.Invoke(System.Object[])">
            <summary>
            Invoke this method. If this is an instance method, the instance should be the first argument of `args`.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IMethodSignature.InvokeEx(System.Linq.Expressions.Expression[])">
            <summary>
            Invoke this method. If this is an instance method, the instance should be the first argument of `args`.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IMethodSignature.InvokeExIfNotConstant(System.Linq.Expressions.Expression[])">
            <summary>
            Return the invocation of this method as an expression node,
            but if all arguments are constant, then instead call the method and wrap it in Ex.Constant.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IMethodSignature.MakeFileLink(System.String)">
            <summary>
            If this method is defined in a file, make a link to the file.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.TypeName">
            <summary>
            (Informational) The name of the type declaring this method.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IMethodSignature.Name">
            <summary>
            (Informational) The name of this method.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Scriptor.Reflection.ScopedConversionKind">
            <summary>
            The kind of scoped conversion created by an <see cref="T:Scriptor.Reflection.IScopedTypeConverter"/>.
            </summary>
        </member>
        <member name="F:Scriptor.Reflection.ScopedConversionKind.BlockScopedExpression">
            <summary>
            A conversion method that compiles an expression and thus creates a local scope, and which
             should treat any local declarations (var) as within Ex.Block scope.
            </summary>
        </member>
        <member name="F:Scriptor.Reflection.ScopedConversionKind.EFScopedExpression">
            <summary>
            A conversion method that compiles an expression and thus creates a local scope, and which
             should use environment frames to instantiate scopes.
            <br/>Because this incurs high garbage/computational overhead in repeated invocations of compiled expressions,
             this is only used for GCXF of StateMachine, AsyncPattern, and SyncPattern, where it is necessary.
            </summary>
        </member>
        <member name="F:Scriptor.Reflection.ScopedConversionKind.Trivial">
            <summary>
            A conversion method not interfacing with expressions, such as GenCtxProperty[] to GenCtxProperties{X}.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.IScopedTypeConverter">
            <summary>
            An implicit type converter that may introduce a new scope, such as for an expression compiler.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IScopedTypeConverter.ScopeArgs">
            <summary>
            Arguments implicit to the scope. If this is null, then a new scope will not be created.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IScopedTypeConverter.Kind">
            <inheritdoc cref="T:Scriptor.Reflection.ScopedConversionKind"/>
        </member>
        <member name="P:Scriptor.Reflection.ITypeConvWithInstance.Instance.Generic">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Reflection.FixedImplicitTypeConv">
            <summary>
            Implicit type conversion for non-generic types.
            </summary>
            Note: even if the type is non-generic, usage of "implicitly generic" tex types, such as
             Func&lt;TExArgCtx, TEx&gt;, can result in the method type having variables.
        </member>
        <member name="P:Scriptor.Reflection.FixedImplicitTypeConv.MethodType">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Reflection.FixedImplicitTypeConv`2">
            <summary>
            Implicit type conversion from type T to type R.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.SingletonToArrayConv">
            <summary>
            Implicit converter that converts a singleton into an array.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.SingletonToArrayConv.#ctor">
            <summary>
            Implicit converter that converts a singleton into an array.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.MethodConv1">
            <summary>
            Implicit converter that uses a method to convert an input into an output.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.GenericMethodConv1">
            <summary>
            Implicit converter that uses a generic method to convert an input into an output.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.InvokedMethod">
            <summary>
            A description of a method called in reflection.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.InvokedMethod.#ctor(Scriptor.Reflection.IMethodSignature,System.String)">
            <summary>
            A description of a method called in reflection.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.InvokedMethod.Mi">
            <summary>
            Method details.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.InvokedMethod.Method">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.InvokedMethod.CalledAs">
            <summary>
            The name by which the user called the method (which may be an alias).
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.InvokedMethod.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Reflection.LiftedInvokedMethod">
            <summary>
            See <see cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.LiftedInvokedMethod.#ctor(Scriptor.Reflection.LiftedMethodSignature,System.String)">
            <summary>
            See <see cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.LiftedInvokedMethod.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Reflection.LiftedInvokedMethod`2">
            <summary>
            See <see cref="T:Scriptor.Reflection.LiftedMethodSignature`2"/>
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.LiftedInvokedMethod`2.#ctor(Scriptor.Reflection.LiftedMethodSignature{`0,`1},System.String)">
            <summary>
            See <see cref="T:Scriptor.Reflection.LiftedMethodSignature`2"/>
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.LiftedInvokedMethod`2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Scriptor.Reflection.MethodSignature">
            <summary>
            An annotated method signature. This may be for a static/instance function, constructor, field, or property.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.Member">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.Flags">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.Params">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.SharedType">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.GenericTypeMap">
            <summary>
            The mapping from generic types in the source member object to type designations in <see cref="P:Scriptor.Reflection.MethodSignature.SharedType"/>.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.SharedGenericTypes">
            <inheritdoc cref="P:Scriptor.Reflection.IGenericMethodSignature.SharedGenericTypes"/>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.CheckHiddenReturnType(System.Type)">
            <summary>
            Check if the return type `t` should be converted to a base type. If so, return the base type.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.HideReturnType(System.Type)">
            <summary>
            Mark that any method returning a subclass of `t` should be treated as returning `t` for type unification.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.IsFallthrough">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.TypeName">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.Name">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.IsCtor">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.IsStatic">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.TypeOnlySignature">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.AsSignature">
            <inheritdoc/>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.AsSignatureWithRestrictions">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.AsSignatureWithParamMod(System.Func{BagoumLib.Reflection.NamedParam,System.Int32,System.String})">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.GetAttribute``1">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.Invoke(System.Object[])">
            <summary>
            Invoke the method with the provided arguments.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.InvokeEx(System.Linq.Expressions.Expression[])">
            <summary>
            Return the invocation of this method as an expression node.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.MakeFileLink(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.Call(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.Get(System.Reflection.MemberInfo)">
            <summary>
            Returns a <see cref="T:Scriptor.Reflection.MethodSignature"/> or <see cref="T:Scriptor.Reflection.GenericMethodSignature"/> for this method.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.MaybeGet(System.Reflection.MemberInfo)">
            <summary>
            Returns a <see cref="T:Scriptor.Reflection.MethodSignature"/> or <see cref="T:Scriptor.Reflection.GenericMethodSignature"/> for this method.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.MethodSignature.ImplicitTypeConvKind">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.MethodSignature.Lift``1">
            <inheritdoc cref="M:Scriptor.Reflection.LiftedMethodSignature`1.Lift(Scriptor.Reflection.MethodSignature)"/>
        </member>
        <member name="T:Scriptor.Reflection.IGenericMethodSignature">
            <summary>
            <see cref="T:Scriptor.Reflection.IMethodSignature"/> for generic methods.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.IGenericMethodSignature.Specialize(System.Type[])">
            <summary>
            Make a concrete method out of a generic one using the provided type parameter.
            </summary>
        </member>
        <member name="P:Scriptor.Reflection.IGenericMethodSignature.SharedGenericTypes">
            <summary>
            Get the type designations for each of the generic types of this method.
            Note this should not be used for unification, as it is shared between all invocations.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.GenericMethodSignature">
            <inheritdoc cref="T:Scriptor.Reflection.MethodSignature"/>
        </member>
        <member name="M:Scriptor.Reflection.GenericMethodSignature.#ctor(BagoumLib.Reflection.TypeMember.Method,BagoumLib.Reflection.NamedParam[])">
            <inheritdoc cref="T:Scriptor.Reflection.MethodSignature"/>
        </member>
        <member name="P:Scriptor.Reflection.GenericMethodSignature.TypeParams">
            <summary>
            Number of generic parameters.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.GenericMethodSignature.Invoke(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.GenericMethodSignature.InvokeEx(System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.GenericMethodSignature.Specialize(System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.GenericMethodSignature.Lift``1">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.GenericMethodSignature.LiftGeneric``1">
            <inheritdoc cref="M:Scriptor.Reflection.GenericMethodSignature.Lift``1"/>
        </member>
        <member name="T:Scriptor.Reflection.LiftedMethodSignature">
            <summary>
            A description of a funcified method called in reflection.
            <br/>A funcified method has a "source" signature (A, B, C)->R, but is internally
            converted to "funcified" signature (T->A, T->B, T->C)->(T->R);
             ie. it is lifted over the reader functor. This is because
            some internal reflection functions are of type <see cref="T:Scriptor.Expressions.TExArgCtx"/>->TEx,
             but it is generally easier to write them as type TEx where possible.
            </summary>
            <param name="Original">The source method, with the signature (A, B, C)->R.</param>
            <param name="FuncedParams">The parameter list [T->A, T->B, T->C]. This is provided as <see cref="P:Scriptor.Reflection.MethodSignature.Params"/>.</param>
            <param name="BaseParams">The parameter list [A, B, C].</param>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature.#ctor(Scriptor.Reflection.MethodSignature,BagoumLib.Reflection.NamedParam[],BagoumLib.Reflection.NamedParam[])">
            <summary>
            A description of a funcified method called in reflection.
            <br/>A funcified method has a "source" signature (A, B, C)->R, but is internally
            converted to "funcified" signature (T->A, T->B, T->C)->(T->R);
             ie. it is lifted over the reader functor. This is because
            some internal reflection functions are of type <see cref="T:Scriptor.Expressions.TExArgCtx"/>->TEx,
             but it is generally easier to write them as type TEx where possible.
            </summary>
            <param name="Original">The source method, with the signature (A, B, C)->R.</param>
            <param name="FuncedParams">The parameter list [T->A, T->B, T->C]. This is provided as <see cref="P:Scriptor.Reflection.MethodSignature.Params"/>.</param>
            <param name="BaseParams">The parameter list [A, B, C].</param>
        </member>
        <member name="P:Scriptor.Reflection.LiftedMethodSignature.Original">
            <summary>The source method, with the signature (A, B, C)->R.</summary>
        </member>
        <member name="P:Scriptor.Reflection.LiftedMethodSignature.FuncedParams">
            <summary>The parameter list [T->A, T->B, T->C]. This is provided as <see cref="P:Scriptor.Reflection.MethodSignature.Params"/>.</summary>
        </member>
        <member name="P:Scriptor.Reflection.LiftedMethodSignature.BaseParams">
            <summary>The parameter list [A, B, C].</summary>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature.Call(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature.Invoke(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature.InvokeEx(System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature.LiftParams``1(Scriptor.Reflection.MethodSignature)">
            <summary>
            Lift a set of parameters over the reader functor T->.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.LiftedMethodSignature`1">
            <inheritdoc cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature`1.#ctor(Scriptor.Reflection.MethodSignature,BagoumLib.Reflection.NamedParam[],BagoumLib.Reflection.NamedParam[])">
            <inheritdoc cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature`1.Lift(Scriptor.Reflection.MethodSignature)">
            <summary>
            Lift a method over the reader functor T->.
            <br/>If R is known statically, use <see cref="T:Scriptor.Reflection.LiftedMethodSignature`2"/>'s Lift instead.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.GenericLiftedMethodSignature`1">
            <inheritdoc cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
        </member>
        <member name="M:Scriptor.Reflection.GenericLiftedMethodSignature`1.#ctor(Scriptor.Reflection.MethodSignature,BagoumLib.Reflection.TypeMember.Method,BagoumLib.Reflection.NamedParam[],BagoumLib.Reflection.NamedParam[])">
            <inheritdoc cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
        </member>
        <member name="P:Scriptor.Reflection.GenericLiftedMethodSignature`1.ReturnType">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.GenericLiftedMethodSignature`1.Invoke(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.GenericLiftedMethodSignature`1.InvokeEx(System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.GenericLiftedMethodSignature`1.Specialize(System.Type[])">
            <inheritdoc cref="M:Scriptor.Reflection.GenericMethodSignature.Specialize(System.Type[])"/>
        </member>
        <member name="T:Scriptor.Reflection.LiftedMethodSignature`2">
            <inheritdoc cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature`2.#ctor(Scriptor.Reflection.MethodSignature,BagoumLib.Reflection.NamedParam[],BagoumLib.Reflection.NamedParam[])">
            <inheritdoc cref="T:Scriptor.Reflection.LiftedMethodSignature"/>
        </member>
        <member name="P:Scriptor.Reflection.LiftedMethodSignature`2.ReturnType">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature`2.Invoke(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature`2.InvokeEx(System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature`2.Call(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Scriptor.Reflection.LiftedMethodSignature`2.Lift(Scriptor.Reflection.MethodSignature)">
            <summary>
            Lift a method over the reader functor T->.
            <br/>If R is not known statically, use <see cref="T:Scriptor.Reflection.LiftedMethodSignature`1"/>'s Lift instead.
            </summary>
        </member>
        <member name="T:Scriptor.Reflection.TypeLifter">
            <summary>
            Helper methods for lifting types and creating func types.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.TypeLifter.Func2Type(System.Type,System.Type)">
            <summary>
            Return the type Func&lt;t1, t2&gt;. Results are cached.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.TypeLifter.LiftType(System.Type,System.Type,System.Type@)">
            <summary>
            Where arg is the type of a parameter for a recorded function R member(...ARG, ...),
            construct the type of the corresponding parameter for the hypothetical function T->R member', such that
            the constructed type can be parsed by reflection code with maximum generality.
            <br/>In most cases, this is just T->ARG. See comments in the code for more details.
            <br/>If the type ARG does not need to be changed, return False (and copy ARG into RES).
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.TypeLifter.Defuncify(System.Type,System.Type,System.Object,System.Object)">
            <summary>
            De-funcify a source object whose type involves functions of one argument (eg. [TExArgCtx->tfloat]) into an
             target type (eg. [tfloat]) by applying an object of that argument type (TExArgCtx) to the
             source object according to the function registered in funcConversions.
            <br/>If no function is registered, return the source object as-is.
            </summary>
        </member>
        <member name="M:Scriptor.Reflection.TypeLifter.FuncInvoke(System.Object,System.Type,System.Object)">
            <summary>
            Return func(arg).
            </summary>
            <param name="func">Function to execute.</param>
            <param name="funcType">Type of func.</param>
            <param name="arg">Argument with which to execute func.</param>
            <returns></returns>
        </member>
    </members>
</doc>
