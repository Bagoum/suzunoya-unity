<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Mizuhashi</name>
    </assembly>
    <members>
        <member name="T:Mizuhashi.Combinators">
            <summary>
            Parser combinator functions
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Between``1(System.Char,Mizuhashi.Parser{System.Char,``0},System.Char)">
            <inheritdoc cref="M:Mizuhashi.Combinators.Between``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Between``1(System.Char,Mizuhashi.Parser{System.Char,``0})">
            <summary>
            <see cref="M:Mizuhashi.Combinators.Between``1(System.Char,Mizuhashi.Parser{System.Char,``0},System.Char)"/>(outer, middle, outer)
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Between``1(System.String,Mizuhashi.Parser{System.Char,``0},System.String)">
            <inheritdoc cref="M:Mizuhashi.Combinators.Between``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Between``1(System.String,Mizuhashi.Parser{System.Char,``0})">
            <summary>
            <see cref="M:Mizuhashi.Combinators.Between``1(System.String,Mizuhashi.Parser{System.Char,``0},System.String)"/>(outer, middle, outer)
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ThenEOF``1(Mizuhashi.Parser{System.Char,``0})">
            <summary>
            Parse the given parser, then parse EOF.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.FMap``3(Mizuhashi.Parser{``0,``1},System.Func{``1,``2})">
            <summary>
            Parses an object of type A and then map it to type B.
            <br/>Equivalent to FParsec |>>
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Select``3(Mizuhashi.Parser{``0,``1},System.Func{``1,``2})">
            <summary>
            Alias for FMap for LINQ compatibility.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Apply``3(Mizuhashi.Parser{``0,System.Func{``1,``2}},Mizuhashi.Parser{``0,``1})">
            <summary>
            Parses a function of type A->B, then an argument of type A, and returns type B.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Bind``3(Mizuhashi.Parser{``0,``1},System.Func{``1,Mizuhashi.Parser{``0,``2}})">
            <summary>
            Parses an object of type A, then parses an object of type B depending on the value of A,
             then returns the object of type B.
            <br/>Equivalent to FParsec >>=
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Bind``3(Mizuhashi.Parser{``0,``1},System.Func{``1,Mizuhashi.ParseResult{``2}})">
            <summary>
            Parses an object of type A, then returns a result of type B depending on the value of A.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Bind``4(Mizuhashi.Parser{``0,``1},System.Func{``1,Mizuhashi.Parser{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Parses an object of type A, then parses an object of type B depending on the value of A,
             then finally combines the objects according to the project function.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.SelectMany``4(Mizuhashi.Parser{``0,``1},System.Func{``1,Mizuhashi.Parser{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Alias for Bind for LINQ compatibility.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Pipe``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Func{``1,``2,``3})">
            <summary>
            Parses an object of type A, then parses an object of type B,
             then finally combines the objects using the project function.
            <br/>FParsec pipe2
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Pipe3``5(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},System.Func{``1,``2,``3,``4})">
            <summary>
            Sequentially parses objects of type A, B, C, then combines them using the project function.
            <br/>FParsec pipe3
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Pipe4``6(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},System.Func{``1,``2,``3,``4,``5})">
            <summary>
            Sequentially parses objects of type A, B, C, D, then combines them using the project function.
            <br/>FParsec pipe4
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Pipe5``7(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},Mizuhashi.Parser{``0,``5},System.Func{``1,``2,``3,``4,``5,``6})">
            <summary>
            Sequentially parses objects of type A, B, C, D, E, then combines them using the project function.
            <br/>FParsec pipe5
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Pipe6``8(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},Mizuhashi.Parser{``0,``5},Mizuhashi.Parser{``0,``6},System.Func{``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            Sequentially parses objects of type A, B, C, D, E, F, then combines them using the project function.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Pipe7``9(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},Mizuhashi.Parser{``0,``5},Mizuhashi.Parser{``0,``6},Mizuhashi.Parser{``0,``7},System.Func{``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>
            Sequentially parses objects of type A, B, C, D, E, F, G, then combines them using the project function.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Sequential``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Func{``1,``2,``3})">
            <summary>
            Allocation-efficient syntax for SelectMany when parsers do not depend on the return value of previous parsers.
            <br/>Delegates to Pipe when possible, as it is more efficient than SelectMany.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Sequential``5(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},System.Func{``1,``2,``3,``4})">
            <inheritdoc cref="M:Mizuhashi.Combinators.Sequential``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Func{``1,``2,``3})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Sequential``6(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},System.Func{``1,``2,``3,``4,``5})">
            <inheritdoc cref="M:Mizuhashi.Combinators.Sequential``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Func{``1,``2,``3})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Sequential``7(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},Mizuhashi.Parser{``0,``5},System.Func{``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:Mizuhashi.Combinators.Sequential``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Func{``1,``2,``3})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Sequential``8(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},Mizuhashi.Parser{``0,``5},Mizuhashi.Parser{``0,``6},System.Func{``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:Mizuhashi.Combinators.Sequential``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Func{``1,``2,``3})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Sequential``9(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3},Mizuhashi.Parser{``0,``4},Mizuhashi.Parser{``0,``5},Mizuhashi.Parser{``0,``6},Mizuhashi.Parser{``0,``7},System.Func{``1,``2,``3,``4,``5,``6,``7,``8})">
            <inheritdoc cref="M:Mizuhashi.Combinators.Sequential``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Func{``1,``2,``3})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Attempt``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            FParsec attempt
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ThenTryIg``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            FParsec .>>?
            <br/>Backtracks only if the second parser hits a non-fatal error.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.IgThenTry``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            FParsec >>? (which should be >>.?)
            <br/>Backtracks only if the second parser hits a non-fatal error.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ThenTry``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            FParsec .>>.?
            <br/>Backtracks only if the second parser hits a non-fatal error.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ThenTryFast``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            Backtracks only if the second parser hits a non-fatal error, but does not record the backtrack.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.IsPresent``2(Mizuhashi.Parser{``0,``1},System.String)">
            <summary>
            FParsec followedBy/followedByL. Attempts to apply the parser, but does not change state.
            <br/>Unlike FParsec, returns the parsed value.
            <br/>Also unlike FParsec, uses the error message from the parser (if `expected` is not provided).
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.IsNotPresent``2(Mizuhashi.Parser{``0,``1},System.String)">
            <summary>
            FParsec notFollowedBy/notFollowedByL. Attempts to apply the parser, but does not change state.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Show(Mizuhashi.Associativity)">
            <summary>
            Helper function to convert <see cref="T:Mizuhashi.Associativity"/> to 'left', 'right', or 'non'.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ParseOperatorsLegacy``3(System.Collections.Generic.IEnumerable{Mizuhashi.Operator{``0,``1,``2}},Mizuhashi.Parser{``0,``1})">
            <summary>
            Parse a set of operators according to precedence and associativity rules.
            This causes stack overflow issues. <see cref="M:Mizuhashi.Combinators.ParseOperators``3(System.Collections.Generic.IEnumerable{Mizuhashi.Operator{``0,``1,``2}},Mizuhashi.Parser{``0,``1})"/> is preferred.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ParseOperators``3(System.Collections.Generic.IEnumerable{Mizuhashi.Operator{``0,``1,``2}},Mizuhashi.Parser{``0,``1})">
            <summary>
            Parse a set of operators according to precedence and associativity rules.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.PReturn``2(``1)">
            <summary>
            FParsec preturn
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ThenPReturn``3(Mizuhashi.Parser{``0,``1},``2)">
            <summary>
            FParsec >>%
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Ignore``1">
            <summary>
            PReturn(Unit.Default)
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Ignore``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            Run the given parser, then ignore its output.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Fail``2(System.String)">
            <summary>
            Fails (fatally) with the given failure string.
            <br/>Note: this consumes a character and constructs a fatal error.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Fail``2(Mizuhashi.ParserError)">
            <inheritdoc cref="M:Mizuhashi.Combinators.Fail``2(System.String)"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Error``2(System.String)">
            <inheritdoc cref="M:Mizuhashi.Combinators.Error``2(Mizuhashi.ParserError)"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Error``2(Mizuhashi.ParserError)">
            <summary>
            Fails (non-fatally) with the given failure string.
            <br/>Note: this does not consume, and therefore constructs a non-fatal error.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ReturnOrError``2(BagoumLib.Functional.Either{``1,Mizuhashi.ParserError})">
            <summary>
            If the provided value is R, then <see cref="M:Mizuhashi.Combinators.PReturn``2(``1)"/> it;
            else <see cref="M:Mizuhashi.Combinators.Error``2(Mizuhashi.ParserError)"/> it.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ThenIg``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            FParsec .>>
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.IgThen``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            FParsec >>.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Then``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            FParsec .>>.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Between``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3})">
            <summary>
            FParsec between
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Between``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            Parse the outer parser, then the middle parse, then the outer parser again, and return
            the result from the middle parser.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Label``2(Mizuhashi.Parser{``0,``1},System.String)">
            <summary>
            FParsec &lt;?&gt;: Wrap any error messages in a label, but only if they do not consume text.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.LabelV``2(Mizuhashi.Parser{``0,``1},System.String)">
            <summary>
            FParsec &lt;??&gt;: Wrap any error messages in a label.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Any``1">
            <summary>
            Match any token (except end-of-file).
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Or``2(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``1})">
            <summary>
            FParsec &lt;|&gt;
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Either``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            Parse one of the two provided parsers, returning an <see cref="T:BagoumLib.Functional.Either`2"/>
             indicating which was used and its result.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.OneOf``4(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},Mizuhashi.Parser{``0,``3})">
            <summary>
            Parse one of the three provided parsers, returning an <see cref="T:BagoumLib.Functional.OneOf`3"/>
             indicating which was used and its result.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Choice``2(Mizuhashi.Parser{``0,``1}[])">
            <summary>
            Parse any of the provided parsers. If no parsers are provided, always fails.
            </summary>
        </member>
        <member name="T:Mizuhashi.Combinators.PipeChoiceEntry`3">
            <summary>
            Non-generic base class for <see cref="T:Mizuhashi.Combinators.PipeChoiceEntry`3"/>.
            </summary>
        </member>
        <member name="T:Mizuhashi.Combinators.PipeChoiceEntry`4">
            <summary>
            A data structure that allows piping the result of a common parser into intermediary parsers of multiple types,
            before finalizing with a common type result.
            </summary>
            <param name="Parser">Intermediary parser.</param>
            <param name="Mapper">Function mapping common result and intermediary result to final result.</param>
            <typeparam name="T">Token type of stream.</typeparam>
            <typeparam name="A">Type of common parser result.</typeparam>
            <typeparam name="B">Type of intermediary result.</typeparam>
            <typeparam name="C">Common type of final result.</typeparam>
        </member>
        <member name="M:Mizuhashi.Combinators.PipeChoiceEntry`4.#ctor(Mizuhashi.Parser{`0,`2},System.Func{`1,`2,`3})">
            <summary>
            A data structure that allows piping the result of a common parser into intermediary parsers of multiple types,
            before finalizing with a common type result.
            </summary>
            <param name="Parser">Intermediary parser.</param>
            <param name="Mapper">Function mapping common result and intermediary result to final result.</param>
            <typeparam name="T">Token type of stream.</typeparam>
            <typeparam name="A">Type of common parser result.</typeparam>
            <typeparam name="B">Type of intermediary result.</typeparam>
            <typeparam name="C">Common type of final result.</typeparam>
        </member>
        <member name="P:Mizuhashi.Combinators.PipeChoiceEntry`4.Parser">
            <summary>Intermediary parser.</summary>
        </member>
        <member name="P:Mizuhashi.Combinators.PipeChoiceEntry`4.Mapper">
            <summary>Function mapping common result and intermediary result to final result.</summary>
        </member>
        <member name="M:Mizuhashi.Combinators.PipeChoice``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Combinators.PipeChoiceEntry{``0,``1,``2}[])">
            <summary>
            Given a list of parsers `ps` that use different intermediate types but combine with `first` to
             produce a common final type, parse one of the list of parsers. If no parsers are provided, always fails.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.ChoiceL``2(System.String,Mizuhashi.Parser{``0,``1}[])">
            <summary>
            FParsec choiceL
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Opt``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            FParsec opt
            <br/>Try to parse an object of type R, and return it as type Maybe&lt;R&gt;.
            If it fails (non-catastrophically), then succeed with Maybe.None.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.OptN``2(Mizuhashi.Parser{``0,``1})">
            <inheritdoc cref="M:Mizuhashi.Combinators.Opt``2(Mizuhashi.Parser{``0,``1})"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Optional``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            FParsec optional
            <br/>Try to parse an object of type R.
            If it fails (non-catastrophically), then succeed.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.OptionalOr``2(Mizuhashi.Parser{``0,``1},``1)">
            <summary>
            FParsec &lt;|&gt;?
            <br/>Try to parse an object of type R.
            If it fails (non-catastrophically), then return the default.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.OptionalOrNull``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            Try to parse an object of type R, and return it as type R?.
            If it fails (non-catastrophically), then succeed with null(R?).
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.NotEmpty``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            FParsec notEmpty
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Repeat``2(Mizuhashi.Parser{``0,``1},System.Int32,System.Int32)">
            <summary>
            Applies a parser as many times as possible up to maxTimes, and returns the list of all results.
            </summary>
            <param name="p"></param>
            <param name="minTimes">Minimum number of times to apply the parser (inclusive). Will error if fewer results are found.</param>
            <param name="maxTimes">Maximum number of times to apply the parser (inclusive).</param>
        </member>
        <member name="M:Mizuhashi.Combinators.Many``2(Mizuhashi.Parser{``0,``1},System.Boolean)">
            <summary>
            Applies a parser repeatedly until it errors, and returns a list of all results.
            <br/>Note that if the parser errors fatally, this will error fatally as well.
            <br/>To avoid infinite recursion, if the parser succeeds without consumption, this will fail.
            <br/>FParsec many
            </summary>
            <param name="p">Parser to apply repeatedly</param>
            <param name="atleastOne">If true, then will require at least one result</param>
            <returns></returns>
        </member>
        <member name="M:Mizuhashi.Combinators.Many1``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            Applies a parser repeatedly until it errors, and returns a list of all results.
            <br/>Requires at least one value to be parsed.
            <br/>See <see cref="M:Mizuhashi.Combinators.Many``2(Mizuhashi.Parser{``0,``1},System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.SkipMany``2(Mizuhashi.Parser{``0,``1},System.Boolean)">
            <summary>
            Applies a parser repeatedly until it errors.
            <br/>Note that if the parser errors fatally, this will error fatally as well.
            <br/>To avoid infinite recursion, if the parser succeeds without consumption, this will fail.
            <br/>FParsec many
            </summary>
            <param name="p">Parser to apply repeatedly</param>
            <param name="atleastOne">If true, then will require at least one result</param>
            <returns></returns>
        </member>
        <member name="M:Mizuhashi.Combinators.SkipMany1``2(Mizuhashi.Parser{``0,``1})">
            <summary>
            Applies a parser repeatedly until it errors.
            <br/>Requires at least one value to be parsed.
            <br/>See <see cref="M:Mizuhashi.Combinators.SkipMany``2(Mizuhashi.Parser{``0,``1},System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.SepBy``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2},System.Boolean,Mizuhashi.Parser{``0,``1})">
            <summary>
            Parse `p (sep p)*`.
            <br/>If atleastOne is false, then allows parsing nothing.
            <br/>`sep` may be non-consuming.
            <br/>If `first` is nonnull, then it will be used to parse the first element.
            <br/>FParsec sepBy
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.SepBy1``3(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``2})">
            <summary>
            Parse `p (sep p)*`.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.SepByAll``2(Mizuhashi.Parser{``0,``1},Mizuhashi.Parser{``0,``1},System.Int32)">
            <summary>
            Parse `p (sep p)*`. Both p and sep are included in the results list.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.GetStream``1">
            <summary>
            Return the input stream that is currently being parsed.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.GetState``2">
            <summary>
            FParsec getUserState
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.SetState``2(``1)">
            <summary>
            FParsec setUserState
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.UpdateState``2(System.Func{``1,``1})">
            <summary>
            FParsec updateUserState
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.GetIndex``1">
            <summary>
            Get the current index of the stream.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.GetPosition">
            <summary>
            FParsec getPosition
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.WrapPositionI``2(Mizuhashi.Parser{``0,``0},System.Func{System.Int32,``0,System.Int32,``1})">
            <summary>
            Take the position information (<see cref="T:System.Int32"/> start and (exclusive) end) from the parse
             result and put it in a condensed type.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.WrapPosition``2(Mizuhashi.Parser{System.Char,``0},System.Func{``0,Mizuhashi.PositionRange,``1})">
            <summary>
            Take the position information (<see cref="T:Mizuhashi.Position"/> start and (exclusive) end) from the parse
             result and put it in a condensed type.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.expectedEof">
            <summary>
            Error when an end-of-file was expected but not found.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.unexpectedEof">
            <summary>
            Error when an end-of-file was found but not expect.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.atleastOneWhitespace">
            <summary>
            Error when whitespace was expected but not found.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.expectedNL">
            <summary>
            Error when a newline was expected but not found.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.partialNLR">
            <summary>
            Error when \r was found but \n did not follow it.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.EOF``1">
            <summary>
            Fails if the stream is not at end-of-file.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Char(System.Char,System.String)">
            <summary>
            Parse a specific character.
            </summary>
            <param name="c">Character</param>
            <param name="expected">Description of character (generally only necessary for characters that are
            not well displayed, such as space or tab)</param>
            <returns></returns>
        </member>
        <member name="M:Mizuhashi.Combinators.NotChar(System.Char,System.String)">
            <summary>
            Parse any character except the one provided character.
            <param name="c">Character</param>
            <param name="expected">Description of character (generally only necessary for characters that are
            not well displayed, such as space or tab)</param>
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.SoftScan">
            <summary>
            Return the next character in the stream, or null if it empty, without advancing the stream.
            <br/>This parser does not fail.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.AnyChar">
            <summary>
            Parse any character (but not EOF).
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.AnyOf(System.Collections.Generic.IReadOnlyList{System.Char})">
            <summary>
            Parse any of the provided characters.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.NoneOf(System.Collections.Generic.IReadOnlyList{System.Char})">
            <summary>
            Parse any character except the provided characters.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Satisfy``1(System.Func{``0,System.Boolean},System.String)">
            <summary>
            Parse a token that satisfies the predicate.
            </summary>
            <param name="pred">Predicate</param>
            <param name="expected">Description of what the predicate does</param>
        </member>
        <member name="M:Mizuhashi.Combinators.DontSatisfy``1(System.Func{``0,System.Boolean},System.String)">
            <summary>
            Parse a token that doesn't satisfy the predicate.
            </summary>
            <param name="pred">Predicate</param>
            <param name="unexpected">Description of what the predicate does</param>
        </member>
        <member name="M:Mizuhashi.Combinators.Satisfy(System.Func{System.Char,System.Boolean},System.String)">
            <inheritdoc cref="M:Mizuhashi.Combinators.Satisfy``1(System.Func{``0,System.Boolean},System.String)"/>
        </member>
        <member name="M:Mizuhashi.Combinators.Satisfy``1(System.Func{Mizuhashi.InputStream{``0},System.Boolean},System.String)">
            <summary>
            Parse the next character when the input stream satisfies the predicate.
            </summary>
            <param name="pred">Predicate</param>
            <param name="expected">Description of what the predicate does</param>
        </member>
        <member name="M:Mizuhashi.Combinators.ManySatisfy(System.Func{System.Char,System.Boolean},System.Boolean,System.String)">
            <summary>
            Sequentially parse as many characters as possible that satisfy the predicate,
            and returns a string composed of them.
            </summary>
            <param name="pred">Predicate</param>
            <param name="atleastOne">If true, will require at least one match</param>
            <param name="expected">Description of what the predicate does</param>
        </member>
        <member name="M:Mizuhashi.Combinators.ManySatisfyI(System.Func{Mizuhashi.InputStream{System.Char},System.Boolean},System.Boolean,System.String)">
            <summary>
            Sequentially parse as many characters as possible while the input stream satisfies the predicate,
            and returns a string composed of them.
            </summary>
            <param name="pred">Predicate</param>
            <param name="atleastOne">If true, will require at least one match</param>
            <param name="expected">Description of what the predicate does</param>
        </member>
        <member name="M:Mizuhashi.Combinators.Many1Satisfy(System.Func{System.Char,System.Boolean},System.String)">
            <summary>
            ManySatisfy with atleastOne set to true.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.SkipManySatisfy(System.Func{System.Char,System.Boolean},System.Boolean,System.String)">
            <summary>
            Sequentially parse as many characters as possible that satisfy the predicate,
             but returns nothing.
            </summary>
            <param name="pred">Predicate</param>
            <param name="atleastOne">If true, will require at least one match</param>
            <param name="expected">Description of what the predicate does</param>
        </member>
        <member name="M:Mizuhashi.Combinators.SkipMany1Satisfy(System.Func{System.Char,System.Boolean},System.String)">
            <summary>
            SkipManySatisfy with atleastOne set to true.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Whitespace">
            <summary>
            Parses zero or more whitespaces (including newlines).
            This parser cannot fail.
            <br/>FParsec spaces
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.WhitespaceIL">
            <summary>
            Parses zero or more whitespaces (not including newlines).
            This parser cannot fail.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Whitespace1">
            <summary>
            Parses one or more whitespaces (including newlines).
            <br/>FParsec spaces1
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.WhitespaceIL1">
            <summary>
            Parses one or more whitespaces (not including newlines).
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Newline">
            <summary>
            Parses \r\n or \n, and returns \n.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Tab">
            <summary>
            Parses \t.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Regex(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Parses the provided regex. Automatically prepends a `\G` to the regex so it only matches from the start.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.IsAsciiLetter(System.Char)">
            <summary>
            True iff a character is [a-zA-Z].
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.AsciiLower">
            <summary>
            Parse a-z.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.AsciiUpper">
            <summary>
            Parse A-Z.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.AsciiLetter">
            <summary>
            Parse a-zA-Z.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Lower">
            <summary>
            Parse any lowercase character.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Upper">
            <summary>
            Parse any uppercase character.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Letter">
            <summary>
            Parse any letter.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.LetterOrDigit">
            <summary>
            Parse any letter or digit.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Digit">
            <summary>
            Parse any digit.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Hex">
            <summary>
            Parse a-fA-F0-9.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.Octal">
            <summary>
            Parse 0-7.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.String(System.String)">
            <summary>
            Parses a string.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.StringIg(System.String)">
            <summary>
            Parses a string, but returns nothing.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.StringCI(System.String)">
            <summary>
            Matches a string (case-insensitive). Returns the parsed string.
            </summary>
        </member>
        <member name="F:Mizuhashi.Combinators.ParseInt">
            <summary>
            Parse a sequence of digits and converts them into an integer.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Substring(Mizuhashi.InputStream{System.Char},System.Int32)">
            <summary>
            Get a substring from a string stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.Combinators.Substring(Mizuhashi.InputStream{System.Char},System.Int32,System.Int32)">
            <summary>
            Get a substring from a string stream.
            </summary>
        </member>
        <member name="T:Mizuhashi.Associativity">
            <summary>
            The associativity of an infix operator.
            </summary>
        </member>
        <member name="F:Mizuhashi.Associativity.Left">
            <summary>
            Left-associative, ie. x~y~z = (x~y)~z
            </summary>
        </member>
        <member name="F:Mizuhashi.Associativity.Right">
            <summary>
            Right-associative, ie. x~y~z = x~(y~z)
            </summary>
        </member>
        <member name="F:Mizuhashi.Associativity.None">
            <summary>
            No associativity, ie. x~y~z throws an exception
            </summary>
        </member>
        <member name="T:Mizuhashi.AmbiguousAssociativity`3">
            <summary>
            Error shown when operator parsing fails due to ambiguous associativity.
            </summary>
        </member>
        <member name="M:Mizuhashi.AmbiguousAssociativity`3.#ctor(Mizuhashi.ParseResult{System.ValueTuple{`2,Mizuhashi.Operator{`0,`1,`2}.Infix}},Mizuhashi.ParseResult{System.ValueTuple{`2,Mizuhashi.Operator{`0,`1,`2}.Infix}})">
            <summary>
            Error shown when operator parsing fails due to ambiguous associativity.
            </summary>
        </member>
        <member name="M:Mizuhashi.AmbiguousAssociativity`3.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.Operator`3">
            <summary>
            Information about a parseable operator.
            </summary>
            <param name="Precedence">The precedence of the operator (higher precedences are parsed first).</param>
            <typeparam name="A">The type that the operator manipulates. An operator is either unary, in which case it has type A -> A, or binary, in which case it has type A -> A -> A.</typeparam>
            <typeparam name="T">Type of input stream token.</typeparam>
            <typeparam name="C">Type of result of operator parser.</typeparam>
        </member>
        <member name="M:Mizuhashi.Operator`3.#ctor(System.Int32)">
            <summary>
            Information about a parseable operator.
            </summary>
            <param name="Precedence">The precedence of the operator (higher precedences are parsed first).</param>
            <typeparam name="A">The type that the operator manipulates. An operator is either unary, in which case it has type A -> A, or binary, in which case it has type A -> A -> A.</typeparam>
            <typeparam name="T">Type of input stream token.</typeparam>
            <typeparam name="C">Type of result of operator parser.</typeparam>
        </member>
        <member name="P:Mizuhashi.Operator`3.Precedence">
            <summary>The precedence of the operator (higher precedences are parsed first).</summary>
        </member>
        <member name="T:Mizuhashi.Operator`3.Prefix">
            <summary>
            A prefix operator.
            </summary>
        </member>
        <member name="P:Mizuhashi.Operator`3.Prefix.Op">
            <summary>
            Function that joins the operator and its operand(s) into a single entity.
            </summary>
        </member>
        <member name="P:Mizuhashi.Operator`3.Prefix.Parser">
            <summary>
            Parser that parses the operator.
            </summary>
        </member>
        <member name="M:Mizuhashi.Operator`3.Prefix.#ctor(Mizuhashi.Parser{`0,`2},System.Func{`2,`1,`1},System.Int32)">
            <inheritdoc cref="T:Mizuhashi.Operator`3.Prefix"/>
        </member>
        <member name="F:Mizuhashi.Operator`3.Prefix.Null">
            <summary>
            Default parser that just returns the term itself.
            </summary>
        </member>
        <member name="T:Mizuhashi.Operator`3.Postfix">
            <summary>
            A postfix operator.
            </summary>
        </member>
        <member name="P:Mizuhashi.Operator`3.Postfix.Op">
            <inheritdoc cref="P:Mizuhashi.Operator`3.Prefix.Op"/>
        </member>
        <member name="P:Mizuhashi.Operator`3.Postfix.Parser">
            <inheritdoc cref="P:Mizuhashi.Operator`3.Prefix.Parser"/>
        </member>
        <member name="M:Mizuhashi.Operator`3.Postfix.#ctor(Mizuhashi.Parser{`0,`2},System.Func{`1,`2,`1},System.Int32)">
            <inheritdoc cref="T:Mizuhashi.Operator`3.Postfix"/>
        </member>
        <member name="F:Mizuhashi.Operator`3.Postfix.Null">
            <summary>
            Default parser that just returns the term itself.
            </summary>
        </member>
        <member name="T:Mizuhashi.Operator`3.Infix">
            <summary>
            An infix operator.
            <br/>To help make clearer error messages, this takes the operator parser
             and the resulting function as separate arguments.
            </summary>
        </member>
        <member name="P:Mizuhashi.Operator`3.Infix.Op">
            <inheritdoc cref="P:Mizuhashi.Operator`3.Prefix.Op"/>
        </member>
        <member name="P:Mizuhashi.Operator`3.Infix.Assoc">
            <inheritdoc cref="T:Mizuhashi.Associativity"/>
        </member>
        <member name="P:Mizuhashi.Operator`3.Infix.Parser">
            <inheritdoc cref="P:Mizuhashi.Operator`3.Prefix.Parser"/>
        </member>
        <member name="M:Mizuhashi.Operator`3.Infix.#ctor(Mizuhashi.Parser{`0,`2},System.Func{`1,`2,`1,`1},Mizuhashi.Associativity,System.Int32)">
            <inheritdoc cref="T:Mizuhashi.Operator`3.Infix"/>
        </member>
        <member name="T:Mizuhashi.Helpers">
            <summary>
            Helpers for calling parsers.
            </summary>
        </member>
        <member name="M:Mizuhashi.Helpers.ResultOrError``2(Mizuhashi.Parser{``0,``1},Mizuhashi.InputStream{``0})">
            <summary>
            Returns either the result of a parser, or its final failure.
            <br/>Does not include backtracking information, but that is stored in s.
            </summary>
        </member>
        <member name="M:Mizuhashi.Helpers.ResultOrError``1(Mizuhashi.Parser{System.Char,``0},System.String)">
            <summary>
            Returns either the result of a parser, or its final failure, for a basic string parser.
            <br/>Does not include backtracking information, but that is stored in s.
            </summary>
        </member>
        <member name="M:Mizuhashi.Helpers.ResultOrErrorString``2(Mizuhashi.Parser{``0,``1},Mizuhashi.InputStream{``0})">
            <summary>
            Returns either the result of a parser, or its error string.
            <br/>The error string includes backtracking information.
            </summary>
        </member>
        <member name="T:Mizuhashi.Lexers.RegexTokenizer`1">
            <summary>
            A handler for creating a token from a source string using regex parsing.
            </summary>
            <param name="RegexPattern">A regex pattern describing the token. The lexer will automatically prepend \G to this pattern to ensure that it generates contiguous tokens.</param>
            <param name="Tokenizer">A function that converts a regex match from RegexPattern into a token, with the option of failing and forcing a different match. Returns the token and the length of the match that was actually used. If length is negative, parsing will stop.</param>
            <typeparam name="T">Type of result token.</typeparam>
        </member>
        <member name="M:Mizuhashi.Lexers.RegexTokenizer`1.#ctor(System.String,System.Func{Mizuhashi.Position,System.Text.RegularExpressions.Match,BagoumLib.Functional.Maybe{System.ValueTuple{`0,System.Int32}}})">
            <summary>
            A handler for creating a token from a source string using regex parsing.
            </summary>
            <param name="RegexPattern">A regex pattern describing the token. The lexer will automatically prepend \G to this pattern to ensure that it generates contiguous tokens.</param>
            <param name="Tokenizer">A function that converts a regex match from RegexPattern into a token, with the option of failing and forcing a different match. Returns the token and the length of the match that was actually used. If length is negative, parsing will stop.</param>
            <typeparam name="T">Type of result token.</typeparam>
        </member>
        <member name="P:Mizuhashi.Lexers.RegexTokenizer`1.RegexPattern">
            <summary>A regex pattern describing the token. The lexer will automatically prepend \G to this pattern to ensure that it generates contiguous tokens.</summary>
        </member>
        <member name="P:Mizuhashi.Lexers.RegexTokenizer`1.Tokenizer">
            <summary>A function that converts a regex match from RegexPattern into a token, with the option of failing and forcing a different match. Returns the token and the length of the match that was actually used. If length is negative, parsing will stop.</summary>
        </member>
        <member name="P:Mizuhashi.Lexers.RegexTokenizer`1.Description">
            <summary>
            Description for this regex.
            </summary>
        </member>
        <member name="P:Mizuhashi.Lexers.RegexTokenizer`1.Flags">
            <summary>
            Flags for regex construction. By default, uses RegexOptions.Compiled.
            </summary>
        </member>
        <member name="T:Mizuhashi.Lexers.RegexLexer`1">
            <summary>
            A simple lexer that uses regexes to convert an input string into a list of tokens.
            <br/>This does not have support for indentation, as that requires a parser stronger than regex.
            </summary>
        </member>
        <member name="M:Mizuhashi.Lexers.RegexLexer`1.#ctor(Mizuhashi.Lexers.RegexTokenizer{`0}[])">
            <summary>
            Create a regex-based lexer.
            </summary>
            <param name="tokenizers">Token regexes, defined in decreasing order of priority.</param>
        </member>
        <member name="M:Mizuhashi.Lexers.RegexLexer`1.Tokenize(System.String)">
            <summary>
            Convert a source string into a list of contiguous tokens.
            </summary>
            <exception cref="T:System.Exception">Throws an exception when the string could not be tokenized.</exception>
        </member>
        <member name="T:Mizuhashi.ParserError">
            <summary>
            Abstract type for errors that occur while parsing.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Enumerated">
            <summary>
            Convert this error and all nested errors into a flattened list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mizuhashi.ParserError.JoinWith(Mizuhashi.ParserError)">
            <summary>
            Create an <see cref="T:Mizuhashi.ParserError.EitherOf"/> error.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <summary>
            Pretty-print the error contents.
            <br/>This does not print the position prelude, but nested errors may print their own prelude.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.ShowTopLevel(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <summary>
            Show a top-level error. This always prints the position prelude.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.ShowNested(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <summary>
            Show a nested error.
            </summary>
        </member>
        <member name="T:Mizuhashi.ParserError.Failure">
            <summary>
            Error representing generic failure.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Failure.#ctor(System.String)">
            <summary>
            Error representing generic failure.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Failure.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.ExpectedChar">
            <summary>
            Error representing a character that was expected but not found.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.ExpectedChar.#ctor(System.Char)">
            <summary>
            Error representing a character that was expected but not found.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.ExpectedChar.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.Expected">
            <summary>
            Error representing a string that was expected but not found.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Expected.#ctor(System.String)">
            <summary>
            Error representing a string that was expected but not found.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Expected.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.IncorrectNumber">
            <summary>
            Error representing that the number of parsed objects was incorrect.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.IncorrectNumber.#ctor(System.Int32,System.Int32,System.String,System.Nullable{Mizuhashi.LocatedParserError})">
            <summary>
            Error representing that the number of parsed objects was incorrect.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.IncorrectNumber.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.UnexpectedChar">
            <summary>
            Error due to a character that was not expected.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.UnexpectedChar.#ctor(System.Char)">
            <summary>
            Error due to a character that was not expected.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.UnexpectedChar.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.Unexpected">
            <summary>
            Error due a string that was not expected.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Unexpected.#ctor(System.String)">
            <summary>
            Error due a string that was not expected.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Unexpected.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.Labelled">
            <summary>
            A wrapper around an error with a label that describes what it was supposed to parse.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Labelled.#ctor(System.String,BagoumLib.Functional.Either{System.String,Mizuhashi.ParserError})">
            <summary>
            A wrapper around an error with a label that describes what it was supposed to parse.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Labelled.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.EitherOf">
            <summary>
            Two errors, either of which would resolve parsing if fixed.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.EitherOf.#ctor(Mizuhashi.ParserError,Mizuhashi.ParserError)">
            <summary>
            Two errors, either of which would resolve parsing if fixed.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.EitherOf.Enumerated">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.ParserError.EitherOf.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.ParserError.OneOf">
            <summary>
            Multiple errors, any of which would fix parsing if resolved.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.OneOf.#ctor(System.Collections.Generic.List{Mizuhashi.ParserError})">
            <summary>
            Multiple errors, any of which would fix parsing if resolved.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.OneOf.Enumerated">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.ParserError.OneOf.JoinWith(Mizuhashi.ParserError)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.ParserError.OneOf.Show(Mizuhashi.IInputStream,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.ParserError.OneOf.Equals(Mizuhashi.ParserError.OneOf)">
            <summary>
            Overrides the equality operator to do element-wise checks on <see cref="P:Mizuhashi.ParserError.OneOf.Errors"/>.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.Flatten">
            <summary>
            Flatten an error by calling <see cref="M:Mizuhashi.ParserError.Enumerated"/> and wrapping the result in <see cref="T:Mizuhashi.ParserError.OneOf"/> if necessary.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParserError.op_Implicit(System.String)~Mizuhashi.ParserError">
            <summary>
            Convert a string into an <see cref="T:Mizuhashi.ParserError.Expected"/> error.
            </summary>
        </member>
        <member name="T:Mizuhashi.LocatedParserError">
            <summary>
            A <see cref="T:Mizuhashi.ParserError"/> paired with a location in the source string.
            </summary>
        </member>
        <member name="F:Mizuhashi.LocatedParserError.Index">
            <summary>
            The index in the source stream where the error started.
            </summary>
        </member>
        <member name="F:Mizuhashi.LocatedParserError.End">
            <summary>
            The index in the source stream where the error ended.
            </summary>
        </member>
        <member name="F:Mizuhashi.LocatedParserError.Error">
            <summary>
            Error.
            </summary>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.#ctor(System.Int32,Mizuhashi.ParserError)">
            <summary>
            Create a <see cref="T:Mizuhashi.LocatedParserError"/>.
            </summary>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.WithError(Mizuhashi.ParserError)">
            <summary>
            Change the <see cref="T:Mizuhashi.ParserError"/> attached to this struct.
            </summary>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.Show(Mizuhashi.IInputStream)">
            <summary>
            Display the error in the source stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.Merge(System.Nullable{Mizuhashi.LocatedParserError},System.Nullable{Mizuhashi.LocatedParserError})">
            <summary>
            Join two errors as efficiently as possible.
            </summary>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.Equals(Mizuhashi.LocatedParserError)">
            <summary>
            Equality operator. Test that the index and error are the same.
            </summary>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.op_Equality(Mizuhashi.LocatedParserError,Mizuhashi.LocatedParserError)">
            <inheritdoc cref="M:Mizuhashi.LocatedParserError.Equals(Mizuhashi.LocatedParserError)"/>
        </member>
        <member name="M:Mizuhashi.LocatedParserError.op_Inequality(Mizuhashi.LocatedParserError,Mizuhashi.LocatedParserError)">
            <summary>
            Inequality operator.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown">
            <summary>
            A representation of a Markdown element.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block">
            <summary>
            A top-level Markdown block that includes a tailing newline or EOF.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block.Paired">
            <summary>
            Convenience structure that contains two sequential blocks. This is used by internal
             parsing handling, but will not be present in the results if you call Document or Parse.
            </summary>
        </member>
        <member name="M:Mizuhashi.Parsers.Markdown.Block.Paired.#ctor(Mizuhashi.Parsers.Markdown.Block,Mizuhashi.Parsers.Markdown.Block)">
            <summary>
            Convenience structure that contains two sequential blocks. This is used by internal
             parsing handling, but will not be present in the results if you call Document or Parse.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block.Empty">
            <summary>
            Empty block.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block.Paragraph">
            <summary>
            A paragraph is a sequence of lines separated by single newlines. It cannot be empty.
            </summary>
        </member>
        <member name="M:Mizuhashi.Parsers.Markdown.Block.Paragraph.#ctor(System.Collections.Generic.List{Mizuhashi.Parsers.Markdown.TextRun})">
            <summary>
            A paragraph is a sequence of lines separated by single newlines. It cannot be empty.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block.List">
            <summary>
            An ordered or unordered sequence of paragraphs displayed with bullets.
            </summary>
        </member>
        <member name="M:Mizuhashi.Parsers.Markdown.Block.List.#ctor(System.Boolean,System.Collections.Generic.List{System.Collections.Generic.List{Mizuhashi.Parsers.Markdown.Block}})">
            <summary>
            An ordered or unordered sequence of paragraphs displayed with bullets.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block.CodeBlock">
            <summary>
            A code-block that may have a language tag.
            </summary>
        </member>
        <member name="M:Mizuhashi.Parsers.Markdown.Block.CodeBlock.#ctor(System.String,System.String)">
            <summary>
            A code-block that may have a language tag.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block.Header">
            <summary>
            A header.
            </summary>
            <param name="Size">1-6, where 1 is the largest</param>
            <param name="Text">Header text</param>
        </member>
        <member name="M:Mizuhashi.Parsers.Markdown.Block.Header.#ctor(System.Int32,Mizuhashi.Parsers.Markdown.TextRun)">
            <summary>
            A header.
            </summary>
            <param name="Size">1-6, where 1 is the largest</param>
            <param name="Text">Header text</param>
        </member>
        <member name="P:Mizuhashi.Parsers.Markdown.Block.Header.Size">
            <summary>1-6, where 1 is the largest</summary>
        </member>
        <member name="P:Mizuhashi.Parsers.Markdown.Block.Header.Text">
            <summary>Header text</summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.Block.HRule">
            <summary>
            A horizontal rule.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.Markdown.TextRun">
            <summary>
            A sequence of Markdown text that contains at least one non-whitespace character.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parsers.MarkdownParser">
            <summary>
            A Markdown parser. The top-level function is <see cref="M:Mizuhashi.Parsers.MarkdownParser.Parse(System.String,Mizuhashi.Parsers.MarkdownParser.Settings)"/>.
            <br/>Parsing Markdown is quite an annoyance, and there are a lot of ambiguities. It is highly likely that
            there are imperfections in the handling here. Also, TODO: blockquotes, underscore-based bold/italics, and images
            are not yet supported
            </summary>
        </member>
        <member name="F:Mizuhashi.Parsers.MarkdownParser.ParseURLLink">
            <summary>
            Parses the URL link, assuming the opening ( has already been parsed.
            <br/>If it fails, it does not consume.
            </summary>
        </member>
        <member name="F:Mizuhashi.Parsers.MarkdownParser.ParseNLOrEOF">
            <summary>
            Returns true if there exists a newline, false if there exists an EOF, after any amount of inline whitespace.
            </summary>
        </member>
        <member name="M:Mizuhashi.Parsers.MarkdownParser.ParseBlock(Mizuhashi.Parsers.MarkdownParser.Settings)">
            <summary>
            The parser will NOT look for whitespace at the start corresponding to indent.
            If you need to enforce whitespace, then do Spaces(indent).IgThen(block(indent)).
            <br/>The parser WILL consume the newline that ends the block.
            </summary>
        </member>
        <member name="M:Mizuhashi.Parsers.MarkdownParser.Parse(System.String,Mizuhashi.Parsers.MarkdownParser.Settings)">
            <summary>
            Parse a Markdown document.
            </summary>
            <param name="markdownText">Markdown document as raw text</param>
            <param name="settings">Indentation settings (defaults to an indent of 2)</param>
            <returns>A list of Markdown blocks constituting the entire document. There is a possibility
            that this throws an exception, but it *should be* impossible for parsing to fail.</returns>
        </member>
        <member name="T:Mizuhashi.Position">
            <summary>
            A description of a position in a string, including line and column information.
            </summary>
        </member>
        <member name="P:Mizuhashi.Position.Index">
            <summary>
            Index in the source string (0-indexed) of the next character.
            <br/>This points out of bounds when the source has no elements left.
            </summary>
        </member>
        <member name="P:Mizuhashi.Position.Line">
            <summary>
            Current line number (1-indexed).
            </summary>
        </member>
        <member name="P:Mizuhashi.Position.IndexOfLineStart">
            <summary>
            Index in the parse string of the first character in the current line.
            <br/>Note that newlines (\n) are considered to be "at the end of the previous line".
            <br/>Note that this may point out of bounds if the source ends with a newline.
            </summary>
        </member>
        <member name="P:Mizuhashi.Position.Column">
            <summary>
            Column of the next character (1-indexed). This does not handle tab width.
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a position struct provided the index in the source text, line, and index of line start.
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.#ctor(System.String,System.Int32)">
            <summary>
            Find the position of the given index in the source string.
            <br/>Note: this is an O(n) operation in the size of `index`.
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="source">Source string</param>
            <param name="line">Line number (1-indexed)</param>
            <param name="column">Column number (1-indexed)</param>
        </member>
        <member name="M:Mizuhashi.Position.Increment">
            <summary>
            Return this position with the index increased by one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mizuhashi.Position.Step(System.String,System.Int32)">
            <summary>
            Advance `steps` characters, using `over` to determine the locations of newlines.
            <br/>Assumes that `over` is some substring Source[Index..].
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.CreateEmptyRange">
            <summary>
            new PositionRange(this, this)
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.CreateRange(System.String,System.Int32)">
            <summary>
            Creates a position range between this position and `steps` characters ahead, using
            `over` to determine the locations of newlines.
            <br/>Assumes that `over` is some substring Source[Index..].
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.Position.Print(System.Boolean)">
            <summary>
            Print the position.
            </summary>
            <param name="compact">Whether or not the position should be printed in a compact form.</param>
        </member>
        <member name="M:Mizuhashi.Position.ShowLine(System.String)">
            <summary>
            Print the entire line of this position in the source string.
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.ShowLineUpToPosition(System.String)">
            <summary>
            Print the contents of this position's line in the source string, up to but not including this position.
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.PrettyPrintLocation(System.String)">
            <summary>
            Show the contents of this position in a user-friendly way by combining ShowLine and ShowLineUpToPosition. 
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.PrettyPrintLocation(System.String,System.String)">
            <summary>
            Show the contents of this position in a user-friendly way by combining ShowLine and ShowLineUpToPosition. 
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.Equals(Mizuhashi.Position)">
            <summary>
            Equality operator.
            </summary>
        </member>
        <member name="M:Mizuhashi.Position.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.Position.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.Position.op_Equality(Mizuhashi.Position,Mizuhashi.Position)">
            <inheritdoc cref="M:Mizuhashi.Position.Equals(Mizuhashi.Position)"/>
        </member>
        <member name="M:Mizuhashi.Position.op_Inequality(Mizuhashi.Position,Mizuhashi.Position)">
            <summary>
            Inequality operator.
            </summary>
        </member>
        <member name="T:Mizuhashi.PositionRange">
            <summary>
            A description of a position range in a stream, with an inclusive start and exclusive end.
            <br/>When printed, the columns are printed inclusively.
            </summary>
        </member>
        <member name="P:Mizuhashi.PositionRange.Start">
            <summary>
            Start point of the range (inclusive).
            </summary>
        </member>
        <member name="P:Mizuhashi.PositionRange.End">
            <summary>
            End point of the range (exclusive).
            </summary>
        </member>
        <member name="P:Mizuhashi.PositionRange.Empty">
            <summary>
            True iff the range contains no elements.
            </summary>
        </member>
        <member name="M:Mizuhashi.PositionRange.#ctor(Mizuhashi.Position@,Mizuhashi.Position@)">
            <summary>
            Create a position range from two positions [start, end).
            </summary>
        </member>
        <member name="M:Mizuhashi.PositionRange.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.PositionRange.Print(System.Boolean)">
            <summary>
            Print the range.
            </summary>
            <param name="compact">True iff the range should be printed in a compact form.</param>
        </member>
        <member name="M:Mizuhashi.PositionRange.Merge(Mizuhashi.PositionRange@)">
            <summary>
            Create a new range that starts where this range starts and ends where the second range ends.
            </summary>
        </member>
        <member name="M:Mizuhashi.PositionRange.Merge(System.Collections.Generic.IEnumerable{Mizuhashi.PositionRange})">
            <summary>
            Merge several position ranges.
            </summary>
        </member>
        <member name="M:Mizuhashi.PositionRange.Contains(Mizuhashi.Position@)">
            <summary>
            True iff a position is contained within this range.
            </summary>
        </member>
        <member name="M:Mizuhashi.PositionRange.ContainsInclusiveEnd(Mizuhashi.Position@)">
            <summary>
            True iff a position is contained within this range, or is equal to the end position of the range.
            </summary>
        </member>
        <member name="M:Mizuhashi.PositionRange.Equals(Mizuhashi.PositionRange)">
            <summary>
            Equality operator.
            </summary>
        </member>
        <member name="M:Mizuhashi.PositionRange.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.PositionRange.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.PositionRange.op_Equality(Mizuhashi.PositionRange,Mizuhashi.PositionRange)">
            <inheritdoc cref="M:Mizuhashi.PositionRange.Equals(Mizuhashi.PositionRange)"/>
        </member>
        <member name="M:Mizuhashi.PositionRange.op_Inequality(Mizuhashi.PositionRange,Mizuhashi.PositionRange)">
            <summary>
            Inequality operator.
            </summary>
        </member>
        <member name="T:Mizuhashi.InputStreamState">
            <summary>
            A small struct representing the current state of an input stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStreamState.#ctor(System.Int32,Mizuhashi.Position,System.Object)">
            <summary>
            A small struct representing the current state of an input stream.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStreamState.Index">
            <summary>
            Index of the next token in the stream. (This is the index in the token array.)
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStreamState.SourcePosition">
            <summary>
            Position of the next token in the source string, which may not be directly visible to the input stream.
            <br/>Note that SourcePosition.Index is an index in the source string, NOT in the token array.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStreamState.State">
            <summary>
            User-defined state variable.
            </summary>
        </member>
        <member name="T:Mizuhashi.IInputStream">
            <summary>
            Base interface for parseable input streams, without the token type specified.
            </summary>
        </member>
        <member name="P:Mizuhashi.IInputStream.TokenWitness">
            <summary>
            Witness describing how to display the tokens over some user-facing source string.
            </summary>
        </member>
        <member name="T:Mizuhashi.InputStream`1">
            <summary>
            A lightweight description of a parseable stream.
            <br/>A single mutable instance of this is threaded through the parsing process.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.TokenWitness">
            <inheritdoc/>
        </member>
        <member name="P:Mizuhashi.InputStream`1.SourceAsString">
            <summary>
            The source stream as a string (if Token = char).
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Source">
            <summary>
            Source stream.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Description">
            <summary>
            Human-readable description of this parseable stream.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Stative">
            <summary>
            Mutable state of the input string.
            <br/>Design-wise, it is possible to extract this into ParserResult and make the stream immutable,
            but that's more expensive.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Rollbacks">
            <summary>
            A list of explicit rollbacks created by "Attempt" and "Try" parsers.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Index">
            <inheritdoc cref="P:Mizuhashi.InputStreamState.Index"/>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Remaining">
            <summary>
            Number of remaining tokens in the input stream.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Empty">
            <summary>
            True iff the input stream is empty (no tokens are remaining).
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.Next">
            <summary>
            Next token in the input stream. Throws if the stream is empty.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.MaybeNext">
            <summary>
            Next token in the input stream. Returns null if the stream is empty.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.CharAt(System.Int32)">
            <summary>
            Returns the token that is `lookahead` tokens ahead in the input stream.
            Throws if this goes beyond the stream range.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.TryCharAt(System.Int32,`0@)">
            <summary>
            Retrieve the token that is `lookahead` tokens ahead in the input stream, iff it is within the stream range.
            </summary>
        </member>
        <member name="P:Mizuhashi.InputStream`1.AsSpan">
            <summary>
            Get a span describing the unparsed section of the stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.#ctor(`0[],System.String,System.Object,Mizuhashi.ITokenWitnessCreator{`0})">
            <summary>
            Create an input stream from an array of tokens.
            <br/>A token witness must be provided, except in the default string-parsing case (Token = <see cref="T:System.Char"/>)
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.#ctor(System.String,System.String,System.Object,Mizuhashi.ITokenWitnessCreator{`0})">
            <summary>
            Create an input stream from a string (only if Token == char).
            <br/>A token witness is optional; <see cref="T:Mizuhashi.CharTokenWitnessCreator"/> will be used by default.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.UpdateState(System.Object)">
            <summary>
            Update the state object of the input stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.Rollback(Mizuhashi.InputStreamState@,System.Nullable{Mizuhashi.LocatedParserError}@)">
            <summary>
            Rollback the position of the stream, storing the error that caused the rollback.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.RollbackFast(Mizuhashi.InputStreamState@)">
            <summary>
            Rollback the position of the stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.Step(System.Int32)">
            <summary>
            Advance in the input stream by the provided number of tokens.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.MakeError(Mizuhashi.ParserError)">
            <summary>
            Pair the provided parser error with the current stream location.
            </summary>
        </member>
        <member name="M:Mizuhashi.InputStream`1.ShowAllFailures(Mizuhashi.LocatedParserError)">
            <summary>
            Returns an error string containing all rollback information and the final error.
            </summary>
        </member>
        <member name="T:Mizuhashi.ResultStatus">
            <summary>
            The status of a parse result.
            </summary>
        </member>
        <member name="F:Mizuhashi.ResultStatus.OK">
            <summary>
            Parsing was successful.
            </summary>
        </member>
        <member name="F:Mizuhashi.ResultStatus.ERROR">
            <summary>
            Parsing failed, but backtracking is enabled.
            </summary>
        </member>
        <member name="F:Mizuhashi.ResultStatus.FATAL">
            <summary>
            Parsing failed and backtracking is not enabled.
            </summary>
        </member>
        <member name="T:Mizuhashi.ParseResult`1">
            <summary>
            The result of running a parser on an input stream.
            </summary>
            <typeparam name="R">Type of parser return value.</typeparam>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.#ctor(BagoumLib.Functional.Maybe{`0},System.Nullable{Mizuhashi.LocatedParserError},System.Int32,System.Int32)">
            <summary>
            The result of running a parser on an input stream.
            </summary>
            <typeparam name="R">Type of parser return value.</typeparam>
        </member>
        <member name="P:Mizuhashi.ParseResult`1.Result">
            <summary>
            Result value. If this is present, then parsing succeeded.
            </summary>
        </member>
        <member name="P:Mizuhashi.ParseResult`1.Error">
            <summary>
            Errors produced by parsing.
            <br/>Note that errors may be present even if the parsing was successful, specifically during no-consume successes.
             Consider the example: \(A(,B)?\) which parses either (A) or (A,B). If we provide (AB) then the
             error should print "expected ',' or ')'", the first part of which is provided by the optional parser.
            <br/>Errors are always present if parsing fails.
            </summary>
        </member>
        <member name="P:Mizuhashi.ParseResult`1.ErrorOrThrow">
            <summary>
            Get <see cref="P:Mizuhashi.ParseResult`1.Error"/> or throw an exception.
            </summary>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="P:Mizuhashi.ParseResult`1.Start">
            <summary>
            Starting index (inclusive) of the parsed result.
            </summary>
        </member>
        <member name="P:Mizuhashi.ParseResult`1.End">
            <summary>
            Ending index (exclusive) of the parsed result.
            </summary>
        </member>
        <member name="P:Mizuhashi.ParseResult`1.Consumed">
            <summary>
            True iff a nonzero number of characters were consumed to produce the result.
            </summary>
        </member>
        <member name="P:Mizuhashi.ParseResult`1.Status">
            <summary>
            Result status of parsing.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.#ctor(Mizuhashi.ParserError,System.Int32,System.Nullable{System.Int32})">
            <inheritdoc cref="T:Mizuhashi.ParseResult`1"/>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.#ctor(System.Nullable{Mizuhashi.LocatedParserError},System.Int32,System.Nullable{System.Int32})">
            <inheritdoc cref="T:Mizuhashi.ParseResult`1"/>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.MergeErrors``1(Mizuhashi.ParseResult{``0}@)">
            <summary>
            Combine the errors from two sequential parse results.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.WithPreceding``1(Mizuhashi.ParseResult{``0}@)">
            <summary>
            Join the errors and consumption range of this parse result with a preceding parse result.
            <br/>Use this whenever parsers are run in sequence.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.WithPrecedingNullable``1(System.Nullable{Mizuhashi.ParseResult{``0}}@)">
            <inheritdoc cref="M:Mizuhashi.ParseResult`1.WithPreceding``1(Mizuhashi.ParseResult{``0}@)"/>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.FMap``1(System.Func{`0,``0})">
            <summary>
            Map over the value of a parse result.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.Erase">
            <summary>
            Map the type of a parse result to unit.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.WithResult``1(``0)">
            <summary>
            Change the value of a successful parse result.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.AsError``1(Mizuhashi.LocatedParserError,System.Boolean)">
            <summary>
            Convert a successful parse result into an error.
            </summary>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.AsError``1(Mizuhashi.ParserError,System.Boolean)">
            <inheritdoc cref="M:Mizuhashi.ParseResult`1.AsError``1(Mizuhashi.LocatedParserError,System.Boolean)"/>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.AsSameError(Mizuhashi.ParserError,System.Boolean)">
            <inheritdoc cref="M:Mizuhashi.ParseResult`1.AsError``1(Mizuhashi.LocatedParserError,System.Boolean)"/>
        </member>
        <member name="M:Mizuhashi.ParseResult`1.CastFailure``1">
            <summary>
            Change the type of a failed parse result.
            </summary>
        </member>
        <member name="T:Mizuhashi.Parser`2">
            <summary>
            A parser is a function that accepts a stream to parse and an initial state,
            passes it through parsing code,
            and returns a parse result (which, loosely speaking, contains either a result value or an error).
            </summary>
        </member>
        <member name="T:Mizuhashi.ITokenWitness">
            <summary>
            A degenerate class that defines how to display a stream over tokens.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.ShowErrorPosition(Mizuhashi.LocatedParserError)">
            <summary>
            Display the position prelude of an error.
            <br/>The output looks something like:
            <br/>Error at Line 1, Col 5:
            <br/>  foo bar
            <br/>  foo | &lt;- at this location
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.ShowErrorPositionInSource(Mizuhashi.PositionRange,System.String)">
            <summary>
            Return a user-readable string explaining the position of an error in the source input stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.Unexpected(System.Int32)">
            <summary>
            Create an error showing that the token at the given index was unexpected.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.Step(System.Int32)">
            <summary>
            Called by the stream when it advances. Returns the new source code position.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.ToPosition(System.Int32,System.Int32)">
            <summary>
            Convert an range in a stream to a range in some user-facing source string.
            <br/>eg. if this is operating over a tokenized stream of ["foo", "bar"], which has been lexed from a soure string "foo bar", then ToPosition(1, 2), indicating the position of "bar", should be Range(4, 7).
            <br/>If the start and end index are the same, then this should return an empty position range.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.ToPosition``1(Mizuhashi.ParseResult{``0})">
            <summary>
            Convert the range parsed by the parse-result to a range in some user-facing source string.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.ShowConsumed(System.Int32,System.Int32)">
            <summary>
            Show the content of some user-facing source string that corresponds to the range [startIndex, endIndex) in the typed stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitness.ShowConsumed``1(Mizuhashi.ParseResult{``0})">
            <summary>
            Show the content of some user-facing source string that corresponds to the range parsed by the parse-result in the typed stream.
            </summary>
        </member>
        <member name="T:Mizuhashi.ITokenWitnessCreator`1">
            <summary>
            A degenerate class that defines how to create an <see cref="T:Mizuhashi.ITokenWitness"/> from a stream.
            </summary>
        </member>
        <member name="M:Mizuhashi.ITokenWitnessCreator`1.Create(Mizuhashi.InputStream{`0})">
            <summary>
            Create a token witness linked to a stream.
            </summary>
        </member>
        <member name="T:Mizuhashi.CharTokenWitness">
            <summary>
            A degenerate class that defines how to display string (char[]) streams.
            </summary>
        </member>
        <member name="M:Mizuhashi.CharTokenWitness.#ctor(Mizuhashi.InputStream{System.Char},System.String)">
            <summary>
            A degenerate class that defines how to display string (char[]) streams.
            </summary>
        </member>
        <member name="M:Mizuhashi.CharTokenWitness.ShowErrorPosition(Mizuhashi.LocatedParserError)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.CharTokenWitness.Unexpected(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.CharTokenWitness.Step(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.CharTokenWitness.ToPosition(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Mizuhashi.CharTokenWitness.ShowConsumed(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Mizuhashi.CharTokenWitnessCreator">
            <summary>
            A degenerate class that defines how to create <see cref="T:Mizuhashi.CharTokenWitness"/>.
            </summary>
        </member>
        <member name="M:Mizuhashi.CharTokenWitnessCreator.#ctor(System.String)">
            <summary>
            A degenerate class that defines how to create <see cref="T:Mizuhashi.CharTokenWitness"/>.
            </summary>
        </member>
        <member name="M:Mizuhashi.CharTokenWitnessCreator.Create(Mizuhashi.InputStream{System.Char})">
            <inheritdoc/>
        </member>
    </members>
</doc>
