<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BagoumLib</name>
    </assembly>
    <members>
        <member name="T:BagoumLib.Assertions.IAssertion">
            <summary>
            A statement about the ideal status of an object in a <see cref="T:BagoumLib.Assertions.IdealizedState"/>,
             providing functions that create, destroy, or modify the object as necessary.
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.IAssertion.ID">
            <summary>
            String that uniquely describes this assertion.
            <br/>This is used to pair old assertions to new assertions when the idealized state changes.
            <br/>Not required if all assertions have unique types.
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.IAssertion.Priority">
            <summary>
            Ordering priority for assertions. Lower priority assertions are executed first.
            <br/>Assertions are executed by phase, so all assertions in phase 0 are executed, then in phase 1, etc.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IAssertion.ActualizeOnNewState">
            <summary>
            Called when the state is first being actualized.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IAssertion.ActualizeOnNoPreceding">
            <summary>
            Called when this assertion has been added with no preceding assertion.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IAssertion.DeactualizeOnEndState">
            <summary>
            Called when the state is being deactualized.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IAssertion.DeactualizeOnNoSucceeding">
            <summary>
            Called when this assertion has been deleted with no succeeding assertion.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IAssertion.Inherit(BagoumLib.Assertions.IAssertion)">
            <summary>
            Called when a previous assertion is replaced with this one.
            <br/>You should generally implement this as AssertionHelpers.Inherit(prev, this).
            </summary>
            <param name="prev">Previous assertion</param>
        </member>
        <member name="T:BagoumLib.Assertions.IAssertion`1">
            <summary>
            An <see cref="T:BagoumLib.Assertions.IAssertion"/> restricted to the type of the designated object.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IAssertion`1._Inherit(`0)">
            <summary>
            Called when a previous assertion is replaced with this one.
            </summary>
            <param name="prev">Previous assertion</param>
        </member>
        <member name="T:BagoumLib.Assertions.IChildLinkedAssertion">
            <summary>
            An assertion with children, which may be defined to have some special relation to the parent.
            For example, an EntityAssertion's children's transforms are children of that EntityAssertion's transform.
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.IChildLinkedAssertion.Children">
            <summary>
            Child assertions.
            </summary>
        </member>
        <member name="T:BagoumLib.Assertions.AssertionHelpers">
            <summary>
            Static class providing helpers for assertions
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.AssertionHelpers.Inherit``1(BagoumLib.Assertions.IAssertion,BagoumLib.Assertions.IAssertion{``0})">
            <summary>
            Convert the untyped assertion `prev` to type IAssertion{T}, then inherit it.
            </summary>
        </member>
        <member name="T:BagoumLib.Assertions.ActualizeOptions">
            <summary>
            Options to configure actualization/deactualization of <see cref="T:BagoumLib.Assertions.IdealizedState"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.ActualizeOptions.SimultaneousActualization">
            <summary>
            Whether or not previous state deactualization should occur at the same time as next state actualization.
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.ActualizeOptions.ActualizeFromNull">
            <summary>
            Whether or not this is the first state of any map being actualized.
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.ActualizeOptions.Default">
            <summary>
            Default options (no simultaneous actualization).
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.ActualizeOptions.Simultaneous">
            <summary>
            Default options with simultaneous actualization.
            </summary>
        </member>
        <member name="T:BagoumLib.Assertions.IdealizedState">
            <summary>
            A set of assertions representing what the state of the world ought to be.
            <br/>At any time, the state may be actualized (constructing objects represented by the state),
            inherited (modifying objects already existing according to a new state representation),
            or deactualized (destroying objects represented by the state).
            </summary>
        </member>
        <member name="P:BagoumLib.Assertions.IdealizedState.IsActualized">
            <summary>
            Whether or not the state is currently actualized.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IdealizedState.#ctor">
            <summary>
            Create an idealized state with no assertions.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IdealizedState.#ctor(BagoumLib.Assertions.IAssertion[])">
            <summary>
            Create an idealized state with some assertions.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IdealizedState.Actualize(BagoumLib.Assertions.IdealizedState,BagoumLib.Assertions.ActualizeOptions)">
            <summary>
            Deactualize the previous state, then actualize this state,
             creating the objects designated by this object's assertions.
            </summary>
            <param name="prev">A previous state. Objects will be transferred instead of created if already created
            by the previous state.</param>
            <param name="opts">Options for configuring actualization.</param>
        </member>
        <member name="M:BagoumLib.Assertions.IdealizedState.ActualizeOnNewState(BagoumLib.Assertions.ActualizeOptions)">
            <summary>
            Actualize this state when no previous state exists (ie, this is a new state).
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IdealizedState.DeactualizeOnEndState(BagoumLib.Assertions.ActualizeOptions)">
            <summary>
            Deactualize this state when no next state exists (ie, this is the last state).
            If this is not the last state, then call nextState.Actualize(thisState),
             which will deactualize thisState.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IdealizedState.Assert(BagoumLib.Assertions.IAssertion[])">
            <summary>
            Add assertions.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.IdealizedState.Assert(System.Collections.Generic.IEnumerable{BagoumLib.Assertions.IAssertion})">
            <summary>
            Add assertions.
            </summary>
        </member>
        <member name="T:BagoumLib.Assertions.RunOnEntryAssertion">
            <summary>
            An assertion that runs a task on entry (new state/no preceding only). No-op on inherit.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion.#ctor(System.Func{System.Threading.Tasks.Task})">
            <summary>
            An assertion that runs a task on entry (new state/no preceding only). No-op on inherit.
            </summary>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion.#ctor(System.Action)">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Assertions.RunOnEntryAssertion.ID">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Assertions.RunOnEntryAssertion.Priority">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion.ActualizeOnNewState">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion.ActualizeOnNoPreceding">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion.DeactualizeOnEndState">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion.DeactualizeOnNoSucceeding">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion.Inherit(BagoumLib.Assertions.IAssertion)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Assertions.RunOnEntryAssertion._Inherit(BagoumLib.Assertions.RunOnEntryAssertion)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Mathematics.AxisAngle">
            <summary>
            Representation of a rotation around an axis by an angle (in radians).
            <br/>Interoperable with <see cref="T:System.Numerics.Quaternion"/>.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.AxisAngle.Axis">
            <summary>
            Axis of rotation (unit vector).
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.AxisAngle.Angle">
            <summary>
            Radians of rotation.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.AxisAngle.#ctor(System.Numerics.Vector3,System.Single)">
            <summary>
            Create an <see cref="T:BagoumLib.Mathematics.AxisAngle"/>.
            </summary>
            <param name="axis">Axis of rotation. Must be normalized.</param>
            <param name="angle">Radians of rotation.</param>
        </member>
        <member name="M:BagoumLib.Mathematics.AxisAngle.Rotate(System.Numerics.Vector3@)">
            <summary>
            Rotate a 3D vector by this AxisAngle.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.AxisAngle.op_Multiply(System.Single,BagoumLib.Mathematics.AxisAngle@)">
            <summary>
            Multiply the angle of rotation in an AxisAngle by a multiplier.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.AxisAngle.op_Multiply(BagoumLib.Mathematics.AxisAngle@,BagoumLib.Mathematics.AxisAngle@)">
            <summary>
            Sequence two axis-angle rotations. (Uses quaternions, since the direct calculation is excessively complex.)
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.AxisAngle.op_Implicit(BagoumLib.Mathematics.AxisAngle)~System.Numerics.Quaternion">
            <summary>
            Convert an AxisAngle to a half-angle Quaternion.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.AxisAngle.op_Implicit(System.Numerics.Quaternion)~BagoumLib.Mathematics.AxisAngle">
            <summary>
            Convert a half-angle Quaternion to an AxisAngle, representing the rotation as positive. If the rotation is zero,
             then assume the axis is UnitZ.
            </summary>
        </member>
        <member name="T:BagoumLib.Mathematics.Bezier">
            <summary>
            Implementation of Bezier curves.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Bezier.CalcBezier(System.Double,System.Double,System.Double)">
            <summary>
            Cubic bezier implementation in one dimension.
            </summary>
            <param name="t">Time [0, 1]</param>
            <param name="c1">First control point</param>
            <param name="c2">Second control point</param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Mathematics.Bezier.CBezier(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a bezier easing function given two time-progression pairs.
            <br/>Works like cubic-bezier in CSS.
            </summary>
            <param name="t1">Time of first control point</param>
            <param name="p1">Progression of first control point</param>
            <param name="t2">Time of second control point</param>
            <param name="p2">Progression of second control point</param>
            <returns></returns>
        </member>
        <member name="T:BagoumLib.Mathematics.BMath">
            <summary>
            Static class providing low-level math utilities.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.IntFloatMax">
            <summary>
            int.MaxValue/2
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.HPI">
            <summary>
            Half of pi.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.PI">
            <summary>
            Pi.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.TAU">
            <summary>
            Tau (2*pi).
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.TWAU">
            <summary>
            2*tau (4*pi).
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.PHI">
            <summary>
            Phi (golden ratio, ~1.618)
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.IPHI">
            <summary>
            Inverse of phi (~.618)
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.degRad">
            <summary>
            pi/180: multiply by this to convert degrees to radians.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.BMath.radDeg">
            <summary>
            180/pi: multiply by this to convert radians to degrees.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Mod(System.Double,System.Double)">
            <summary>
            Mod function. The result will always be zero or have the same sign as `by`.
            <br/>Note that a % n = Mod(n, a)
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Mod(System.Single,System.Single)">
            <inheritdoc cref="M:BagoumLib.Mathematics.BMath.Mod(System.Double,System.Double)"/>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Mod(System.Int32,System.Int32)">
            <inheritdoc cref="M:BagoumLib.Mathematics.BMath.Mod(System.Double,System.Double)"/>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.SoftMod(System.Single,System.Single)">
            <summary>
            Triangle wave function. Has a period of 2*<paramref name="by"/>.
            </summary>
            <example>
            Softmod(4, 3) = 3
            <br/>Softmod(4, 4) = 4
            <br/>Softmod(4, 5) = 3
            <br/>Softmod(4, 8) = 0
            <br/>Softmod(4, 9) = 1
            </example>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamp a value to the range [low, high].
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Clamp(System.Single,System.Single,System.Single)">
            <inheritdoc cref="M:BagoumLib.Mathematics.BMath.Clamp(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.LerpU(System.Single,System.Single,System.Single)">
            <summary>
            Lerp between a and b, but do not clamp t, so the result can be outside the range [a, b].
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Lerp(System.Double,System.Double,System.Double)">
            <summary>
            Lerp between a and b with t as a controller (clamped to [0, 1]).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Lerp(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Lerp between `a` and `b` (clamped) based on `controller` being between `low` and `high`.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Lerp between a and b with t as a controller (clamped to [0, 1]).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Mod(System.Single,System.Numerics.Vector3)">
            <summary>
            Element-wise <see cref="M:BagoumLib.Mathematics.BMath.Mod(System.Single,System.Single)"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Smoothstep(System.Single,System.Single,System.Single)">
            <summary>
            HLSL smoothstep. Return a smoothed value of Ratio.
            WARNING: Unity's Mathf.Smoothstep returns something different.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Ratio(System.Double,System.Double,System.Double)">
            <summary>
            Returns (x - a) / (b - a); ie. t such that LerpUnclamped(a, b, t) = x.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Ratio(System.Single,System.Single,System.Single)">
            <inheritdoc cref="M:BagoumLib.Mathematics.BMath.Ratio(System.Double,System.Double,System.Double)"/>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.RatioC(System.Single,System.Single,System.Single)">
            <summary>
            Returns (x - a) / (b - a) clamped to (0, 1).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Sinc(System.Double)">
            <summary>
            =sin(pi*x)/(pi*x)
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Cis(System.Double)">
            <summary>
            =e^ix
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Cis(System.Double,System.Double,System.Double)">
            <summary>
            =amp * e^2ipi*freq*x
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.GetClosestAroundBound(System.Single,System.Single,System.Single)">
            <summary>
            Returns (target+n*mod) to minimize |src - (target+n*mod)|.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.RotateVectorDeg(System.Single,System.Single,System.Single)">
            <summary>
            Rotate a vector (x,y) CCW by the provided angle in degrees.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Rotate(System.Numerics.Vector3@,System.Numerics.Quaternion@)">
            <summary>
            Rotate a vector by a quaternion. Note that the quaternion should already have its angle halved.
            Generating a quaternion via <see cref="M:System.Numerics.Quaternion.CreateFromAxisAngle(System.Numerics.Vector3,System.Single)"/> will automatically halve the axis.
            <br/>Equal to rotator * Quaternion(vec, 0) * rotator.Conjugate()
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.SlerpNear(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Single)">
            <summary>
            Slerp between two quaternions via the closest path between them. Same as Quaternion.Slerp.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.SlerpFar(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Single)">
            <summary>
            Slerp between two quaternions via the farthest path between them.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.Slerp(System.Numerics.Quaternion@,System.Numerics.Quaternion@,System.Single)">
            <summary>
            Slerp between two quaternions.
            <br/>Note that this is not the same as Quaternion.Slerp, which always takes the shortest path.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.EqualsByDot(System.Numerics.Quaternion@,System.Numerics.Quaternion@)">
            <summary>
            Check if two quaternions are (approximately) equal using their dot product.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.ToEulersD(System.Numerics.Quaternion@)">
            <summary>
            Convert a half-angled quaternion to euler angles (in degrees).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.ToQuaternionD(System.Numerics.Vector3@)">
            <summary>
            Convert euler angles (in degrees) to a half-angled quaternion, with order ZXY.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.RotateAroundD(System.Numerics.Vector3,System.Single)">
            <summary>
            Create a half-angled quaternion to rotate a given number of degrees around an axis.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.BMath.RotateAroundZ(System.Single)">
            <summary>
            Create a half-angled quaternion to rotate a given number of degrees around the Z-axis.
            </summary>
        </member>
        <member name="T:BagoumLib.Mathematics.Easer">
            <summary>
            A continuous function over the domain [0, 1] with f(0) = 0 and f(1) = 1.
            Behavior is undefined if called with a value outside [0, 1].
            </summary>
            <param name="x">Control value in range [0, 1]</param>
        </member>
        <member name="T:BagoumLib.Mathematics.Easers">
            <summary>
            A repository of easing functions (see the <see cref="T:BagoumLib.Mathematics.Easer"/> delegate for definition).
            All easing functions are prefixed with "E".
            Some functions may also have their paired derivatives present. These are prefixed with "DE".
            Some functions may construct easing functions given a parameter, such as the power easer. These are prefixed with "CE".
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EInSine(System.Single)">
            <summary>
            Sine easer (slow at beginning).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EOutSine(System.Single)">
            <summary>
            Sine easer (slow at end).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EIOSine(System.Single)">
            <summary>
            Sine easer (slow at beginning and end).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.DEOutSine(System.Single)">
            <summary>
            Derivative of <see cref="M:BagoumLib.Mathematics.Easers.EOutSine(System.Single)"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EInQuad(System.Single)">
            <summary>
            Quadratic easer (slow at beginning).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EOutQuad(System.Single)">
            <summary>
            Quadratic easer (slow at end).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EIOQuad(System.Single)">
            <summary>
            Quadratic easer (slow at beginning and end).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EinQuart(System.Single)">
            <summary>
            Quartic easer (slow at beginning).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EOutQuart(System.Single)">
            <summary>
            Quartic easer (slow at end).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EIOQuart(System.Single)">
            <summary>
            Quartic easer (slow at beginning and end).
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.Easers.BackElasticity">
            <summary>
            Elasticity for <see cref="M:BagoumLib.Mathematics.Easers.EInBack(System.Single)"/>/<see cref="M:BagoumLib.Mathematics.Easers.EOutBack(System.Single)"/>.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.Easers.IOBackElasticity">
            <summary>
            Elasticity for <see cref="M:BagoumLib.Mathematics.Easers.EIOBack(System.Single)"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EInBack(System.Single)">
            <summary>
            Elastic easer starting by going negative and then moving quickly to the endpoint.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.CEOutBack(System.Single,System.Single)">
            <inheritdoc cref="M:BagoumLib.Mathematics.Easers.EInBack(System.Single)"/>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EOutBack(System.Single)">
            <summary>
            Elastic easer that goes beyond the endpoint and then is pulled back.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EIOBack(System.Single)">
            <summary>
            Elastic easer that starts by going negative, then quickly goes beyond the endpoint, and then is pulled back.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EInElastic(System.Single)">
            <summary>
            Elastic easer that oscillates around the starting point.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EOutElastic(System.Single)">
            <summary>
            Elastic easer that oscillates around the ending point.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EIOElastic(System.Single)">
            <summary>
            Elastic easer that oscillates around the starting and ending points.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EInBounce(System.Single)">
            <summary>
            Easer that bounces increasingly to the endpoint.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EOutBounce(System.Single)">
            <summary>
            Easer that quickly goes to the endpoint, then bounces decreasingly.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EIOBounce(System.Single)">
            <summary>
            Easer that bounces increasingly to the endpoint, then bounces decreasingly.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.ELinear(System.Single)">
            <summary>
            f(x) = x. Same as EIdentity.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.EIdentity(System.Single)">
            <summary>
            f(x) = x. Same as ELinear.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.CEOutPow(System.Single,System.Single)">
            <summary>
            1 - (1-x)^(pow)
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.Easers.CEOutBounce(System.Single[])">
            <summary>
            </summary>
            <param name="bounces">Points at which to create zeroes in the bouncing.
            0th element must be negative of 1st element.
            Final element must be 1.
            Eg: [-1/3, 1/3, 2/3, 5.3/6, 1]</param>
            <returns></returns>
        </member>
        <member name="T:BagoumLib.Mathematics.OffEasers">
            <summary>
            Functions that are similar to easers, but don't satisfy all qualifications (eg. they end at 0 instead of 1).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.OffEasers.ESine010(System.Single)">
            <summary>
            Sine wave that goes through half a period in the range [0, 1], starting and ending at 0.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.OffEasers.ESoftmod010(System.Single)">
            <summary>
            Triangle wave that has F(0) = 0, F(0.5) = 1, F(1) = 0.
            </summary>
        </member>
        <member name="T:BagoumLib.Mathematics.GenericOps">
            <summary>
            A repository for generic addition, scalar multiplication, pointwise multiplication, and lerp operators.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.GetLerp``1">
            <summary>
            Get an (unclamped) lerping function for the provided type.
            </summary>
            <typeparam name="T">A mathematical type such as float, Vector2, Color, etc.</typeparam>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.GetAddOp``1">
            <summary>
            Get an addition function for the provided type.
            </summary>
            <typeparam name="T">A mathematical type such as float, Vector2, Color, etc.</typeparam>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.GetMulOp``1">
            <summary>
            Get n scalar multiplication function for the provided type.
            </summary>
            <typeparam name="T">A mathematical type such as float, Vector2, Color, etc.</typeparam>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.GetVecMulOp``1">
            <summary>
            Get an elementwise multiplication function for the provided type.
            </summary>
            <typeparam name="T">A mathematical type such as float, Vector2, Color, etc.</typeparam>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.RegisterLerper``1(System.Func{``0,``0,System.Single,``0})">
            <summary>
            Register a lerping function for a given type. Function should be an unclamped lerp.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.RegisterAdder``1(System.ValueTuple{``0,System.Func{``0,``0,``0}})">
            <summary>
            Register an addition function for a given type.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.RegisterMultiplier``1(System.Func{``0,System.Single,``0})">
            <summary>
            Register a scalar multiplication function for a given type.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.RegisterVecMultiplier``1(System.ValueTuple{``0,System.Func{``0,``0,``0}})">
            <summary>
            Register an elementwise multiplication function for a given type.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.GenericOps.RegisterType``1(System.Func{``0,``0,System.Single,``0},System.Func{``0,System.Single,``0},System.ValueTuple{``0,System.Func{``0,``0,``0}},System.ValueTuple{``0,System.Func{``0,``0,``0}})">
            <summary>
            Register lerp, addition, scalar/elementwise multiplication operations for a given type.
            </summary>
        </member>
        <member name="T:BagoumLib.Mathematics.RandUtils">
            <summary>
            Utilities for Random.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.RandUtils.R">
            <summary>
            Static instance of Random.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.RandUtils.RandString(System.Random,System.Int32,System.String)">
            <summary>
            Create a random string. Uses the chars a-zA-Z0-9 if no set is provided.
            </summary>
        </member>
        <member name="T:BagoumLib.Mathematics.V2RV2">
            <summary>
            A position description composed of a nonrotational offset
            and a rotational offset.
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.V2RV2.nx">
            <summary>
            X-component of nonrotational offset
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.V2RV2.ny">
            <summary>
            Y-component of nonrotational offset
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.V2RV2.rx">
            <summary>
            X-component of rotational offset
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.V2RV2.ry">
            <summary>
            Y-component of rotational offset
            </summary>
        </member>
        <member name="F:BagoumLib.Mathematics.V2RV2.angle">
            <summary>
            Rotation (degrees) of rotational offset
            </summary>
        </member>
        <member name="P:BagoumLib.Mathematics.V2RV2.Zero">
            <summary>
            Create a V2RV2 with all fields set to zero.
            </summary>
        </member>
        <member name="P:BagoumLib.Mathematics.V2RV2.ComputedLocation">
            <summary>
            Get the computed position of this V2RV2, calculated as (nx, ny) + Rotate((rx, ry), angle).
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc cref="T:BagoumLib.Mathematics.V2RV2"/>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.NRot(System.Single,System.Single)">
            <summary>
            Create a V2RV2 with nonrotational coordinates and an angle of zero.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.NRotAngled(System.Single,System.Single,System.Single)">
            <summary>
            Create a V2RV2 with nonrotational coordinates.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.Rot(System.Single,System.Single,System.Single)">
            <summary>
            Create a V2RV2 with rotational coordinates.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.RX(System.Single,System.Single)">
            <summary>
            Create a V2RV2 with all fields set to zero except the rotational-X and angle.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.RY(System.Single,System.Single)">
            <summary>
            Create a V2RV2 with all fields set to zero except the rotational-Y and angle.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.Angle(System.Single)">
            <summary>
            Create a V2RV2 with all fields set to zero except the angle.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.Bank(System.Nullable{System.Single})">
            <summary>
            Convert the V2RV2 into non-rotational coordinates only, and set the angle to the
             override if provided or the current angle.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.BankOffset(System.Single)">
            <summary>
            Convert the V2RV2 into non-rotational coordinates only, and set the angle to the
             current angle plus the provided offset.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.ForceAngle(System.Single)">
            <summary>
            Create a V2RV2 with the angle set to new_ang.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.op_Addition(BagoumLib.Mathematics.V2RV2,BagoumLib.Mathematics.V2RV2)">
            <summary>
            Find the sum of each field in two V2RV2s.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.op_Subtraction(BagoumLib.Mathematics.V2RV2,BagoumLib.Mathematics.V2RV2)">
            <summary>
            Find the difference of each field in two V2RV2s.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.op_Multiply(System.Single,BagoumLib.Mathematics.V2RV2)">
            <summary>
            Multiply all elements of a V2RV2.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.op_Division(BagoumLib.Mathematics.V2RV2,System.Single)">
            <summary>
            Divide all elements of a V2RV2.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.op_Addition(BagoumLib.Mathematics.V2RV2,System.Single)">
            <summary>
            Increase the angle of a V2RV2.
            </summary>
        </member>
        <member name="M:BagoumLib.Mathematics.V2RV2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Cancellation.CancelHelpers">
            <summary>
            Helpers for <see cref="T:BagoumLib.Cancellation.ICancellee"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.CancelHelpers.IsHardCancelled(BagoumLib.Cancellation.ICancellee)">
            <summary>
            True iff the token's cancellation level is geq than <see cref="P:BagoumLib.Cancellation.ICancellee.HardCancelLevel"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.CancelHelpers.IsSoftCancelled(BagoumLib.Cancellation.ICancellee)">
            <summary>
            True iff the token is cancelled, but not hard-cancelled (<see cref="M:BagoumLib.Cancellation.CancelHelpers.IsHardCancelled(BagoumLib.Cancellation.ICancellee)"/>).
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.CancelHelpers.ToCompletion(BagoumLib.Cancellation.ICancellee)">
            <summary>
            Convert the cancellation status of a token to <see cref="T:BagoumLib.Completion"/> based on its cancel level.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.CancelHelpers.ThrowIfHardCancelled(BagoumLib.Cancellation.ICancellee)">
            <summary>
            Throw <see cref="T:System.OperationCanceledException"/> if the token is hard-cancelled (<see cref="M:BagoumLib.Cancellation.CancelHelpers.IsHardCancelled(BagoumLib.Cancellation.ICancellee)"/>).
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.CancelHelpers.ThrowIfCancelled(BagoumLib.Cancellation.ICancellee)">
            <summary>
            Throw <see cref="T:System.OperationCanceledException"/> if the token is cancelled.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.CancelHelpers.Guard(BagoumLib.Cancellation.ICancellee,System.Action)">
            <summary>
            Create an action that runs the provided action when the token is not cancelled.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.CancelHelpers.Guard``1(BagoumLib.Cancellation.ICancellee,System.Action{``0})">
            <inheritdoc cref="M:BagoumLib.Cancellation.CancelHelpers.Guard(BagoumLib.Cancellation.ICancellee,System.Action)"/>
        </member>
        <member name="T:BagoumLib.Cancellation.ICancellee">
            <summary>
            A token passed into tasks to track cancellation.
            Similar to CancellationToken, but allocates minimal garbage, does not require disposal,
            and *is not thread-safe*.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.ICancellee.HardCancelLevel">
            <summary>
            When a supported process (such as tweening) is cancelled, it will set the final value and exit without
            throwing an exception by default. However, if the cancel level is GEQ
            this value, it will not set a final value and instead throw OperationCancelledException.
            Make sure this is greater than SoftSkipLevel.
            <br/>Note that consumers are not required to distinguish skip levels.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.ICancellee.SoftSkipLevel">
            <summary>
            Cancelling with this value on a supported process will set the final value and exit without
            throwing an exception.
            Make sure this is greater than zero and less than HardCancelLevel.
            <br/>Note that cancelling with this value may result in the continuation of the process. It is a "recommendation" to skip.
            <br/>Note that consumers are not required to distinguish skip levels.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.ICancellee.CancelLevel">
            <summary>
            Used to mark the significance of cancellation client-side.
            A value LEQ 0 (default 0) indicates that the operation has not been cancelled.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.ICancellee.Cancelled">
            <summary>
            True iff the token is cancelled (<see cref="P:BagoumLib.Cancellation.ICancellee.CancelLevel"/> > 0).
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.ICancellee.Root">
            <summary>
            Get the youngest ancestor cancellee that is not a passthrough.
            </summary>
        </member>
        <member name="T:BagoumLib.Cancellation.ICancellable">
            <summary>
            A source of cancellation information.
            Similar to CancellationTokenSource, but allocates minimal garbage, does not require disposal,
            and *is not thread-safe*.
            <br/>NB: This implements IDisposable, but does not generally require disposal;
             Dispose is an alias for Cancel.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.ICancellable.Cancel(System.Int32)">
            <summary>
            Mark a cancellable as cancelled.
            </summary>
            <param name="level">Numerical level of cancellation. 0 = no cancellation.</param>
        </member>
        <member name="M:BagoumLib.Cancellation.ICancellable.Cancel">
            <summary>
            Cancel with a level of HardCancelLevel.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.ICancellable.SoftCancel">
            <summary>
            Cancel with a level of SoftSkipLevel.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.ICancellable.Token">
            <summary>
            Get a token that reflects the cancellation status of this cancellable.
            </summary>
        </member>
        <member name="T:BagoumLib.Cancellation.Cancellable">
            <inheritdoc cref="T:BagoumLib.Cancellation.ICancellable"/>
        </member>
        <member name="F:BagoumLib.Cancellation.Cancellable.Null">
            <summary>
            A cancellee that is never cancelled.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.Cancellable.CancelLevel">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.Cancellable.Cancelled">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.Cancellable.Cancel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.Cancellable.Cancel">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.Cancellable.SoftCancel">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.Cancellable.Token">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.Cancellable.Replace(BagoumLib.Cancellation.Cancellable@)">
            <summary>
            Cancel a token, and then replace it with a new one.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.Cancellable.Extend(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.ICancellee)">
            <summary>
            Return a <see cref="T:BagoumLib.Cancellation.MinCancellee"/> that is cancelled when both
             of the source cancellees are cancelled.
            </summary>
        </member>
        <member name="T:BagoumLib.Cancellation.JointCancellable">
            <summary>
            A cancellable token that is cancelled when its parent is cancelled or it is locally cancelled (via <see cref="M:BagoumLib.Cancellation.JointCancellable.Cancel(System.Int32)"/>).
            <br/>Note that `new JointCancellable(parent)` is almost the same as `new JointCancellee(parent, new Cancellable())`,
             but this is slightly more garbage-efficient.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.JointCancellable.Parent">
            <summary>
            The parent cancellation token. When it is cancelled, this token will also be cancelled.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.JointCancellable.CancelLevel">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.JointCancellable.Cancelled">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.JointCancellable.LocallyCancelled">
            <summary>
            True if Cancel was called on this token, regardless of whether or not
            the parent token is cancelled.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellable.#ctor(BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a <see cref="T:BagoumLib.Cancellation.JointCancellable"/>.
            </summary>
            <param name="parent">Parent token. If the parent token is cancelled, then this is also cancelled.</param>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellable.Cancel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellable.Cancel">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellable.SoftCancel">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.JointCancellable.Token">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Cancellation.PassthroughCancellee">
            <summary>
            Dependency situations where X constructs Y constructs Z may be organized such that
            Y has a PassthroughCancellee of (X, Y) and Z has a PassthroughCancellee of (X, Z).
            In this case, the formation of Z's JointCancellee needs to skip Y, treating X as the root
            against which to make a joint. 
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.PassthroughCancellee.CancelLevel">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.PassthroughCancellee.Cancelled">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.PassthroughCancellee.Root">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.PassthroughCancellee.#ctor(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.ICancellee)">
            <inheritdoc cref="T:BagoumLib.Cancellation.PassthroughCancellee"/>
        </member>
        <member name="T:BagoumLib.Cancellation.JointCancellee">
            <summary>
            A cancellee that is cancelled when either of its two parents are cancelled.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.JointCancellee.CancelLevel">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Cancellation.JointCancellee.Cancelled">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellee.#ctor(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.ICancellee)">
            <inheritdoc cref="T:BagoumLib.Cancellation.JointCancellee"/>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellee.#ctor(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.Cancellable@)">
            <inheritdoc cref="T:BagoumLib.Cancellation.JointCancellee"/>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellee.From(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a cancellee from two parents. If either is null, the other will be directly returned.
            If both are null, returns Cancellable.Null.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.JointCancellee.MaybeFrom(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a cancellee from two parents. If either is null, the other will be directly returned.
            </summary>
        </member>
        <member name="T:BagoumLib.Cancellation.MinCancellee">
            <summary>
            A cancel token that is cancelled when both of its parents are cancelled.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.MinCancellee.#ctor(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.ICancellee)">
            <summary>
            A cancel token that is cancelled when both of its parents are cancelled.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.MinCancellee.CancelLevel">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.MinCancellee.From(BagoumLib.Cancellation.ICancellee,BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a cancellee from two parents. If either is null, the other will be directly returned.
            </summary>
        </member>
        <member name="T:BagoumLib.Cancellation.StrongCancellee">
            <summary>
            A cancellee that proxies a source by treating soft cancellations as no-cancellation.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.StrongCancellee.#ctor(BagoumLib.Cancellation.ICancellee)">
            <summary>
            A cancellee that proxies a source by treating soft cancellations as no-cancellation.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.StrongCancellee.CancelLevel">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Cancellation.ICancellee`1">
            <summary>
            A token passed into tasks to track cancellation.
            Similar to <see cref="T:BagoumLib.Cancellation.ICancellee"/>, but when it is cancelled, it must be provided a value of type T
            (for example, a canceller for a state machine passing the next state).
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.ICancellee`1.Cancelled(`0@)">
            <summary>
            Check if the token is cancelled, and if it is, get the cancellation value.
            </summary>
        </member>
        <member name="T:BagoumLib.Cancellation.GCancellable`1">
            <inheritdoc cref="T:BagoumLib.Cancellation.ICancellee`1"/>
        </member>
        <member name="F:BagoumLib.Cancellation.GCancellable`1.Null">
            <summary>
            A cancellee that is never cancelled.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.GCancellable`1.CancelLevel">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.GCancellable`1.Cancelled(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Cancellation.GCancellable`1.Cancel(System.Int32,`0)">
            <summary>
            Cancel the token with the provided value.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.GCancellable`1.Cancel(`0)">
            <summary>
            Cancel the token with the provided value, setting the cancel level to <see cref="P:BagoumLib.Cancellation.ICancellee.HardCancelLevel"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Cancellation.ITokenized">
            <summary>
            Disposal handler for objects with a list of IDisposable tokens.
            </summary>
        </member>
        <member name="P:BagoumLib.Cancellation.ITokenized.Tokens">
            <summary>
            Set of disposable tokens to be disposed when <see cref="M:System.IDisposable.Dispose"/> is called.
            </summary>
        </member>
        <member name="M:BagoumLib.Cancellation.ITokenized.AddToken(System.IDisposable)">
            <summary>
            Add a token to <see cref="P:BagoumLib.Cancellation.ITokenized.Tokens"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Culture.LocalizationRendering">
            <summary>
            Helpers for rendering localization strings.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LocalizationRendering.FormatArgs(System.String,System.Object[])">
            <summary>
            For each argument, if it is <see cref="T:BagoumLib.Culture.IVariant"/>, then realize it with the provided locale.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LocalizationRendering.Render(System.String,System.String[],System.Object[])">
            <summary>
            String-format the strings in `pieces` using the values in `fmtArgs`, which may be locale-dependent,
             and then join them.
            </summary>
            <example>
            Render("en", new[]{"{0}", " and", " {1}"}, IVariant{"en"=>"A"}, IVariant{"en"=>"B"})
             = "A and B"
            </example>
            <param name="locale"></param>
            <param name="fmtStrings">Strings to format.</param>
            <param name="fmtArgs">Arguments to string formatting, which may be <see cref="T:BagoumLib.Culture.IVariant"/>.</param>
        </member>
        <member name="M:BagoumLib.Culture.LocalizationRendering.Render(System.String,System.String,System.Object[])">
            <inheritdoc cref="M:BagoumLib.Culture.LocalizationRendering.Render(System.String,System.String[],System.Object[])"/>
        </member>
        <member name="T:BagoumLib.Culture.LString">
            <summary>
            <see cref="T:BagoumLib.Culture.Variant`1"/> with some utility functions specific to strings.
            </summary>
        </member>
        <member name="P:BagoumLib.Culture.LString.Empty">
            <summary>
            Default empty string.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LString.#ctor(BagoumLib.Culture.ILocaleProvider,System.String,System.ValueTuple{System.String,System.String}[])">
            <inheritdoc cref="T:BagoumLib.Culture.LString"/>
        </member>
        <member name="M:BagoumLib.Culture.LString.ToString">
            <inheritdoc cref="T:BagoumLib.Culture.LString"/>
        </member>
        <member name="M:BagoumLib.Culture.LString.op_Implicit(System.String)~BagoumLib.Culture.LString">
            <summary>
            Wrap a string with no variation functionality.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Culture.LString.FormatLocale(System.String,BagoumLib.Culture.LString,BagoumLib.Culture.LString[])">
            <summary>
            Realize a format string and all of its arguments for a given locale, then combine them with string.Format.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LString.Format(BagoumLib.Culture.LString,BagoumLib.Culture.LString[])">
            <summary>
            For each locale that has value for any of the arguments, run <see cref="M:BagoumLib.Culture.LString.FormatLocale(System.String,BagoumLib.Culture.LString,BagoumLib.Culture.LString[])"/> over that locale,
             then combine all the results into a single <see cref="T:BagoumLib.Culture.LString"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LString.FormatFnLocale(System.String,System.Func{System.String[],System.String},BagoumLib.Culture.LString[])">
            <summary>
            Realize all arguments for a given locale, then combine them with the provided formatter.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LString.FormatFn(System.Func{System.String[],System.String},BagoumLib.Culture.LString[])">
            <summary>
            For each locale that has value for any of the arguments, run <see cref="M:BagoumLib.Culture.LString.FormatFnLocale(System.String,System.Func{System.String[],System.String},BagoumLib.Culture.LString[])"/> over that locale,
             then combine all the results into a single <see cref="T:BagoumLib.Culture.LString"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LString.Or(BagoumLib.Culture.LString)">
            <summary>
            For each locale that has value in `this` or `other`, create a realization selecting `this.Realize(locale)`,
             or if it is null or empty, then `second.Realize(locale)` instead.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LString.FMap(System.Func{System.String,System.String,System.String})">
            <summary>
            Run all variant values through a mapping function, and return a new <see cref="T:BagoumLib.Culture.LString"/>.
            </summary>
            <param name="mapper">Locale -> String -> New String</param>
        </member>
        <member name="T:BagoumLib.Culture.IVariant">
            <summary>
            Interface for an object whose value changes based on the current locale,
             as provided by an <see cref="T:BagoumLib.Culture.ILocaleProvider"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Culture.IVariant.ID">
            <summary>
            An identifier for the object that may be used to key it in maps. Not required if no such usages occur.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.IVariant.RealizeObj(System.String)">
            <summary>
            Get the value of the object in the given locale.
            </summary>
        </member>
        <member name="T:BagoumLib.Culture.IVariant`1">
            <summary>
            An <see cref="T:BagoumLib.Culture.IVariant`1"/> whose object type is constrained.
            </summary>
            <typeparam name="T">Type of varying object</typeparam>
        </member>
        <member name="M:BagoumLib.Culture.IVariant`1.Realize(System.String)">
            <inheritdoc cref="M:BagoumLib.Culture.IVariant.RealizeObj(System.String)"/>
        </member>
        <member name="T:BagoumLib.Culture.ILocaleProvider">
            <summary>
            Provides a language that can be interpreted by <see cref="T:BagoumLib.Culture.IVariant`1"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Culture.ILocaleProvider.LocaleEv">
            <summary>
            An event defining the current locale.
            </summary>
        </member>
        <member name="P:BagoumLib.Culture.ILocaleProvider.Locale">
            <summary>
            The current locale.
            </summary>
        </member>
        <member name="T:BagoumLib.Culture.Variant`1">
            <summary>
            Baseline implementation of <see cref="T:BagoumLib.Culture.IVariant`1"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Culture.Variant`1.ID">
            <inheritdoc />
        </member>
        <member name="F:BagoumLib.Culture.Variant`1.defaultValue">
            <summary>
            Default value to realize if the locale is null or there is no handling for the provided locale.
            </summary>
        </member>
        <member name="F:BagoumLib.Culture.Variant`1.variants">
            <summary>
            A list of locales and their mapped values.
            </summary>
        </member>
        <member name="F:BagoumLib.Culture.Variant`1.localeP">
            <summary>
            The <see cref="T:BagoumLib.Culture.ILocaleProvider"/> used to get the current locale.
            </summary>
        </member>
        <member name="P:BagoumLib.Culture.Variant`1.MyLocales">
            <summary>
            The set of locales for which alternate values are provided.
            </summary>
        </member>
        <member name="P:BagoumLib.Culture.Variant`1.Value">
            <summary>
            The current value of the locale-variant object, with the locale defined by <see cref="F:BagoumLib.Culture.Variant`1.localeP"/>
             (or defaulting to null if no locale provider is set).
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.Variant`1.#ctor(BagoumLib.Culture.ILocaleProvider,`0,System.ValueTuple{System.String,`0}[])">
            <summary>
            Create a locale-variant object.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.Variant`1.HasLang(System.String)">
            <summary>
            Whether or not there is handling for the provided locale.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.Variant`1.Realize(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Culture.Variant`1.RealizeObj(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Culture.Variant`1.op_Implicit(BagoumLib.Culture.Variant{`0})~`0">
            <summary>
            <see cref="P:BagoumLib.Culture.Variant`1.Value"/>
            </summary>
        </member>
        <member name="T:BagoumLib.Culture.LocaleProvider">
            <summary>
            Baseline implementation of <see cref="T:BagoumLib.Culture.ILocaleProvider"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Culture.LocaleProvider.#ctor(BagoumLib.Events.Evented{System.String})">
            <summary>
            Baseline implementation of <see cref="T:BagoumLib.Culture.ILocaleProvider"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.AbstractDMCompactingArray`1">
            <summary>
            Alternate implementation of <see cref="T:BagoumLib.DataStructures.DMCompactingArray`1"/> which allows any concrete implementation of
            <see cref="T:BagoumLib.DataStructures.IDeletionMarker`1"/>.
            </summary>
            <typeparam name="T">Value type of array elements</typeparam>
        </member>
        <member name="M:BagoumLib.DataStructures.AbstractDMCompactingArray`1.#ctor(System.Int32)">
            <summary>
            Create a new compacting array with the provided initial capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="P:BagoumLib.DataStructures.AbstractDMCompactingArray`1.Item(System.Int32)">
            <inheritdoc cref="P:BagoumLib.DataStructures.DMCompactingArray`1.Item(System.Int32)"/>
        </member>
        <member name="M:BagoumLib.DataStructures.AbstractDMCompactingArray`1.GetIfExistsAt(System.Int32,`0@)">
            <inheritdoc cref="M:BagoumLib.DataStructures.IReadOnlyDMCompactingArray`1.GetIfExistsAt(System.Int32,`0@)"/>
        </member>
        <member name="M:BagoumLib.DataStructures.AbstractDMCompactingArray`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.AbstractDMCompactingArray`1.CopyIntoList(System.Collections.Generic.List{`0})">
            <summary>
            Copy the non-deleted elements of this array into a list.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AbstractDMCompactingArray`1.FirstOrNull">
            <inheritdoc cref="M:BagoumLib.DataStructures.DMCompactingArray`1.FirstOrNull"/>
        </member>
        <member name="M:BagoumLib.DataStructures.AbstractDMCompactingArray`1.FirstOrNone">
            <inheritdoc cref="M:BagoumLib.DataStructures.DMCompactingArray`1.FirstOrNone"/>
        </member>
        <member name="T:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1">
            <summary>
            Generalized implementation of <see cref="T:BagoumLib.DataStructures.DMCompactingArray`1"/> parametrized by the type of deletion marker.
            <br/>There is no guarantee about the value type of array elements.
            </summary>
            <typeparam name="D">Subimplementation of <see cref="T:BagoumLib.DataStructures.IDeletionMarker"/></typeparam>
        </member>
        <member name="F:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.count">
            <inheritdoc cref="P:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Count"/>
        </member>
        <member name="P:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Count">
            <summary>
            Number of elements present in the array.
            Some of the elements may be deleted. Call <see cref="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Compact"/> to remove deleted elements and make this number
             stricter.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Data">
            <summary>
            Underlying data array.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.#ctor(System.Int32)">
            <summary>
            Create a new compacting array with the provided initial capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Compact">
            <summary>
            Remove deleted elements from the underlying data array.
            </summary>
            <returns>True iff compaction occurred, false iff the array was not modified.</returns>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.MaybeResize">
            <summary>
            Resize the array if it is full.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.NextIndexForPriority(System.Int32)">
            <summary>
            Returns the first index where the priority is greater than the given value.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.FirstPriorityGT(System.Int32)">
            <summary>
            Find the first index at which the sorting priority is greater than or equal to the given value.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.AddPriority(`0)">
            <summary>
            Add an element to the array with the priority assigned in the DeletionMarker.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.AddToEnd(`0)">
            <summary>
            Add an element to the array at the end, ignoring its priority.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.ExistsAt(System.Int32)">
            <summary>
            Returns true iff the element at the given index has not been deleted.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.GetMarkerIfExistsAt(System.Int32,`0@)">
            <summary>
            Get the index'th element's metadata if it has not been deleted.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Delete(System.Int32)">
            <summary>
            Mark the element at the provided index for deletion.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Empty">
            <summary>
            Clear the array.
            <br/>Note that this will result in markers currently in the array not receiving <see cref="M:BagoumLib.DataStructures.IDeletionMarker.RemovedFromCollection"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the array. 
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.CopyIntoList(System.Collections.Generic.List{`0})">
            <summary>
            Copy the non-deleted elements of this array into a list.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.ArrayDictionary`1">
            <summary>
            A class with a dictionary interface that is implemented without hashing by iterating over an array.
            <br/>This is sometimes faster than a dictionary when the number of keys is very small (&lt;10).
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.ArrayList`1">
            <summary>
            Implementation of List that supports Add(in T). This is probably not faster than List.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.DictCache`2">
            <summary>
            Cache for dictionaries.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DictCache`2.Consign(System.Collections.Generic.Dictionary{`0,`1})">
            <summary>
            Return an object to the cache.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DictCache`2.Get">
            <summary>
            Get a new object from the cache, or create it if the cache is empty.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.ListCache`1">
            <summary>
            Cache for lists.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.ListCache`1.Consign(System.Collections.Generic.List{`0})">
            <summary>
            Return an object to the cache.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.ListCache`1.Get">
            <summary>
            Get a new object from the cache, or create it if the cache is empty.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.CacheExtensions">
            <summary>
            Extensions for <see cref="T:BagoumLib.DataStructures.ListCache`1"/>, <see cref="T:BagoumLib.DataStructures.DictCache`2"/>, etc.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CacheExtensions.Consign``1(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:BagoumLib.DataStructures.ListCache`1.Consign(System.Collections.Generic.List{`0})"/>
        </member>
        <member name="M:BagoumLib.DataStructures.CacheExtensions.Consign``2(System.Collections.Generic.Dictionary{``0,``1})">
            <inheritdoc cref="M:BagoumLib.DataStructures.DictCache`2.Consign(System.Collections.Generic.Dictionary{`0,`1})"/>
        </member>
        <member name="M:BagoumLib.DataStructures.CacheExtensions.SetDefaultSet``3(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.Dictionary{``1,``2}},``0,``1,``2)">
            <summary>
            Set a value in a nested dictionary.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CacheExtensions.ConsignRecursive``2(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.List{``1}})">
            <summary>
            Consign all lists within this dictionary, and then the dictionary itself.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.CircularList`1">
            <summary>
            A list with a fixed capacity that wraps around and overwrites the oldest items.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.CircularList`1.Count">
            <summary>
            Number of elements in the list. Note that this is bounded by the initialized size.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.CircularList`1.TotalAdds">
            <summary>
            The total number of items that were added to the list. Since old items are overwritten,
             only the items in the range [TotalAdds-Count,TotalAdds) are accessible.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CircularList`1.#ctor(System.Int32)">
            <summary>
            Create a circular list.
            </summary>
            <param name="size">Fixed capacity of the circular list.</param>
        </member>
        <member name="M:BagoumLib.DataStructures.CircularList`1.Add(`0)">
            <summary>
            Add an element. Overwrite old elements if the container is full.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CircularList`1.SafeIndexFromBack(System.Int32)">
            <summary>
            Get the ii'th most recently added element.
            </summary>
            <param name="ii">Index from end of container. Note this should be 1 to get the last element in the container.</param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.DataStructures.CircularList`1.TrueIndex(System.Int32)">
            <summary>
            Get the ii'th added element. If the ii'th added element has not been overwritten,
             then this is equivalent to indexing into an unbounded array holding the added values at index ii.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.CircularList`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.CircularList`1.RelativeIndex(System.Int32)">
            <summary>
            Retrieve the (size-index)'th most recently added element.
            <br/>Eg. ii=0 is the oldest element still in the list; ii=Count-1 is the newest element.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CircularList`1.Clear">
            <summary>
            Clear all emenets in the container.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CircularList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.CompactingArray`1">
            <summary>
            An ordered collection that supports iteration, as well as deletion of arbitrary indices.
            Indices are not guaranteed to be persistent, so deletion must occur during the iteration block of an index.
            <br/>Note: this is significantly less flexible than <see cref="T:BagoumLib.DataStructures.DMCompactingArray`1"/>, but
            can function with zero reference overhead and zero garbage.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:BagoumLib.DataStructures.CompactingArray`1.count">
            <summary>
            Number of elements present in the array.
            Some of the elements may be deleted. Call <see cref="M:BagoumLib.DataStructures.CompactingArray`1.Compact"/> to remove deleted elements and make this number
             stricter.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.CompactingArray`1.Count">
            <inheritdoc cref="F:BagoumLib.DataStructures.CompactingArray`1.count"/>
        </member>
        <member name="P:BagoumLib.DataStructures.CompactingArray`1.Deleted">
            <summary>
            Iff the object at index i has been marked for deletion, then the i'th element in this array is true.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.CompactingArray`1.Data">
            <summary>
            Underlying data array.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.CompactingArray`1.NullElements">
            <summary>
            Number of elements that are marked for deletion.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.#ctor(System.Int32,System.Int32)">
            <inheritdoc cref="T:BagoumLib.DataStructures.CompactingArray`1"/>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.Delete(System.Int32)">
            <inheritdoc cref="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Delete(System.Int32)"/>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.Compact">
            <inheritdoc cref="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Compact"/>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.AddRef(`0@)">
            <summary>
            Add an element to the end of the array. Takes a reference for struct-type optimization.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.Add(`0)">
            <summary>
            Add an element to the end of the array.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.Empty">
            <inheritdoc cref="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Empty"/>
        </member>
        <member name="P:BagoumLib.DataStructures.CompactingArray`1.Item(System.Int32)">
            <summary>
            Get the index'th element in the array. Note that this object may be marked as deleted.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.ItemAt(System.Int32)">
            <inheritdoc cref="P:BagoumLib.DataStructures.CompactingArray`1.Item(System.Int32)"/>
        </member>
        <member name="M:BagoumLib.DataStructures.CompactingArray`1.TryGet(System.Int32,`0@)">
            <summary>
            Get the index'th element in the array only if it has not been marked as deleted.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.Continuation`2">
            <summary>
            An object of some type paired with a function that converts it to a known type.
            </summary>
            <typeparam name="B">A base type for the underlying object.</typeparam>
            <typeparam name="U">The known type that is the result of the continuation.</typeparam>
        </member>
        <member name="M:BagoumLib.DataStructures.Continuation`2.Realize">
            <summary>
            Run the continuation on the underlying object.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.Continuation`2.Obj">
            <summary>
            Get the underlying value in a base type.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Continuation`2.Typed`1.Realize">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.Continuation`2.Of``1(``0,System.Func{``0,`1})">
            <summary>
            Create a <see cref="T:BagoumLib.DataStructures.Continuation`2"/> for some data.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.CoroutineType">
            <summary>
            Details on how to handle a newly-added coroutine.
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.CoroutineType.StepTryPrepend">
            <summary>
            If a currently executing ienumerator exists, adds the coroutine before it and steps it in place (StepPrepend).
            Otherwise append to end and step it in place.
            <br/>For inter-object dependencies, this is more correct than TryStepPrepend if sending an iEnum to a previous object in the update order.
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.CoroutineType.TryStepPrepend">
            <summary>
            If a currently executing ienumerator exists, adds the coroutine before it and steps it in place (StepPrepend).
            Otherwise append to end (AppendToEnd).
            <br/>For inter-object dependencies, this is more correct than StepTryPrepend if sending an iEnum to a later object in the update order.
            This is used by default. This means that sending an update to a previous object in the update order will cause it to execute one frame slow.
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.CoroutineType.StepPrepend">
            <summary>
            Adds the coroutine before the currently executing ienumerator and steps it in place.
            If no currently executing ienumerator exists, throws an error.
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.CoroutineType.AppendToEnd">
            <summary>
            Adds the coroutine to the end of the executing list.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.CoroutineOptions">
            <summary>
            Options detailing how to handle a new coroutine.
            </summary>
            <param name="Droppable">True iff the coroutine can be deleted without waiting for cancellation when
             the coroutine container is deleted.</param>
            <param name="ExecType">Instructions on how to add the new coroutine to the existing list.</param>
        </member>
        <member name="M:BagoumLib.DataStructures.CoroutineOptions.#ctor(BagoumLib.DataStructures.CoroutineType,System.Boolean)">
            <summary>
            Options detailing how to handle a new coroutine.
            </summary>
            <param name="Droppable">True iff the coroutine can be deleted without waiting for cancellation when
             the coroutine container is deleted.</param>
            <param name="ExecType">Instructions on how to add the new coroutine to the existing list.</param>
        </member>
        <member name="P:BagoumLib.DataStructures.CoroutineOptions.ExecType">
            <summary>Instructions on how to add the new coroutine to the existing list.</summary>
        </member>
        <member name="P:BagoumLib.DataStructures.CoroutineOptions.Droppable">
            <summary>True iff the coroutine can be deleted without waiting for cancellation when
             the coroutine container is deleted.</summary>
        </member>
        <member name="F:BagoumLib.DataStructures.CoroutineOptions.Default">
            <summary>
            Default coroutine options (non-droppable and <see cref="F:BagoumLib.DataStructures.CoroutineType.StepTryPrepend"/>)
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.CoroutineOptions.DroppableDefault">
            <summary>
            Default coroutine options (droppable and <see cref="F:BagoumLib.DataStructures.CoroutineType.StepTryPrepend"/>)
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CoroutineOptions.DefaultWith(System.Boolean)">
            <summary>
            Return <see cref="F:BagoumLib.DataStructures.CoroutineOptions.DroppableDefault"/> if `droppable` is true, else <see cref="F:BagoumLib.DataStructures.CoroutineOptions.Default"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.CoroutineOptions.ProcessThisFrame(System.Boolean)">
            <summary>
            Return a CoroutineOptions with StepTryPrepend if the entity has updated this frame, or TryStepPrepend
             if it has not yet updated. This ensures that the coroutine receives one update this frame.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.ICoroutineRunner">
            <summary>
            An object on which coroutines can be run.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.ICoroutineRunner.Run(System.Collections.IEnumerator,BagoumLib.DataStructures.CoroutineOptions)">
            <summary>
            Run the provided coroutine.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.Coroutines">
            <summary>
            A class that permits manually stepping through IEnumerator-based coroutines.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Coroutines.AsIEnum">
            <summary>
            Convert this object to an IEnumerator.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Coroutines.Step">
            <summary>
            Step once through all coroutines.
            </summary>
            <returns>True iff the coroutine set changed.</returns>
        </member>
        <member name="P:BagoumLib.DataStructures.Coroutines.Count">
            <summary>
            Number of coroutines currently executing.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Coroutines.Close">
            <summary>
            Step through all coroutines once, and stops executing any droppable coroutines.
            <br/>Before calling this, non-droppable coroutines should be cancelled via cancellation tokens.
            <br/>After calling this, the caller may want to enforce that no (non-droppable) coroutines remain.
            <br/>Use <see cref="M:BagoumLib.DataStructures.Coroutines.CloseRepeated"/> instead of coroutines have dependences on other coroutines.
            </summary>
            <returns>True iff the coroutine set changed.</returns>
        </member>
        <member name="M:BagoumLib.DataStructures.Coroutines.CloseRepeated">
            <summary>
            Step through all coroutines once, dropping any droppable coroutines,
             then repeat the process while this results in changes to the coroutine set.
            <br/>Use this over <see cref="M:BagoumLib.DataStructures.Coroutines.CloseRepeated"/> when coroutines may be dependent on the results of other coroutines.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Coroutines.Run(System.Collections.IEnumerator,BagoumLib.DataStructures.CoroutineOptions)">
            <summary>
            Run a couroutine that will be updated once every engine frame.
            This coroutine is expected to clean up within one step on cancellation, 
             for correct behavior with <see cref="M:BagoumLib.DataStructures.Coroutines.Close"/>.
            Alternatively, the coroutine may be marked as droppable under <see cref="P:BagoumLib.DataStructures.CoroutineOptions.Droppable"/>.
            </summary>
            <param name="ienum">Coroutine</param>
            <param name="opts">Settings</param>
        </member>
        <member name="T:BagoumLib.DataStructures.DictionaryWithKeys`2">
            <summary>
            A dictionary where the set of keys is stored separately, allowing zero-garbage iteration.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.DictionaryWithKeys`2.Data">
            <summary>
            Dictionary data.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.DictionaryWithKeys`2.Keys">
            <summary>
            Array of dictionary keys.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.DictionaryWithKeys`2.Item(`0)">
            <summary>
            Get/set accessors for the underlying data.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DictionaryWithKeys`2.Clear">
            <summary>
            Clear all data in this dictionary.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.IDeletionMarker">
            <summary>
            A disposable marker. When disposed, some underlying object will be removed from a collection.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.IDeletionMarker.Priority">
            <summary>
            Sorting priority in the array.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.IDeletionMarker.MarkedForDeletion">
            <summary>
            Whether or not the element is currently marked as deleted.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.IDeletionMarker.MarkForDeletion">
            <summary>
            Mark the element as deleted. The caller should stop using the marker after this.
            <br/>It is unsafe to reuse (eg. via caching) deletion markers at this point, as the collection
             may not have deleted them. Wait until <see cref="M:BagoumLib.DataStructures.IDeletionMarker.RemovedFromCollection"/> is called to cache deletion markers.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.IDeletionMarker.RemovedFromCollection">
            <summary>
            Called when the collection removes the marker and the underlying element.
            <br/>It is *not guaranteed* that this function will be called, so you should not depend on it.
            <br/>It is permissible to reuse (eg. via caching) deletion markers when this is called,
             as long as you are not using the marker somewhere else.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.IDeletionMarker`1">
            <summary>
            An <see cref="T:BagoumLib.DataStructures.IDeletionMarker"/> for an underlying value of type T.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.IDeletionMarker`1.Value">
            <summary>
            Value of the object in the collection.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.DeletionMarker`1">
            <summary>
            A disposable marker for a value <see cref="F:BagoumLib.DataStructures.DeletionMarker`1.Value"/> within a collection (see <see cref="T:BagoumLib.DataStructures.DMCompactingArray`1"/>).
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.DeletionMarker`1.Priority">
            <inheritdoc/>
        </member>
        <member name="F:BagoumLib.DataStructures.DeletionMarker`1.Value">
            <summary>
            Value of the object in the array.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DeletionMarker`1.#ctor(`0,System.Int32)">
            <summary>
            Create a new deletion marker with the given value and priority.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DeletionMarker`1.Make(`0,System.Int32)">
            <summary>
            Create a new deletion marker with the given value and priority.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DeletionMarker`1.MarkForDeletion">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.DeletionMarker`1.RemovedFromCollection">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.DeletionMarker`1.AllowPooling">
            <summary>
            Mark that a DeletionMarker is safe to be pooled when it receives <see cref="M:BagoumLib.DataStructures.DeletionMarker`1.RemovedFromCollection"/>.
            <br/>Call this on construction if you are not using the DeletionMarker anywhere else.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DeletionMarker`1.DisallowPooling">
            <summary>
            Mark that a DeletionMarker is unsafe to be pooled.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DeletionMarker`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.DMCompactingArray`1">
            <summary>
            An ordered collection that supports iteration, as well as deletion of arbitrary elements via
            disposable tokens (<see cref="T:BagoumLib.DataStructures.DeletionMarker`1"/>) returned to consumers.
            Indices are not guaranteed to be persistent and should not be used for identification.
            <br/>Deletion is O(1) amortized, assuming that <see cref="M:BagoumLib.DataStructures.AnyTypeDMCompactingArray`1.Compact"/> is called at a reasonable frequency.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.DMCompactingArray`1.EmptyArray">
            <summary>
            A statically-shared empty array.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.#ctor(System.Int32)">
            <summary>
            Create a new compacting array with the provided initial capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.Add(`0)">
            <summary>
            Add an element to the array with a default ordering priority of zero.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.AddPriority(`0,System.Int32)">
            <summary>
            Add an element into the array with a priority.
            Lower priorities will be inserted at the front of the array.
            </summary>
            <param name="obj"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="P:BagoumLib.DataStructures.DMCompactingArray`1.Item(System.Int32)">
            <summary>
            Get the index'th element in the array. Note that this does not check if the element has been deleted.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.GetIfExistsAt(System.Int32,`0@)">
            <inheritdoc cref="M:BagoumLib.DataStructures.IReadOnlyDMCompactingArray`1.GetIfExistsAt(System.Int32,`0@)"/>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.CopyIntoList(System.Collections.Generic.List{`0})">
            <summary>
            Copy the non-deleted elements of this array into a list.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.FirstOrNull">
            <summary>
            Get the first element in the array, or null if it is empty.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.DMCompactingArray`1.FirstOrNone">
            <summary>
            Get the first element in the array, or None if it is empty.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.FColor">
            <summary>
            Representation of RGBA colors with 0-1 float values for each field.
            <br/>(Fields may exceed the 0-1 range.)
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.FColor.r">
            <summary>
            Red component.
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.FColor.g">
            <summary>
            Green component.
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.FColor.b">
            <summary>
            Blue component.
            </summary>
        </member>
        <member name="F:BagoumLib.DataStructures.FColor.a">
            <summary>
            Alpha component.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a new <see cref="T:BagoumLib.DataStructures.FColor"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.WithA(System.Single)">
            <summary>
            Copy this color with a different alpha component.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.Lerp(BagoumLib.DataStructures.FColor,BagoumLib.DataStructures.FColor,System.Single)">
            <summary>
            Lerp (clamped) between colors.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.LerpU(BagoumLib.DataStructures.FColor,BagoumLib.DataStructures.FColor,System.Single)">
            <summary>
            Lerp (unclamped) between colors.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.ToString">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Addition(BagoumLib.DataStructures.FColor,BagoumLib.DataStructures.FColor)">
            <summary>
            Add colors (unclamped).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Subtraction(BagoumLib.DataStructures.FColor,BagoumLib.DataStructures.FColor)">
            <summary>
            Subtract colors (unclamped).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Multiply(BagoumLib.DataStructures.FColor,BagoumLib.DataStructures.FColor)">
            <summary>
            Multiply colors component-wise.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Multiply(BagoumLib.DataStructures.FColor,System.Single)">
            <summary>
            Multiply all components of a color by a scalar (unclamped).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Multiply(System.Single,BagoumLib.DataStructures.FColor)">
            <summary>
            Multiply all components of a color by a scalar (unclamped).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Division(BagoumLib.DataStructures.FColor,System.Single)">
            <summary>
            Divide all components of a color by a scalar (unclamped).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Equality(BagoumLib.DataStructures.FColor,BagoumLib.DataStructures.FColor)">
            <summary>
            Check if two colors are equal.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Inequality(BagoumLib.DataStructures.FColor,BagoumLib.DataStructures.FColor)">
            <summary>
            Check if two colors are not equal.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Implicit(BagoumLib.DataStructures.FColor)~System.Numerics.Vector4">
            <summary>
            Convert a color to a 0-1 vector4.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Implicit(System.Numerics.Vector4)~BagoumLib.DataStructures.FColor">
            <summary>
            Convert a 0-1 vector4 to a color.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.op_Implicit(System.Drawing.Color)~BagoumLib.DataStructures.FColor">
            <summary>
            Convert a 0-255 color to a 0-1 color.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.FColor.White">
            <summary>
            White (1, 1, 1, 1).
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.FColor.Clear">
            <summary>
            Transparent (0, 0, 0, 0).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FColor.Equals(BagoumLib.DataStructures.FColor)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.FreezableArray`1">
            <summary>
            An array of data that cannot be modified and has element-based equality/hashing.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.FreezableArray`1.Data">
            <summary>
            The underlying data.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FreezableArray`1.#ctor(`0[])">
            <inheritdoc cref="T:BagoumLib.DataStructures.FreezableArray`1"/>
        </member>
        <member name="P:BagoumLib.DataStructures.FreezableArray`1.Empty">
            <summary>
            An empty array.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.FreezableArray`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.FreezableArray`1.Equals(BagoumLib.DataStructures.FreezableArray{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.FreezableArray`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.FreezableArray`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.IReadOnlyDMCompactingArray`1">
            <summary>
            Interface for reading from a <see cref="T:BagoumLib.DataStructures.DMCompactingArray`1"/> or <see cref="T:BagoumLib.DataStructures.AbstractDMCompactingArray`1"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.IReadOnlyDMCompactingArray`1.Count">
            <summary>
            Number of elements present in the array.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.IReadOnlyDMCompactingArray`1.GetIfExistsAt(System.Int32,`0@)">
            <summary>
            Get the index'th element in the array if it has not been deleted.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.IReadOnlyDMCompactingArray`1.NumberAlive">
            <summary>
            Returns the number of non-deleted elements in the array.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.JointCallback`3">
            <summary>
            Invoke a callback when two dependencies are fulfilled.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.JointCallback`3.Callback">
            <summary>
            The function that will be called when <see cref="P:BagoumLib.DataStructures.JointCallback`3.First"/> and <see cref="P:BagoumLib.DataStructures.JointCallback`3.Second"/> are provided.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.JointCallback`3.First">
            <summary>
            First value to be passed to the callback.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.JointCallback`3.Second">
            <summary>
            Second value to be passed to the callback.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.JointCallback`3.#ctor(System.Func{`0,`1,`2})">
            <inheritdoc cref="T:BagoumLib.DataStructures.JointCallback`3"/>
        </member>
        <member name="M:BagoumLib.DataStructures.JointCallback`3.#ctor(System.Action{`0,`1})">
            <inheritdoc cref="T:BagoumLib.DataStructures.JointCallback`3"/>
        </member>
        <member name="M:BagoumLib.DataStructures.JointCallback`3.SetFirst(`0)">
            <summary>
            Provide the first value, and invoke the callback if the second value is already provided.
            </summary>
            <exception cref="T:System.Exception">Thrown when the first value is already provided.</exception>
        </member>
        <member name="M:BagoumLib.DataStructures.JointCallback`3.SetSecond(`1)">
            <summary>
            Provide the second value, and invoke the callback if the first value is already provided.
            </summary>
            <exception cref="T:System.Exception">Thrown when the second value is already provided.</exception>
        </member>
        <member name="T:BagoumLib.DataStructures.JointDisposable">
            <summary>
            A disposable token that, when disposed, disposes multiple other tokens and then calls a function.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.JointDisposable.#ctor(System.Action,System.IDisposable[])">
            <inheritdoc cref="T:BagoumLib.DataStructures.JointDisposable"/>
        </member>
        <member name="M:BagoumLib.DataStructures.JointDisposable.#ctor(System.Action,System.Collections.Generic.IReadOnlyList{System.IDisposable})">
            <inheritdoc cref="T:BagoumLib.DataStructures.JointDisposable"/>
        </member>
        <member name="M:BagoumLib.DataStructures.JointDisposable.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.JointDisposable.MaybeJoint(System.IDisposable,System.IDisposable)">
            <summary>
            Create a <see cref="T:BagoumLib.DataStructures.JointDisposable"/> if `b` is nonnull. Otherwise, return `a`.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.SinglyLinkedList`1">
            <summary>
            A data structure containing a value and a nullable pointer to a continuation.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.SinglyLinkedList`1.#ctor(`0,BagoumLib.DataStructures.SinglyLinkedList{`0})">
            <summary>
            A data structure containing a value and a nullable pointer to a continuation.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.SinglyLinkedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.ListDisposable">
            <summary>
            A disposable object that nests multiple other disposables.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.ListDisposable.#ctor(System.Collections.Generic.IReadOnlyList{System.IDisposable})">
            <inheritdoc cref="T:BagoumLib.DataStructures.ListDisposable"/>
        </member>
        <member name="M:BagoumLib.DataStructures.ListDisposable.From``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.IDisposable})">
            <inheritdoc cref="T:BagoumLib.DataStructures.ListDisposable"/>
        </member>
        <member name="M:BagoumLib.DataStructures.ListDisposable.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.Node`1">
            <summary>
            An object holding inert data for a NodeLinkedList. Instances are cached.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.Node`1.Prev">
            <summary>
            Previous node in the list.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.Node`1.Next">
            <summary>
            Next node in the list.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.Node`1.Value">
            <summary>
            Value of contained data.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.Node`1.DeletedCount">
            <summary>
            The number of times this object has been deleted. Use this to determine if the object has been deleted during iteration.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.Node`1.LinkedList">
            <summary>
            A singly-linked list made up of <see cref="T:BagoumLib.DataStructures.Node`1"/>s.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Node`1.LinkedList.Remove(BagoumLib.DataStructures.Node{`0})">
            <summary>
            Remove a node. The node may still be used by the caller and later reinserted.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Node`1.LinkedList.Destroy(BagoumLib.DataStructures.Node{`0})">
            <summary>
            Remove a node and push it to the cache. The node must not be reused after this is called.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Node`1.LinkedList.At(System.Int32)">
            <summary>
            This method is slow
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Node`1.LinkedList.IndexOf(BagoumLib.DataStructures.Node{`0})">
            <summary>
            This method is slow
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.SafeResizableArray`1">
            <summary>
            Fast resizeable wrapper around T[] that is safe for arbitrary indexing.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.SafeResizableArray`1.#ctor(System.Int32)">
            <inheritdoc cref="T:BagoumLib.DataStructures.SafeResizableArray`1"/>
        </member>
        <member name="M:BagoumLib.DataStructures.SafeResizableArray`1.SafeAssign(System.Int32,`0)">
            <summary>
            Assign the index'th element in the array. If the underlying array is too small, increase its size.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.SafeResizableArray`1.SafeGet(System.Int32)">
            <summary>
            Get the index'th element in the array, or return the default value if it is out of bounds.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.SafeResizableArray`1.EmptyAndReset">
            <summary>
            Clear all elements in the array and reset it to its base size.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.StackLet`1">
            <summary>
            Wrapper around Stack.Push to allow `using`/Dispose pattern.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StackLet`1.#ctor(System.Collections.Generic.Stack{`0})">
            <summary>
            Wrapper around Stack.Push to allow `using`/Dispose pattern.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.StackList`1">
            <summary>
            A stack that can also be indexed like a list.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.StackList`1.Count">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.#ctor(System.Int32)">
            <inheritdoc cref="T:BagoumLib.DataStructures.StackList`1"/>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.Push(`0)">
            <summary>
            Add an element to the end of the stack.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.Pop">
            <summary>
            Remove and return the last element.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.Peek">
            <summary>
            Return the last element.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.Peek(System.Int32)">
            <summary>
            Return the `distance`'th element from the back (distance = 1 is the last element).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.MaybePeek">
            <summary>
            Return the last element if the stack is not empty; otherwise, return 
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.Clear">
            <summary>
            Empty all elements from the stack.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.StackList`1.Item(System.Int32)">
            <summary>
            Get a reference to the 'ind''th element.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.StackList`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.StackList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.StateFlow`1">
            <summary>
            A helper to manage state flow between states of type T.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.StateFlow`1.State">
            <summary>
            The current state of the flow transfer.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.StateFlow`1.StateEv">
            <inheritdoc cref="P:BagoumLib.DataStructures.StateFlow`1.State"/>
        </member>
        <member name="P:BagoumLib.DataStructures.StateFlow`1.NextState">
            <summary>
            A canceller that contains the next state for the flow transfer.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.StateFlow`1.Cancelled">
            <summary>
            Returns true if <see cref="P:BagoumLib.DataStructures.StateFlow`1.NextState"/> is cancelled.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StateFlow`1.#ctor(`0)">
            <inheritdoc cref="T:BagoumLib.DataStructures.StateFlow`1"/>
        </member>
        <member name="M:BagoumLib.DataStructures.StateFlow`1.Start">
            <summary>
            Start the state flow.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StateFlow`1.RunState(BagoumLib.Functional.Maybe{`0})">
            <summary>
            Execute the current <see cref="P:BagoumLib.DataStructures.StateFlow`1.State"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StateFlow`1.SetNext(`0)">
            <summary>
            Set the next state to execute by calling <see cref="P:BagoumLib.DataStructures.StateFlow`1.NextState"/>.<see cref="M:BagoumLib.Cancellation.GCancellable`1.Cancel(`0)"/>. The next state will only be executed
             when the current state coroutine calls <see cref="M:BagoumLib.DataStructures.StateFlow`1.GoToNext(`0)"/> or <see cref="M:BagoumLib.DataStructures.StateFlow`1.GoToNextIfCancelled"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StateFlow`1.GoToNext(`0)">
            <summary>
            Updates <see cref="P:BagoumLib.DataStructures.StateFlow`1.State"/>, sets a new token in <see cref="P:BagoumLib.DataStructures.StateFlow`1.NextState"/>,
             and runs the code for the next state (as implemented virtually in <see cref="M:BagoumLib.DataStructures.StateFlow`1.RunState(BagoumLib.Functional.Maybe{`0})"/>).
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StateFlow`1.GoToNextIfCancelled">
            <summary>
            If <see cref="P:BagoumLib.DataStructures.StateFlow`1.NextState"/> is cancelled, then executes that state and returns true.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.StateFlow`1.GoToNextWithDefault(`0)">
            <summary>
            Execute the next state as provided in <see cref="P:BagoumLib.DataStructures.StateFlow`1.NextState"/>, or if <see cref="P:BagoumLib.DataStructures.StateFlow`1.NextState"/> is not set then use the default instead.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructures.SubList`1">
            <summary>
            A view over a subsection of a list.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.SubList`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.DataStructures.SubList`1.Offset">
            <summary>
            The offset of the start of this view from the start of the original list.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.SubList`1.Source">
            <summary>
            The original list.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.SubList`1.#ctor(System.Collections.Generic.IReadOnlyList{`0},System.Int32,System.Nullable{System.Int32})">
            <inheritdoc cref="T:BagoumLib.DataStructures.SubList`1"/>
        </member>
        <member name="P:BagoumLib.DataStructures.SubList`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.DataStructures.SubList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.DataStructures.Trie">
            <summary>
            A trie structure that supports finding the longest substring (starting from zero) of a string stored within it.
            <br/>The root node represents the empty string.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.Trie.IsLeaf">
            <summary>
            Whether or not this node marks the existence of a character.
            </summary>
        </member>
        <member name="P:BagoumLib.DataStructures.Trie.Parent">
            <summary>
            The parent of this trie.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Trie.#ctor">
            <summary>
            Create a trie.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Trie.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create a trie from a set of strings.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Trie.Add(System.String,System.Int32)">
            <summary>
            Add a string to this trie.
            <br/>If this is not the root trie, then this is equivalent to adding the string made of this trie's
             stored string and the provided string. eg. If this trie represents "abc" and Add("def") is called on this trie,
             then "abcdef" is added to the root trie.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Trie.Contains(System.String,System.Int32)">
            <summary>
            Check whether a string exists in this trie.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Trie.FindLongestSubstring(System.String)">
            <summary>
            Find the longest substring (starting at index zero) of a string that exists within this trie.
            Eg. If this trie contains "abc" and "ape", then
            <br/>FindLongestSubstring("abcd") = "abc"
            <br/>FindLongestSubstring("pe") = null
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructures.Trie.Remove(System.ReadOnlySpan{System.Char})">
            <summary>
            Remove a string from this trie.
            </summary>
            <returns>True iff a string was removed.</returns>
        </member>
        <member name="T:BagoumLib.Completion">
            <summary>
            Enum describing the completion status of a task.
            </summary>
        </member>
        <member name="F:BagoumLib.Completion.Standard">
            <summary>
            Process ran to completion.
            </summary>
        </member>
        <member name="F:BagoumLib.Completion.SoftSkip">
            <summary>
            Process received a skip signal. Will not throw OperationCancelledException.
            </summary>
        </member>
        <member name="F:BagoumLib.Completion.Cancelled">
            <summary>
            Process received a cancel signal. Will throw OperationCancelledException.
            </summary>
        </member>
        <member name="T:BagoumLib.InterruptionStatus">
            <summary>
            Enum describing the status of a process that may be interrupted by another process.
            </summary>
        </member>
        <member name="F:BagoumLib.InterruptionStatus.Normal">
            <summary>
            The process has not yet been interrupted.
            </summary>
        </member>
        <member name="F:BagoumLib.InterruptionStatus.Continue">
            <summary>
            The process was previously interrupted but may continue.
            </summary>
        </member>
        <member name="F:BagoumLib.InterruptionStatus.Interrupted">
            <summary>
            The process is currently being interrupted by another process.
            </summary>
        </member>
        <member name="F:BagoumLib.InterruptionStatus.Abort">
            <summary>
            The process should abort due to a signal from an interrupting process,
             or if the interrupting process itself was cancelled.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.ArrayOverlapperEvent`1">
            <summary>
            An event that receives arrays of a fixed size, and outputs overlapping arrays of that same size.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ArrayOverlapperEvent`1.BlockSize">
            <summary>
            The number of elements that will be aggregated in each chunk of data.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ArrayOverlapperEvent`1.EvictionIndices">
            <summary>
            The number of indices that will be evicted every time the event yields a new value.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ArrayOverlapperEvent`1.EvictionRate">
            <summary>
            The percentage of the block that will be evicted every time the event yields a new value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.ArrayOverlapperEvent`1.#ctor(System.Int32,System.Double,System.Boolean)">
            <inheritdoc cref="T:BagoumLib.Events.ArrayOverlapperEvent`1"/>
        </member>
        <member name="M:BagoumLib.Events.ArrayOverlapperEvent`1.OnNext(`0[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ArrayOverlapperEvent`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ArrayOverlapperEvent`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ArrayOverlapperEvent`1.Subscribe(System.IObserver{`0[]})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.ChunkerEvent`1">
            <summary>
            An event that receives items and outputs them in non-overlapping arrays of length <see cref="P:BagoumLib.Events.ChunkerEvent`1.BlockSize"/>.
            <br/>Note that the final partial chunk will not be output when <see cref="M:BagoumLib.Events.ChunkerEvent`1.OnCompleted"/> is called, unless
            <see cref="F:BagoumLib.Events.ChunkerEvent`1.pushOnCompletion"/> is set to true, in which case it will be output with the rest of the array
             set to `default`.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ChunkerEvent`1.NextChunk">
            <summary>
            The in-process chunk of data that will be issued to observers
             when <see cref="P:BagoumLib.Events.ChunkerEvent`1.AllotedIndicies"/> equals <see cref="P:BagoumLib.Events.ChunkerEvent`1.BlockSize"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ChunkerEvent`1.BlockSize">
            <summary>
            The number of elements that will be aggregated in each chunk of data.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ChunkerEvent`1.AllotedIndicies">
            <summary>
            The number of indices that have been set in <see cref="P:BagoumLib.Events.ChunkerEvent`1.NextChunk"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.ChunkerEvent`1.#ctor(System.Int32,System.Boolean)">
            <inheritdoc cref="T:BagoumLib.Events.ChunkerEvent`1"/>
        </member>
        <member name="M:BagoumLib.Events.ChunkerEvent`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ChunkerEvent`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ChunkerEvent`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ChunkerEvent`1.Subscribe(System.IObserver{`0[]})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.ConstantObservable`1">
            <summary>
            An observable with an unchanging value.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ConstantObservable`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ConstantObservable`1.#ctor(`0)">
            <summary>
            Create a new <see cref="T:BagoumLib.Events.ConstantObservable`1"/>.
            </summary>
            <param name="value">Fixed value of the observable.</param>
        </member>
        <member name="M:BagoumLib.Events.ConstantObservable`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.IDisturbable`1">
            <summary>
            <see cref="T:BagoumLib.Events.DisturbedEvented`2"/> with only the first type parameter (type of disturbance effect).
            </summary>
        </member>
        <member name="M:BagoumLib.Events.IDisturbable`1.AddDisturbance(BagoumLib.Events.IBObservable{`0})">
            <summary>
            Add a disturbance.
            Whenver the disturbance receives a new value, this aggregate will update as well.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.IDisturbable`1.AddConst(`0)">
            <summary>
            Add a constant value disturbance.
            This aggregate will also update immediately.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.DisturbedEvented`2">
            <summary>
            DisturbedEvented is a wrapper around a core value (eg. a location) that can be modified by any number
             of disturbance effects (eg. shake effects) that all use the same aggregation function (eg. addition).
            <br/>Note that <see cref="M:BagoumLib.Events.DisturbedEvented`2.get_Value"/> and the event listeners
             will return the total value, whereas <see cref="M:BagoumLib.Events.DisturbedEvented`2.set_Value(`1)"/> will set the core value.
            <br/>Use <see cref="M:BagoumLib.Events.DisturbedEvented`2.get_BaseValue"/> to get the core value. <see cref="M:BagoumLib.Events.DisturbedEvented`2.set_BaseValue(`1)"/>
             will also set the core value.
            <br/>Note that, like <see cref="T:BagoumLib.Events.Evented`1"/>, new subscribers will be sent the current value immediately.
            </summary>
            <typeparam name="D">Type of disturbance effect.</typeparam>
            <typeparam name="V">Type of output value.</typeparam>
        </member>
        <member name="P:BagoumLib.Events.DisturbedEvented`2.BaseValue">
            <summary>
            Initial (aggregation seed) value.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.DisturbedEvented`2.Value">
            <summary>
            Aggregate value. Note that the set operator modifies <see cref="P:BagoumLib.Events.DisturbedEvented`2.BaseValue"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.DisturbedEvented`2.OnChange">
            <summary>
            Source event that is fired when this value changes.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.DisturbedEvented`2.Disturbances">
            <summary>
            List of disturbance effects applied to the core value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.#ctor(`1)">
            <summary>
            The initial value is published to onSet.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.op_Implicit(BagoumLib.Events.DisturbedEvented{`0,`1})~`1">
            <summary>
            Get the aggregate value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.Fold(`1,`0)">
            <summary>
            Function that aggregates values.
            </summary>
            <param name="acc">Accumulated value</param>
            <param name="next">Next value to fold into acc</param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.AddDisturbance(BagoumLib.Events.IBObservable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.AddConst(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.CopyDisturbances(BagoumLib.Events.DisturbedEvented{`0,`1})">
            <summary>
            Copy the disturbances from another <see cref="T:BagoumLib.Events.DisturbedEvented`2"/>.
            The copied disturbances will be bound by the same <see cref="T:System.IDisposable"/>s as the original.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.ClearDisturbances">
            <summary>
            Remove all additional provided values. 
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.Subscribe(System.IObserver{`1})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.OnNext(`1)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.DisturbedEvented`2.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.DisturbedFold`1">
            <summary>
            An aggregator that does a fold (reduction) over all values using the provided monoidal addition function.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedFold`1.#ctor(`0,System.Func{`0,`0,`0})">
            <summary>
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedFold`1.Fold(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.DisturbedFold`2">
            <summary>
            An aggregator that does a fold (reduction) over all values using the provided combination function.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedFold`2.#ctor(`1,System.Func{`1,`0,`1})">
            <summary>
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedFold`2.Fold(`1,`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.IAggregator`1">
            <summary>
            Interface for elements that can be combined in <see cref="T:BagoumLib.Events.DisturbedAggregation`1"/>.
            </summary>
            <typeparam name="D"></typeparam>
        </member>
        <member name="M:BagoumLib.Events.IAggregator`1.FoldOnto(`0)">
            <summary>
            Fold this value onto the accumulated value.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.Aggregator`2">
            <summary>
            An element that can be combined in <see cref="T:BagoumLib.Events.DisturbedAggregation`1"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.Aggregator`2.Data">
            <summary>
            Data contained in this element.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.Aggregator`2.Folder">
            <summary>
            Method for combining this element's data with the accumulator.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Aggregator`2.#ctor(`1,System.Func{`0,`1,`0})">
            <inheritdoc cref="T:BagoumLib.Events.Aggregator`2"/>
        </member>
        <member name="M:BagoumLib.Events.Aggregator`2.FoldOnto(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.DisturbedAggregation`1">
            <summary>
            An aggregator that folds functions of type T->T onto a base value of type T.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedAggregation`1.#ctor(`0)">
            <summary>
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedAggregation`1.Fold(`0,BagoumLib.Events.IAggregator{`0})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.OverrideEvented`1">
            <summary>
            Get the most recent value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.OverrideEvented`1.#ctor(`0)">
            <summary>
            </summary>
        </member>
        <member name="M:BagoumLib.Events.OverrideEvented`1.Fold(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.DisturbedSum`1">
            <summary>
            Get the sum of all values.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedSum`1.#ctor">
            <summary>
            Get the sum of all values with the monoidal zero.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedSum`1.#ctor(`0)">
            <summary>
            Get the sum of all values with the provided base value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedSum`1.#ctor(BagoumLib.Events.IBObservable{`0})">
            <summary>
            Get the sum of all values with the provided base value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedSum`1.Fold(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.DisturbedProduct`1">
            <summary>
            Get the product of all values.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedProduct`1.#ctor">
            <summary>
            Get the product of all values with the monoidal zero.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedProduct`1.#ctor(`0)">
            <summary>
            Get the product of all values with the provided base value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedProduct`1.#ctor(BagoumLib.Events.IBObservable{`0})">
            <summary>
            Get the product of all values with the provided base value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedProduct`1.Fold(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.DisturbedAnd">
            <summary>
            Get the AND of all provided values (true when all values are true).
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedAnd.#ctor(System.Boolean)">
            <summary>
            </summary>
            <param name="first">Initial value (true by default)</param>
        </member>
        <member name="M:BagoumLib.Events.DisturbedAnd.Fold(System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.DisturbedOr">
            <summary>
            Get the OR of all provided values (true when any value is true).
            </summary>
        </member>
        <member name="M:BagoumLib.Events.DisturbedOr.#ctor(System.Boolean)">
            <summary>
            </summary>
            <param name="first">Initial value (false by default)</param>
        </member>
        <member name="M:BagoumLib.Events.DisturbedOr.Fold(System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.IBObservable`1">
            <summary>
            An observable that tracks its last published value.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.IBObservable`1.HasValue">
            <summary>
            Whether or not this observable has ever published a value.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.IBObservable`1.Value">
            <summary>
            The last published value of this observable.
            <br/>Undefined behavior if <see cref="P:BagoumLib.Events.IBObservable`1.HasValue"/> is false.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.ICObservable`1">
            <summary>
            An observable that has a "current" value.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.IBSubject`2">
            <summary>
            A subject that tracks its last published observable value.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.ICSubject`2">
            <summary>
            A subject that has a "current" value.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.IBSubject`1">
            <summary>
            A subject that tracks its last published observable value.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.ICSubject`1">
            <summary>
            A subject that has a "current" value.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.Event`2">
            <summary>
            A subject that observes elements of type T, maps them to type U, and publishes mapped elements to observers.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.Event`2.HasValue">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Events.Event`2.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.Event`2.#ctor(System.Func{`0,`1})">
            <summary>
            Create an event with a function to map from intake to output values.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Event`2.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.Event`2.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.Event`2.Subscribe(System.IObserver{`1})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.Event`2.Subscribe(System.IObserver{`1},System.Int32)">
            <inheritdoc cref="M:BagoumLib.Events.Event`2.Subscribe(System.IObserver{`1})"/>
        </member>
        <member name="M:BagoumLib.Events.Event`2.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.Event`1">
            <summary>
            A subject that observes elements of type T and publishes them to observers without modification.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Event`1.#ctor">
            <summary>
            Create an event.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.AccEvent`1">
            <summary>
            An event that records all its published values in a list.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.AccEvent`1.Published">
            <summary>
            All values published by this event.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.AccEvent`1.HasValue">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Events.AccEvent`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.AccEvent`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.AccEvent`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.AccEvent`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.AccEvent`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.AccEvent`1.Clear">
            <summary>
            Clear the accumulated values in Published.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.Evented`2">
            <summary>
            A subject that observes elements of type T, maps them to type U, and publishes mapped elements to observers.
            <br/>New subscribers are sent the existing value as well as any new values.
            <br/>Always has a current value.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.Evented`2.AllowSameValueUpdate">
            <summary>
            Allow the same value to be published multiple times in a row.
            <br/>True by default. Note that <see cref="M:BagoumLib.Events.Evented`2.PublishIfNotSame(`0)"/> will not
             publish a value if it is the same as the previous one, regardless of this
             setting.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.Evented`2.Value">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Events.Evented`2.OnChange">
            <summary>
            Event that fires when the value updates. You can subscribe to this directly if you do not want
             to receive the existing value on subscription.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Evented`2.#ctor(`1,System.Func{`0,`1})">
            <summary>
            The initial value is published to onSet.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Evented`2.Subscribe(System.IObserver{`1})">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.Evented`2.Subscribe(System.IObserver{`1},System.Int32)">
            <inheritdoc cref="M:BagoumLib.Events.Evented`2.Subscribe(System.IObserver{`1})" />
        </member>
        <member name="M:BagoumLib.Events.Evented`2.OnNext(`0)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.Evented`2.OnError(System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.Evented`2.OnCompleted">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.Evented`2.PublishIfNotSame(`0)">
            <summary>
            Set a new value only if it is not equal to the existing value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Evented`2.op_Implicit(BagoumLib.Events.Evented{`0,`1})~`1">
            <summary>
            Gets <see cref="P:BagoumLib.Events.Evented`2.Value"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.Evented`1">
            <summary>
            A wrapper around a value that publishes an event whenever it is set.
            New subscribers are sent the existing value as well as any new values.
            <br/>(Same as BehaviorSubject.)
            <br/>This class can be serialized and deserialized in Newtonsoft.JSON.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Evented`1.#ctor(`0)">
            <summary>
            The initial value is published to onSet.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Evented`1.op_Implicit(BagoumLib.Events.Evented{`0})~`0">
            <summary>
            Gets <see cref="P:BagoumLib.Events.Evented`2.Value"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.IdealOverride`1">
            <summary>
            A wrapper around an ideal value that may be overriden by a temporary value.
            <see cref="M:BagoumLib.Events.IdealOverride`1.set_Value(`0)"/> will set the override.
            <br/>The ideal value can be accessed as <see cref="P:BagoumLib.Events.IdealOverride`1.Ideal"/>.
            <br/>Note that the functionality here is very similar to <see cref="T:BagoumLib.Events.OverrideEvented`1"/>, but
             this is optimized for the case where there is one ideal value and one override value that may be
             revoked at will.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.IdealOverride`1.Ideal">
            <summary>
            The ideal value, which is the current value if there is no override.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.IdealOverride`1.Value">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.IdealOverride`1.RevokeOverride">
            <summary>
            Reset the override value, so <see cref="M:BagoumLib.Events.IdealOverride`1.get_Value"/> will return the ideal value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.IdealOverride`1.#ctor(`0)">
            <inheritdoc cref="T:BagoumLib.Events.IdealOverride`1"/>
        </member>
        <member name="M:BagoumLib.Events.IdealOverride`1.Subscribe(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.IdealOverride`1.OnCompleted">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.IdealOverride`1.OnError(System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.IdealOverride`1.OnNext(`0)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.IdealOverride`1.SetIdeal(`0)">
            <summary>
            Modify <see cref="P:BagoumLib.Events.IdealOverride`1.Ideal"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.EventedSerializer">
            <summary>
            Newtonsoft.Json serializer for <see cref="T:BagoumLib.Events.Evented`1"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Events.EventedSerializer.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.EventedSerializer.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.EventedSerializer.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:BagoumLib.Events.LazyEvented`1">
            <summary>
            An event wrapper around a zero-argument function whose value may change unpredictably.
            <br/>This wrapper will only publish return values of the wrapped function when
             one of the provided triggers is updated or <see cref="M:BagoumLib.Events.LazyEvented`1.Recompute"/> is called.
            <br/>If the value does not change, this wrapper will not publish anything.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.LazyEvented`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.LazyEvented`1.#ctor(System.Func{`0},System.IObservable{System.Reactive.Unit}[])">
            <summary>
            The initial value is published to onSet.
            </summary>
            <param name="val">Function to lazily evaluate to obtain a value</param>
            <param name="triggers">Observables to use as triggers for function reealuation</param>
        </member>
        <member name="M:BagoumLib.Events.LazyEvented`1.op_Implicit(BagoumLib.Events.LazyEvented{`0})~`0">
            <summary>
            Get the value of this event.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.LazyEvented`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.LazyEvented`1.Recompute">
            <summary>
            Explicitly recompute the value of the function.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.LazyEvented`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.LazyEvented`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.LazyEvented`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.Lerpifier`1">
            <summary>
            Lerpifier tracks a changing value (targetValue) by smoothly lerping to it.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.Lerpifier`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.Lerpifier`1.#ctor(System.Func{`0,`0,System.Single,`0},System.Func{`0},System.Single)">
            <summary>
            Create a new <see cref="T:BagoumLib.Events.Lerpifier`1"/>.
            </summary>
            <param name="lerper">Lerping function.</param>
            <param name="targetValue">Initial target function.</param>
            <param name="lerpTime">Time it should take to lerp between an existing value and a new target function.</param>
        </member>
        <member name="M:BagoumLib.Events.Lerpifier`1.HardReset">
            <summary>
            Reset the state of the container as if it was initialized with the current <see cref="F:BagoumLib.Events.Lerpifier`1.targetValue"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.Lerpifier`1.Update(System.Single)">
            <summary>
            Update the state of the container.
            </summary>
            <param name="dt">Time passed since last update</param>
        </member>
        <member name="M:BagoumLib.Events.Lerpifier`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.Lerpifier`1.op_Implicit(BagoumLib.Events.Lerpifier{`0})~`0">
            <summary>
            Get the current value of the container.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.LiftEvented`3">
            <summary>
            A lifted binary function over <see cref="T:BagoumLib.Events.Evented`1"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.LiftEvented`3.Tokens">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Events.LiftEvented`3.Value">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.LiftEvented`3.#ctor(System.Func{`0,`1,`2},BagoumLib.Events.ICObservable{`0},BagoumLib.Events.ICObservable{`1})">
            <summary>
            The initial value is published to onSet.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.LiftEvented`3.Subscribe(System.IObserver{`2})">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Events.LiftEvented`3.Reevaluate">
            <summary>
            Re-evaluate the arguments and publish the result.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.LiftEvented`3.op_Implicit(BagoumLib.Events.LiftEvented{`0,`1,`2})~`2">
            <summary>
            Gets <see cref="P:BagoumLib.Events.LiftEvented`3.Value"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Events.NullDisposable">
            <summary>
            A disposable that doesn't do anything.
            </summary>
        </member>
        <member name="F:BagoumLib.Events.NullDisposable.Default">
            <summary>
            Singleton instance of <see cref="T:BagoumLib.Events.NullDisposable"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.NullDisposable.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.NullEvent`1">
            <summary>
            An event that ignores subscriptions, values, errors, and completions.
            </summary>
        </member>
        <member name="F:BagoumLib.Events.NullEvent`1.Default">
            <summary>
            Singleton instance of <see cref="T:BagoumLib.Events.NullEvent`1"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.NullEvent`1.HasValue">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Events.NullEvent`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.NullEvent`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.NullEvent`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.NullEvent`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.NullEvent`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.PushLerper`1">
            <summary>
            A wrapper around a sequence of values that smoothly lerps to the most recent value provided.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BagoumLib.Events.PushLerper`1.LerpTime">
            <summary>
            Function that determines how much time it takes to lerp from the previous value (first argument)
             to the next value (second argument).
            </summary>
        </member>
        <member name="P:BagoumLib.Events.PushLerper`1.IsSteadyState">
            <summary>
            True iff the lerp process has attained its endpoint.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.PushLerper`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.#ctor(System.Single,System.Func{`0,`0,System.Single,`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.#ctor(System.Func{`0,`0,System.Single},System.Func{`0,`0,System.Single,`0})">
            <summary>
            </summary>
            <param name="lerpTime">A pure function that returns the lerp time given the previous and next values.</param>
            <param name="lerper"></param>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.Push(`0,System.Single)">
            <summary>
            Set a new target value to lerp to.
            </summary>
            <param name="targetValue">The new target value.</param>
            <param name="initTime">The time that the lerp between the current value and the new target should start at.</param>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.PushIfNotSame(`0,System.Single)">
            <summary>
            Set a new target value to lerp to (see <see cref="M:BagoumLib.Events.PushLerper`1.Push(`0,System.Single)"/>) if it is not the same as the existing target value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.ForcePushIfNotSame(`0,System.Single)">
            <summary>
            Force-set the current value to `targetValue` if it is not the same as the existing target value.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.Update(System.Single)">
            <summary>
            Update the lerp process for a given delta-time.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.ChangeLerpTime(System.Func{`0,`0,System.Single})">
            <summary>
            Change the function that determines how long it takes to lerp between existing and target values.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.Unset">
            <summary>
            Puts the object in a state such that the next time a value is pushed, it will be instantaneously lerped to.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.op_Implicit(BagoumLib.Events.PushLerper{`0})~`0">
            <summary>
            Get the current value of a <see cref="T:BagoumLib.Events.PushLerper`1"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerper`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.PushLerperF`1">
            <summary>
            A wrapper around a sequence of single-argument functions that smoothly lerps to the most recent function.
            <br/>The functions are evaluated with the time-since-push as the single argument.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BagoumLib.Events.PushLerperF`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.PushLerperF`1.#ctor(System.Single,System.Func{`0,`0,System.Single,`0})">
            <inheritdoc cref="T:BagoumLib.Events.PushLerperF`1"/>
        </member>
        <member name="M:BagoumLib.Events.PushLerperF`1.Push(System.Func{System.Single,`0},System.Single)">
            <inheritdoc cref="M:BagoumLib.Events.PushLerper`1.Push(`0,System.Single)"/>
        </member>
        <member name="M:BagoumLib.Events.PushLerperF`1.Unset">
            <summary>
            Puts the object in a state such that the next time a function is pushed, it will be instantaneously lerped to.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerperF`1.Update(System.Single)">
            <inheritdoc cref="M:BagoumLib.Events.PushLerper`1.Update(System.Single)"/>
        </member>
        <member name="M:BagoumLib.Events.PushLerperF`1.op_Implicit(BagoumLib.Events.PushLerperF{`0})~`0">
            <summary>
            Get the current value of a <see cref="T:BagoumLib.Events.PushLerper`1"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.PushLerperF`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.ReplayEvent`1">
            <summary>
            An event that sends the <see cref="P:BagoumLib.Events.ReplayEvent`1.History"/> most recent published elements to any new subscribers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BagoumLib.Events.ReplayEvent`1.History">
            <summary>
            Maximum number of recently published elements to send to new subscribers.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.ReplayEvent`1.HasValue">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Events.ReplayEvent`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ReplayEvent`1.#ctor(System.Int32)">
            <summary>
            Create a new <see cref="T:BagoumLib.Events.ReplayEvent`1"/>.
            </summary>
            <param name="history">Maximum number of recently published elements to send to new subscribers</param>
        </member>
        <member name="M:BagoumLib.Events.ReplayEvent`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ReplayEvent`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ReplayEvent`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.ReplayEvent`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Events.TriggerEvent`1">
            <summary>
            An event that will only dispatch listeners the first time it receives
             an OnNext call, and then noop until it is reset.
            </summary>
        </member>
        <member name="P:BagoumLib.Events.TriggerEvent`1.HasValue">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Events.TriggerEvent`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.TriggerEvent`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.TriggerEvent`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.TriggerEvent`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.TriggerEvent`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Events.TriggerEvent`1.Reset">
            <summary>
            Reset the trigger so it can be called again.
            </summary>
        </member>
        <member name="M:BagoumLib.Events.TriggerEvent`1.ResetOn``1(System.IObservable{``0})">
            <summary>
            When the provided observable sends a value, this trigger will be reset.
            </summary>
        </member>
        <member name="T:BagoumLib.JSONHelpers">
            <summary>
            Helper utilities for JSON serialization.
            </summary>
        </member>
        <member name="F:BagoumLib.JSONHelpers.GetTypeName">
            <summary>
            Get a type name according to Newtonsoft.Json serialization rules.
            </summary>
        </member>
        <member name="T:BagoumLib.SingletonConverter`1">
            <summary>
            Newtonsoft.Json serializer for singleton subclasses of a parent class T.
            <br/>The singleton for a subclass must be accessible as static property `Subclass.S`,
            or type T must have a static property SINGLETON_KEY that provides the name of the property.
            <br/>The singletons are serialized using the local class name (Type.Name).
            </summary>
        </member>
        <member name="M:BagoumLib.SingletonConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.SingletonConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.SingletonConverter`1.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:BagoumLib.ComplexDictKeyConverter`2">
            <summary>
            JSON converter for dictionaries with non-primitive keys.
            </summary>
        </member>
        <member name="M:BagoumLib.ComplexDictKeyConverter`2.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.ComplexDictKeyConverter`2.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.ComplexDictKeyConverter`2.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:BagoumLib.MultiException">
            <summary>
            An exception class with basically the same functionality as <see cref="T:System.AggregateException"/>, but with
            more explicit control over the message.
            </summary>
        </member>
        <member name="P:BagoumLib.MultiException.InnerExceptions">
            <summary>
            List of exceptions aggregated within this.
            </summary>
        </member>
        <member name="M:BagoumLib.MultiException.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Exception})">
            <inheritdoc cref="T:BagoumLib.MultiException"/>
        </member>
        <member name="M:BagoumLib.MultiException.#ctor(System.String,System.Exception[])">
            <inheritdoc cref="T:BagoumLib.MultiException"/>
        </member>
        <member name="T:BagoumLib.Exceptions">
            <summary>
            Helpers for exceptions.
            </summary>
        </member>
        <member name="M:BagoumLib.Exceptions.MaybeAggregate``1(System.Collections.Generic.IList{``0})">
            <summary>
            Combine multiple errors into one.
            </summary>
        </member>
        <member name="M:BagoumLib.Exceptions.PrintNestedException(System.Exception,System.Boolean)">
            <summary>
            Return a string describing a nested exception, showing the outermost
             exception first and then moving inwards.
            <br/>Includes a stacktrace from the innermost exception.
            </summary>
        </member>
        <member name="M:BagoumLib.Exceptions.PrintNestedExceptionInverted(System.Exception,System.Boolean)">
            <summary>
            Return a string describing a nested exception, showing the innermost
             exception first and then moving outwards.
            <br/>Includes a stacktrace from the innermost exception.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.EnumerateVisitor">
            <summary>
            Expression visitor that enumerates all nodes in preorder.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.EnumerateVisitor.Enumerate(System.Linq.Expressions.Expression)">
            <summary>
            Enumerate all nodes in preorder.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.EnumerateVisitor.Visit(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Expressions.ExExtensions">
            <summary>
            Extensions and helpers for expression trees.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Eq(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.Equal (equality comparison)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Is(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.Assign (variable assignment)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.Add (addition operator). If both sides are constants,
            then produces a constant expression instead of an addition expression.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Add(System.Linq.Expressions.Expression,System.Single)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Sub(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.Subtract (subtraction operator). If both sides are constants,
            then produces a constant expression instead of a subtraction expression.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Sub(System.Linq.Expressions.Expression,System.Single)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Sub(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Mul(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.Multiply (multiplication operator). If both sides are constants,
            then produces a constant expression instead of a multiplication expression.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Mul(System.Linq.Expressions.Expression,System.Single)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Mul(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Div(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.Divide (division operator). If both sides are constants,
            then produces a constant expression instead of a division expression.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Div(System.Linq.Expressions.Expression,System.Single)">
            <inheritdoc cref="M:BagoumLib.Expressions.ExExtensions.Div(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Neg(System.Linq.Expressions.Expression)">
            <summary>
            Ex.Negate (arithmetic negation)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Complement(System.Linq.Expressions.Expression)">
            <summary>
            The subtraction expression (1 - me)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Length(System.Linq.Expressions.Expression)">
            <summary>
            Ex.ArrayLength
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Index(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.ArrayAccess
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Ipp(System.Linq.Expressions.Expression)">
            <summary>
            Ex.PostIncrementAssign (me++)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.LT(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.LessThan
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.LT0(System.Linq.Expressions.Expression)">
            <summary>
            The boolean expression for (me &lt; 0)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.GT(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.GreaterThan
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.GT0(System.Linq.Expressions.Expression)">
            <summary>
            The boolean expression for (me &gt; 0)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.AndAlso (short-circuit and)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Ex.OrElse (short-circuit else)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Field(System.Linq.Expressions.Expression,System.String)">
            <summary>
            Ex.PropertyOrField
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Cast``1(System.Linq.Expressions.Expression)">
            <summary>
            Ex.Convert
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.Cast(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Ex.Convert
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.As``1(System.Linq.Expressions.Expression)">
            <summary>
            Ex.TypeAs
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.As(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Ex.TypeAs
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.DictContains(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            The method call (dict.ContainsKey(key))
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.DictGetOrThrow(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.String)">
            <summary>
            The expression for (dict.ContainsKey(key) ? dict[key] : throw new Exception(err))
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.DictSafeGet(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            The expression for (dict.ContainsKey(key) ? dict[key] : deflt)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.DictGet(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            The expression for (dict[key]). Note that this allows read and write.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.DictSet(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            The expression for (dict[key] = value)
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.IsConstant(System.Linq.Expressions.Expression)">
            <summary>
            True iff the expression is a constant value.
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.IsSimplifiable(System.Linq.Expressions.Expression)">
            <summary>
            True iff the expression is a constant or a parameter.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.TryAsConst``1(System.Linq.Expressions.Expression,``0@)">
            <summary>
            Get the value of the expression if it is a <see cref="T:System.Linq.Expressions.ConstantExpression"/> with type T.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExExtensions.TryAsAnyConst(System.Linq.Expressions.Expression,System.Object@)">
            <summary>
            Get the value of the expression if it is a <see cref="T:System.Linq.Expressions.ConstantExpression"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.ExFunction">
            <summary>
            A representation of a <see cref="T:System.Reflection.MethodInfo"/> with efficient static lookup methods and
             convenience methods for expression invocation.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.ExFunction.Mi">
            <summary>
            Wrapped <see cref="T:System.Reflection.MethodInfo"/> instance.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Create an <see cref="T:BagoumLib.Expressions.ExFunction"/> with the provided <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.Of(System.Linq.Expressions.Expression[])">
            <summary>
            Create an expression representing calling a static method on the provided arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.InstanceOf(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <summary>
            Create an expression representing calling an instance method on the provided arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.WrapByRetType(System.Type,System.String,System.Type)">
            <summary>
            Disambiguate a method based on its return type.
            </summary>
            <param name="cls">Type containing the method</param>
            <param name="methodName">Method name</param>
            <param name="retType">Return type</param>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.Wrap(System.Type,System.String,System.Type[])">
            <summary>
            Disambiguate a method based on its parameter types.
            </summary>
            <param name="cls">Type containing the method</param>
            <param name="methodName">Method name</param>
            <param name="types">Parameter types</param>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.WrapAny(System.Type,System.String)">
            <summary>
            Get any method on the enclosing type with the corresponding method name.
            <br/>This function is cached.
            </summary>
            <param name="cls"></param>
            <param name="methodName"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.Wrap``1(System.String,System.Type[])">
            <summary>
            Disambiguate a method based on its parameter types.
            </summary>
            <typeparam name="C">Type containing the method</typeparam>
            <param name="methodName">Method name</param>
            <param name="types">Parameter types</param>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.WrapAny``1(System.String)">
            <summary>
            Find any method with the given name.
            </summary>
            <typeparam name="C">Type containing the method</typeparam>
            <param name="methodName">Method name</param>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.Wrap``2(System.String,System.Int32)">
            <summary>
            Disambiguate a method based on its parameter types, when all parameters are of the same type.
            </summary>
            <typeparam name="C">Type containing the method</typeparam>
            <typeparam name="T">Parameter type</typeparam>
            <param name="methodName">Method name</param>
            <param name="typeCt">Number of times the parameter occurs</param>
        </member>
        <member name="M:BagoumLib.Expressions.ExFunction.Wrap``1(System.Type,System.String,System.Int32)">
            <summary>
            Disambiguate a method based on its parameter types, when all parameters are of the same type.
            </summary>
            <param name="cls">Type containing the method</param>
            <typeparam name="T">Parameter type</typeparam>
            <param name="methodName">Method name</param>
            <param name="typeCt">Number of times the parameter occurs</param>
        </member>
        <member name="T:BagoumLib.Expressions.ExpressionPrinter">
            <summary>
            Converts an expression into C# source code using <see cref="T:BagoumLib.Expressions.LinearizeVisitor"/> and <see cref="T:BagoumLib.Expressions.PrintVisitor"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.ExpressionPrinter.InitialIndent">
            <summary>
            Mumber of tabs with which to start printing.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.ExpressionPrinter.TabToSpace">
            <summary>
            Number of spaces that one tab corresponds to.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.ExpressionPrinter.TypePrinter">
            <summary>
            Printer that can convert types into strings.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.ExpressionPrinter.ObjectPrinter">
            <summary>
            Printer that can convert simple objects into strings.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.ExpressionPrinter.SafeLinearize">
            <summary>
            Set this to true if you expect exceptions to arise unexpectedly. This will
             use more temporary variables to ensure the correct order of exception throwing.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExpressionPrinter.Linearize(System.Linq.Expressions.Expression)">
            <summary>
            Linearizes an expression using LinearizeVisitor.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExpressionPrinter.LinearizePrint(System.Linq.Expressions.Expression)">
            <summary>
            Linearizes an expression and then converts it into C# source code.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExpressionPrinter.Print(System.Linq.Expressions.Expression)">
            <summary>
            Runs PrintVisitor on an expression and then converts the output into C# source code.
            <br/>You will probably need to run Linearize first for complex expressions.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ExpressionPrinter.Stringify(BagoumLib.Expressions.PrintToken[])">
            <summary>
            Converts an array of PrintTokens generated from PrintVisitor into C# source code.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.LinearizeVisitor">
            <summary>
            Linearizes expressions.
            <br/>A linearized expression is one of:
            <br/>(1) an expression that can participate in basic C# value operations (eg. can be the X in `return 2 + X;`),
            <br/>(2) a BlockExpression whose statements satisfy (1) or (3) but are *not* BlockExpressions,
             and whose last statement only satisfies (1).
            <br/>(3) an expression with a return type of void (such as if/try/switch, or the elusive void BlockExpression),
             whose children are all linearized expressions.
            <br/>Linearized expressions can be converted to source code without too much difficulty. See <see cref="T:BagoumLib.Expressions.PrintVisitor"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.LinearizeVisitor.SafeExecution">
            <summary>
            If true, will assume that any expression can throw an exception,
             and as a result will always assign block results to temporary variables.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.WithAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Invariant: expr is linearized under (1) or (2).
            <br/>Returns a linearized expression under (1) or (2) equivalent to expr that,
             as a side effect, assigns the value of expr to dst.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.LinearizeVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <inheritdoc />
        </member>
        <member name="T:BagoumLib.Expressions.IObjectPrinter">
            <summary>
            Interface for converting objects into string representations.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.IObjectPrinter.Print(System.Object)">
            <summary>
            Convert an object into a string representation.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.CSharpObjectPrinter">
            <summary>
            Tries really hard to convert an object to a C# representation.
            <br/>Note that this is not possible for all types.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.CSharpObjectPrinter.TypePrinter">
            <summary>
            Type-to-string printer.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.CSharpObjectPrinter.FallbackToToString">
            <summary>
            Set this to true to use .ToString() if the value cannot be printed.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.CSharpObjectPrinter.Print(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Expressions.CSharpObjectPrinter.NoPrintMethodFallback(System.Object)">
            <summary>
            Method called when no standard method of printing the object succeeded.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.ReplaceParameterVisitor">
            <summary>
            An expression visitor that replaces a parameter with an arbitrary expression.
            <br/>The resulting tree may not be sound if the expression is of a different type
             or the parameter is written to and the expression is not writeable.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ReplaceParameterVisitor.#ctor(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            An expression visitor that replaces a parameter with an arbitrary expression.
            <br/>The resulting tree may not be sound if the expression is of a different type
             or the parameter is written to and the expression is not writeable.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ReplaceParameterVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Expressions.HasUnboundParameterVisitor">
            <summary>
            Checks if a expression tree has any parameters not bound in a Block.
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.HasUnboundParameterVisitor.UnboundParameters">
            <summary>
            All the unbound parameters.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.HasUnboundParameterVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Expressions.HasUnboundParameterVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Expressions.PrintAsParenthesizedVisitor">
            <summary>
            A visitor that transforms the provided expression into a parenthesized expression (only if necessary).
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.PrintAsParenthesizedVisitor.Parener">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintAsParenthesizedVisitor.#ctor(BagoumLib.Expressions.PrintVisitor)">
            <summary>
            Create a <see cref="T:BagoumLib.Expressions.PrintAsParenthesizedVisitor"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintAsParenthesizedVisitor.Visit(System.Linq.Expressions.Expression)">
            <inheritdoc />
        </member>
        <member name="T:BagoumLib.Expressions.PrintAsReturnVisitor">
            <summary>
            A visitor that transforms the provided expression with an implicit return into code with an explicit return.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintAsReturnVisitor.#ctor(BagoumLib.Expressions.PrintVisitor)">
            <summary>
            Create a <see cref="T:BagoumLib.Expressions.PrintAsReturnVisitor"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintAsReturnVisitor.Visit(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Expressions.PrintAsReturnVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Expressions.PrintAsStatementVisitor">
            <summary>
            A visitor that transforms the provided expression into a statement (ie. succeeds it with a semicolon).
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.PrintAsStatementVisitor.Stmter">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Expressions.PrintAsStatementVisitor.#ctor(BagoumLib.Expressions.PrintVisitor)">
            <summary>
            Create a <see cref="T:BagoumLib.Expressions.PrintAsStatementVisitor"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintAsStatementVisitor.Visit(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken">
            <summary>
            A data representation of elements that can be processed to print an <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Parameter">
            <summary>
            A parameter.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintToken.Parameter.#ctor(System.Linq.Expressions.ParameterExpression)">
            <summary>
            A parameter.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Constant">
            <summary>
            Any constant value.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintToken.Constant.#ctor(System.Object)">
            <summary>
            Any constant value.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.TypeName">
            <summary>
            The name of a type.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintToken.TypeName.#ctor(System.Type)">
            <summary>
            The name of a type.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Label">
            <summary>
            A label (used for gotos).
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintToken.Label.#ctor(System.Linq.Expressions.LabelTarget)">
            <summary>
            A label (used for gotos).
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Newline">
            <summary>
            A newline, which will also include any indents.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.UndoNewline">
            <summary>
            If the previous token is a newline, then cancel it out.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Indent">
            <summary>
            Add an indent to the printer.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Dedent">
            <summary>
            Remove an indent from the printer.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Semicolon">
            <summary>
            A semicolon.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintToken.Text">
            <summary>
            Any plain text to be printed.
            <br/>Do not put newlines/indents/dedents here, use the dedicated tokens instead.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintToken.Text.#ctor(System.String)">
            <summary>
            Any plain text to be printed.
            <br/>Do not put newlines/indents/dedents here, use the dedicated tokens instead.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintToken.op_Implicit(System.String)~BagoumLib.Expressions.PrintToken">
            <summary>
            Make a <see cref="T:BagoumLib.Expressions.PrintToken.Text"/> token from a string.
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.PrintToken.newline">
            <summary>
            <see cref="T:BagoumLib.Expressions.PrintToken.Newline"/> singleton
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.PrintToken.undoNewline">
            <summary>
            <see cref="T:BagoumLib.Expressions.PrintToken.UndoNewline"/> singleton
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.PrintToken.indent">
            <summary>
            <see cref="T:BagoumLib.Expressions.PrintToken.Indent"/> singleton
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.PrintToken.dedent">
            <summary>
            <see cref="T:BagoumLib.Expressions.PrintToken.Dedent"/> singleton
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.PrintToken.semicolon">
            <summary>
            <see cref="T:BagoumLib.Expressions.PrintToken.Semicolon"/> singleton
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintVisitorAbs">
            <summary>
            Abstract base class for expression visitors that convert a tree into a list of PrintTokens
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.PrintVisitorAbs.Tokens">
            <summary>
            Accumulated tokens from visiting a tree
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.PrintVisitorAbs.Parener">
            <summary>
            Sub-printer responsible for printing parenthesized expressions
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.PrintVisitorAbs.Stmter">
            <summary>
            Sub-printer responsible for printing expressions as statements
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.PrintVisitorAbs.Returner">
            <summary>
            Sub-printer responsible for printing expressions as return statements
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitorAbs.Add(BagoumLib.Expressions.PrintToken)">
            <summary>
            Add a token to be printed.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitorAbs.Add(BagoumLib.Expressions.PrintToken[])">
            <summary>
            Add many tokens to be printed.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.DerivativePrintVisitor">
            <summary>
            A printer that applies some modifications to a base printer.
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.DerivativePrintVisitor.parent">
            <summary>
            Base printer
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.DerivativePrintVisitor.Tokens">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Expressions.DerivativePrintVisitor.Parener">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Expressions.DerivativePrintVisitor.Stmter">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Expressions.DerivativePrintVisitor.Returner">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.DerivativePrintVisitor.#ctor(BagoumLib.Expressions.PrintVisitor)">
            <summary>
            Create a printer from the given base printer.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.PrintVisitor">
            <summary>
            Converts an expression into an array of <see cref="T:BagoumLib.Expressions.PrintToken"/>s that can be trivially printed.
            <br/>If the expression is linearized, then the output of this will construct valid C# source code,
            given a sufficiently apt type and object printer (see <see cref="T:BagoumLib.Expressions.ExpressionPrinter"/>).
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.PrintVisitor.Parener">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Expressions.PrintVisitor.Stmter">
            <inheritdoc />
        </member>
        <member name="P:BagoumLib.Expressions.PrintVisitor.Returner">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.#ctor">
            <summary>
            Create a printer.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.Print(System.Linq.Expressions.Expression)">
            <summary>
            Visit an expression and convert it to tokens, stored in <see cref="P:BagoumLib.Expressions.PrintVisitorAbs.Tokens"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.Visit(System.Linq.Expressions.Expression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitConditionalAsIfElse(System.Linq.Expressions.ConditionalExpression)">
            <summary>
            Visit a conditional expression, but print it as an if/else block instead of a ternary.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitExtension(System.Linq.Expressions.Expression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitArguments(System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.Expression},System.Reflection.ParameterInfo[],System.Boolean)">
            <summary>
            Print an argument list.
            </summary>
            <param name="args">Arguments to print</param>
            <param name="asParams">True if the argument types should be included</param>
            <param name="parens">True if should be wrapped in parentheses</param>
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitTypedParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Display a parameter and its type, eg. as 'int myInt'.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:BagoumLib.Expressions.PrintVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <inheritdoc />
        </member>
        <member name="T:BagoumLib.Expressions.ITypePrinter">
            <summary>
            An interface that prints a type into a string.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.ITypePrinter.Print(System.Type)">
            <summary>
            Print a type.
            </summary>
        </member>
        <member name="T:BagoumLib.Expressions.CSharpTypePrinter">
            <summary>
            Tries really hard to convert a type to its C# representation, eg. "int[]" or "Func&lt;bool, string&gt;".
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.CSharpTypePrinter.Default">
            <summary>
            Default printer with <see cref="P:BagoumLib.Expressions.CSharpTypePrinter.UseSimpleTypeNames"/> = true, <see cref="P:BagoumLib.Expressions.CSharpTypePrinter.PrintTypeNamespace"/> = false.
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.CSharpTypePrinter.UseSimpleTypeNames">
            <summary>
            If true, will represent simple system types like int/Int32 as "int" instead of "System.Int32".
            </summary>
        </member>
        <member name="P:BagoumLib.Expressions.CSharpTypePrinter.PrintTypeNamespace">
            <summary>
            Whether or not to print the namespace of types.
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.CSharpTypePrinter.tupleTypes">
            <summary>
            The non-empty tuple types ordered by arity.
            </summary>
        </member>
        <member name="F:BagoumLib.Expressions.CSharpTypePrinter.SimpleTypeNameMap">
            <summary>
            Map of simple types, such as int/Int32, to their simple names, such as "int"
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.CSharpTypePrinter.Print(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Expressions.VisitorHelpers">
            <summary>
            Helpers for expression visitors.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.VisitorHelpers.IsBlockishExpression(System.Linq.Expressions.Expression)">
            <summary>
            Return true if this expression does not have a value in C# source code
            (block expressions, void-typed conditional expressions, try expressions, switch expressions).
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.VisitorHelpers.ParameterByRefPrefix(System.Reflection.ParameterInfo)">
            <summary>
            Return the in/out/ref prefix for a by-ref parameter.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.VisitorHelpers.NameTypeInWords(System.Type)">
            <summary>
            Converts a type into a camel-case representation with no symbols.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.VisitorHelpers.IsChecked(System.Linq.Expressions.ExpressionType)">
            <summary>
            Return true if this operator is a checked arithmetic operator.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.VisitorHelpers.IsAssign(System.Linq.Expressions.ExpressionType)">
            <summary>
            Return true if this operator is an assignment-type operator.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.VisitorHelpers.BinaryOperatorString(System.Linq.Expressions.ExpressionType)">
            <summary>
            Convert a binary operator into its infix source code representation.
            </summary>
        </member>
        <member name="M:BagoumLib.Expressions.VisitorHelpers.UnaryOperatorString(System.Linq.Expressions.ExpressionType,System.Type)">
            <summary>
            Convert a unary operator into its source code representation.
             Return Either.Left if the operator is on the left side, or Either.Right if the operator is on the right side.
            </summary>
        </member>
        <member name="T:BagoumLib.Extensions">
            <summary>
            Static class providing extensions
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.CountOf(System.String,System.Char)">
            <summary>
            Return the number of occurrences of the character c in string s.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.TryIndex(System.String,System.Int32)">
            <summary>
            Try to get the character at index ii.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.TryIndex(System.String,System.Int32,System.Char@)">
            <summary>
            Try to get the character at index ii.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.FirstToUpper(System.String)">
            <summary>
            Return the string with the first character capitalized.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.ToLiteral(System.String)">
            <summary>
            Convert a string into a string literal, eg. by converting newlines to explicit '\n',
             converting hex characters to \u sequences, etc.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.Or(System.String,System.String)">
            <summary>
            If x is null or empty, return y. Else return x.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.SubscribeOnce``1(System.IObservable{``0},System.Action{``0})">
            <summary>
            Subscribe to an event, but dispose the token after it is triggered once.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.DisposeAll(System.Collections.Generic.List{System.IDisposable})">
            <summary>
            Dispose all <see cref="T:System.IDisposable"/> in a list.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.Map``2(BagoumLib.Events.IBObservable{``0},System.Func{``0,``1})">
            <summary>
            Functor map over <see cref="T:System.IObservable`1"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.Map``2(BagoumLib.Events.ICObservable{``0},System.Func{``0,``1})">
            <summary>
            Functor map over <see cref="T:BagoumLib.Events.ICObservable`1"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.CrossProduct``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>
            Get the cross product of elements from the first stream and second stream.
            <br/>This will include pairs where the first element occurs after the second element,
             unlike the behavior of ae.SelectMany(_ => be, (a, b) => (a, b)).
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.Apply``2(System.IObservable{System.Func{``0,``1}},System.IObservable{``0})">
            <summary>
            Applicative apply over IObservable. This will compute the cross product of values,
             unlike the naive definition `from f in fe from x in xe select f(x)`, which
             does not pull tuples where f occurs after x.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.Bind``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>
            Monadic bind over <see cref="T:System.IObservable`1"/>. Note this leaves hanging disposables.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.BindSubscribe``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.Action{``1})">
            <summary>
            Performs a monadic bind over <see cref="T:System.IObservable`1"/> and then subscribes to the constructed event.
            Collects all generated <see cref="T:System.IDisposable"/> tokens together, so that when the returned token is disposed,
             the constructed event is also disposed.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.SqrMagnitude(System.Numerics.Complex)">
            <summary>
            Returns the square magnitude of a complex number.
            </summary>
        </member>
        <member name="M:BagoumLib.Extensions.Freeze``1(``0)">
            <summary>
            Create a delegate that returns a value.
            </summary>
        </member>
        <member name="T:BagoumLib.ArrayExtensions">
            <summary>
            Static class providing array extensions
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.Insert``1(``0[],System.Int32@,``0,System.Int32)">
            <summary>
            Insert an element into an array, shifting all existing elements starting at the given index right by one.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.Extend``1(``0[],``0[])">
            <summary>
            Join two arrays.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.ModIndex``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Index into an array, but loop around to the start if the index is out of bounds.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.Try``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Try to get the object at the given index.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.TryN``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Try to get the object at the given index.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.Try``1(``0[],System.Int32,``0@)">
            <summary>
            Try to get the object at the given index.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.Try``1(``0[],System.Int32,``0)">
            <summary>
            Get the object at the given index, or return the default value.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.IndexOf``1(``0[],``0)">
            <summary>
            Get the index of the given object, or return -1 if not found.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.GetBounded``1(System.ValueTuple{System.Int32,``0}[],System.Int32)">
            <summary>
            Returns the first T such that the associated priority is LEQ the given priority.
            Make sure the array is sorted from lowest to highest priority.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.GetAtPriority``1(System.ValueTuple{System.Int32,``0}[],System.Int32)">
            <summary>
            Returns the first T such that the associated priority is EQUAL TO the given priority.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.SelectInPlace``1(``0[],System.Func{``0,``0})">
            <summary>
            Update each element of an array in-place using the mapping function.
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.SelectInPlace``1(``0[],System.Func{``0,System.Int32,``0})">
            <inheritdoc cref="M:BagoumLib.ArrayExtensions.SelectInPlace``1(``0[],System.Func{``0,``0})"/>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.SelectToArr``2(``0[],System.Func{``0,``1})">
            <summary>
            = arr.Select(map).ToArray()
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.SelectToArr``2(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,``1})">
            <summary>
            = arr.Select(map).ToArray()
            </summary>
        </member>
        <member name="M:BagoumLib.ArrayExtensions.SelectToList``2(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,``1})">
            <summary>
            = arr.Select(map).ToLis()
            </summary>
        </member>
        <member name="T:BagoumLib.IUnrollable`1">
            <summary>
            An object which has a sequence of values, some of which may themselves be
             objects with sequences of values.
            <br/>See <see cref="M:BagoumLib.IEnumExtensions.Unroll``1(System.Collections.Generic.IEnumerable{``0})"/>
            </summary>
        </member>
        <member name="P:BagoumLib.IUnrollable`1.Values">
            <summary>
            Values
            </summary>
        </member>
        <member name="T:BagoumLib.IEnumExtensions">
            <summary>
            Static class providing extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.TryGetAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Try to get the element at the given index in the enumerable.
            <br/>If the enumerable is too short, return Maybe.None.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.PairSuccessive``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Get successive elements of an enumerable.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.AppendIfNonnull``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Return `arr.Append(next)` if next is nnonnull. Otherwise, return `arr`.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.AppendIfNonnull``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{``0})">
            <summary>
            Return `arr.Append(next)` if next is nnonnull. Otherwise, return `arr`.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.Enumerate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get the index and element of each element in the enumerable.
            <br/>Similar to python enumerate
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.SelectDisposable``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.IDisposable})">
            <summary>
            Generate an <see cref="T:System.IDisposable"/> from each entry in a list, then join them into a single disposable.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.Unroll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            If an element is an <see cref="T:BagoumLib.IUnrollable`1"/>, then unroll it and yield all its unrolled elements.
            Otherwise, yield the element.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.Range(System.Int32)">
            <summary>
            Returns the range [0, max)
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.Range(System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Returns the range [min, max)
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.Step(System.ValueTuple{System.Double,System.Double},System.Double)">
            <summary>
            Returns the range [min, max) with the provided step
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.SelectNotNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Maps over each element, and only returns the non-null ones.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.SelectNotNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Maps over each element, and only returns the non-null ones.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Get the index of the first object satisfying the predicate, or -1 if none is found.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <inheritdoc cref="M:BagoumLib.ArrayExtensions.IndexOf``1(``0[],``0)"/>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.FirstOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return the first element of an enumerable, or null if it is empty.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.CastFilter``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Filter to include only the elements of `arr` that are of type `U`.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.FilterNone``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>
            Filter out null elements.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.FilterNone``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Filter out null elements.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.FilterMaybe``1(System.Collections.Generic.IEnumerable{BagoumLib.Functional.Maybe{``0}})">
            <summary>
            Filter out null elements.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.Items``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Enumerate over all key-value pairs in the dictionary.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.GroupToArray``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}})">
            <summary>
            Simplify groupings into (key, values) pairs.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.MaxByGroupSize``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}})">
            <summary>
            Get the grouping with the largest value set.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Get the maximum element according to the given selector.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.MaxByWith``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Get the maximum element according to the given selector, then return
             both the element and its selected value.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.SoftSkip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Skip the first SKIP elements of the enumerable.
            If there are fewer than SKIP elements, then return an empty enumerable instead of throwing.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.Join``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Flatten a once-nested enumerable.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.ToDict``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>
            Convert key-value pairs into a dictionary.
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.SeparateBy``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},``0)">
            <summary>
            Separate the given enumerables by a separator.
            <br/>eg. SeparateBy({1,2,3}, {4,5,6}, {7,8,9}, 0) = {1,2,3,0,4,5,6,0,7,8,9}
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.MaxConsecutive``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Get the maximum number of consecutive occurences of the given object. 
            </summary>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.WaitForCompletion``1(System.IObservable{``0})">
            <summary>
            Get a task that is set to true when the observable is completed.
            </summary>
            <param name="src"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BagoumLib.IEnumExtensions.WithSubscribe``2(``0,System.IObserver{``1},System.IDisposable@)">
            <summary>
            Calls `src.Subscribe` and returns `src`.
            </summary>
        </member>
        <member name="T:BagoumLib.ListExtensions">
            <summary>
            Static class providing extensions for <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.Cleared``1(System.Collections.Generic.List{``0})">
            <summary>
            Clear the list and return it.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.Added``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Add an element to a list and return it.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.Pop``1(System.Collections.Generic.List{``0})">
            <summary>
            Remove and return the last element of a list.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.SelectInPlace``1(System.Collections.Generic.List{``0},System.Func{``0,``0})">
            <summary>
            Update each element of a list in-place using the mapping function.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.IsSubsetOf``1(System.Collections.Generic.IReadOnlyList{``0},System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
            Returns true iff every item in `subset` is contained within `other`.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.ElementWiseHashCode``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
            Get a hash code based only on the elements of the list.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.AreSame``1(System.Collections.Generic.IReadOnlyList{``0},System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
            Returns true if the lists contains the same elements.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.AssignOrExtend``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0}@)">
            <summary>
            Add elements from <paramref name="from"/> into <paramref name="into"/> if <paramref name="into"/> exists,
             otherwise assign <paramref name="from"/> to <paramref name="into"/>.
            </summary>
            <param name="from"></param>
            <param name="into"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BagoumLib.ListExtensions.IncrLoop``1(System.Collections.Generic.List{``0},System.Int32@)">
            <summary>
            Add 1 to idx, but reset it to zero if it is larger than the list length.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.DecrLoop``1(System.Collections.Generic.List{``0},System.Int32@)">
            <summary>
            Subtract 1 from idx, but reset it to ^1 if it is less than zero.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.IncrLoop(System.Int32,System.Int32@)">
            <summary>
            Add 1 to idx, but reset it to zero if it is larger than mod.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.DecrLoop(System.Int32,System.Int32@)">
            <summary>
            Subtract 1 from idx, but reset it to mod-1 if it is less than zero.
            </summary>
        </member>
        <member name="M:BagoumLib.ListExtensions.AddNonNull``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Add `x` to the list if it is not null, and return the list.
            </summary>
        </member>
        <member name="T:BagoumLib.DictExtensions">
            <summary>
            Static class providing extensions for dictionaries
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.CopyInto``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Copy all key/value pairs from `src` into `target`.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.GetOrThrow``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Get the element at the given key, or throw an exception explicitly mentioning the key.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.GetOrThrow``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,System.String)">
            <summary>
            Get the element at the given key, or throw an exception explicitly mentioning the key and the dictionary name.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.MaybeGet``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)">
            <summary>
            Try to get the element at the given key.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.AddToList``2(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.List{``1}},``0,``1)">
            <summary>
            For a dictionary whose values are lists, add an element to the list associated with the given key,
             or create a new list if none are yet associated.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.Has2``3(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.Dictionary{``1,``2}},``0,``1)">
            <summary>
            For a nested dictionary, returns true iff dict[key1][key2] exists.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.Add2``3(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.Dictionary{``1,``2}},``0,``1,``2)">
            <summary>
            For a nested dictionary, set dict[key1][key2] = val. Creates dict[key1] if it does not exist.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.AddToList2``3(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.Dictionary{``1,System.Collections.Generic.List{``2}}},``0,``1,``2)">
            <summary>
            For a nested dictionary whose values are lists, add an element to the list associated with the given key pair,
             or create a new list if none are yet associated.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.TryGet2``3(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.Dictionary{``1,``2}},``0,``1,``2@)">
            <summary>
            For a nested dictionary, try to get the value at dict[key1][key2].
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.SetDefault``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Get the value at the given key, or create a new value.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.SetDefault``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            Get the value at the given key, or create a new value.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.GetOrNull``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Get the value associated with a key, or return null.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.Push``2(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.Stack{``1}},``0,``1)">
            <summary>
            Push a value onto the stack mapped to the provided key.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.Pop``2(System.Collections.Generic.Dictionary{``0,System.Collections.Generic.Stack{``1}},``0)">
            <summary>
            Pop a value from the stack mapped to the provided key. Clear the key if the stack becomes empty.
            </summary>
        </member>
        <member name="M:BagoumLib.DictExtensions.SearchByType``1(System.Collections.Generic.Dictionary{System.Type,``0},System.Object,System.Boolean)">
            <summary>
            Get the value `V` associated with the type that most accurately defines `obj`, in the order:
            <br/>- obj.GetType()
            <br/>- interfaces
            <br/>- base types
            </summary>
        </member>
        <member name="T:BagoumLib.NullableExtensions">
            <summary>
            Static class providing extensions for nullable types
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.And(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Returns x &amp;&amp; y (or null if x is null).
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.Or(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Returns x || y (or null if x is null).
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.FMap``2(System.Nullable{``0},System.Func{``0,``1})">
            <summary>
            Functor map over nullable structs.
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.OptFMap``2(``0,System.Func{``0,``1})">
            <summary>
            Functor map over nullable class types.
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.Bind``2(System.Nullable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Monadic bind over nullable structs
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.Try``1(System.Nullable{``0},``0@)">
            <summary>
            Try to get the value of a nullable struct.
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.AsMaybe``1(System.Nullable{``0})">
            <summary>
            Isomorphic transformation between nullable struct and <see cref="T:BagoumLib.Functional.Maybe`1"/>
            </summary>
        </member>
        <member name="M:BagoumLib.NullableExtensions.Try``1(``0,``0@)">
            <summary>
            Try to get the value of a nullable reference type.
            </summary>
        </member>
        <member name="T:BagoumLib.DataStructureExtensions">
            <summary>
            Static class providing extensions for miscellaneous data structures
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructureExtensions.TryPeek``1(System.Collections.Generic.Stack{``0})">
            <summary>
            Try to get the top element in a stack.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructureExtensions.TryPeek``1(BagoumLib.DataStructures.StackList{``0})">
            <summary>
            Try to get the top element in a <see cref="T:BagoumLib.DataStructures.StackList`1"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.DataStructureExtensions.WithPush``1(System.Collections.Generic.Stack{``0},``0)">
            <summary>
            Push an entry to a stack, and return a disposable that pops it.
            </summary>
        </member>
        <member name="T:BagoumLib.EventExtensions">
            <summary>
            Static class providing extensions for events
            </summary>
        </member>
        <member name="M:BagoumLib.EventExtensions.Finalize``1(System.IObserver{``0},``0)">
            <summary>
            Run `ev.OnNext` and then `ev.OnCompleted`.
            </summary>
        </member>
        <member name="M:BagoumLib.EventExtensions.Erase``1(BagoumLib.Events.IBObservable{``0})">
            <summary>
            Get an <see cref="T:System.IObservable`1"/> that is triggered when the source event is triggered,
             but does not carry its value.
            </summary>
        </member>
        <member name="M:BagoumLib.EventExtensions.Select``2(BagoumLib.Events.ICObservable{``0},System.Func{``0,``1})">
            <summary>
            Create an <see cref="T:BagoumLib.Events.Evented`2"/> that maps the source values into another type.
            </summary>
        </member>
        <member name="T:BagoumLib.FuncExtensions">
            <summary>
            Static class providing extensions for actions/funcs.
            </summary>
        </member>
        <member name="M:BagoumLib.FuncExtensions.AsFunc``2(``1,System.Action{``0})">
            <summary>
            Create a Func that calls the `preceding` Action and then returns `result`.
            </summary>
        </member>
        <member name="M:BagoumLib.FuncExtensions.Or(System.Func{System.Boolean},System.Func{System.Boolean})">
            <summary>
            Create a Func that returns true if either argument returns true.
            </summary>
        </member>
        <member name="M:BagoumLib.FuncExtensions.Use``2(``0,System.Func{``0,``1})">
            <summary>
            Provide the first value as an argument to the Func.
            </summary>
        </member>
        <member name="M:BagoumLib.FuncExtensions.Then(System.Action,System.Action)">
            <summary>
            Return an action that execute two actions in sequence.
            </summary>
        </member>
        <member name="M:BagoumLib.FuncExtensions.Then``1(System.Action{``0},System.Action{``0})">
            <inheritdoc cref="M:BagoumLib.FuncExtensions.Then(System.Action,System.Action)"/>
        </member>
        <member name="M:BagoumLib.FuncExtensions.Then``2(System.Action{``0,``1},System.Action{``0,``1})">
            <inheritdoc cref="M:BagoumLib.FuncExtensions.Then(System.Action,System.Action)"/>
        </member>
        <member name="T:BagoumLib.Functional.Delayed`1">
            <summary>
            A value, or a delayed value.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Delayed`1.ConcreteValue">
            <summary>
            A concrete value. Only valid if <see cref="P:BagoumLib.Functional.Delayed`1.IsConcrete"/> is true.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Delayed`1.DelayedValue">
            <summary>
            A delayed value. Only valid if <see cref="P:BagoumLib.Functional.Delayed`1.IsConcrete"/> is false.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Delayed`1.IsConcrete">
            <summary>
            True iff this struct is represented by a concrete value.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Delayed`1.Value">
            <summary>
            Retrieves the concrete value (if provided), else realizes the delayed value.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Delayed`1.#ctor(`0)">
            <summary>
            Create a Delayed struct from a concrete value.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Delayed`1.#ctor(System.Func{`0})">
            <summary>
            Create a Delayed struct from a delayed value.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Delayed`1.FMap``1(System.Func{`0,``0})">
            <summary>
            Functor map over delayed values.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Delayed`1.op_Implicit(`0)~BagoumLib.Functional.Delayed{`0}">
            <summary>
            Create a Delayed struct from a concrete value.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Delayed`1.op_Implicit(System.Func{`0})~BagoumLib.Functional.Delayed{`0}">
            <summary>
            Create a Delayed struct from a delayed value.
            </summary>
        </member>
        <member name="T:BagoumLib.Functional.Either`2">
            <summary>
            A value that is either of type L (left) or of type R (right).
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.Left">
            <summary>
            The left-value of this type. Only valid if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is true.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.Right">
            <summary>
            The right-value of this type. Only valid if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is false.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.IsLeft">
            <summary>
            True iff the value is of type L.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.IsRight">
            <summary>
            !<see cref="P:BagoumLib.Functional.Either`2.IsLeft"/>
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.LeftOrNull">
            <summary>
            <see cref="P:BagoumLib.Functional.Either`2.Left"/> if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is true, else a default value.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.LeftOrThrow">
            <summary>
            <see cref="P:BagoumLib.Functional.Either`2.Left"/> if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is true, else throw.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.RightOrNull">
            <summary>
            <see cref="P:BagoumLib.Functional.Either`2.Right"/> if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is false, else a default value.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Either`2.RightOrThrow">
            <summary>
            <see cref="P:BagoumLib.Functional.Either`2.Right"/> if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is false, else throw.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.#ctor(System.Boolean,`0,`1)">
            <summary>
            Create a new <see cref="T:BagoumLib.Functional.Either`2"/> container.
            </summary>
            <param name="isLeft">True iff the left value is valid, false iff the right value is valid.</param>
            <param name="left">A left value.</param>
            <param name="right">A right value.</param>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.#ctor(`0)">
            <summary>
            Create a left-<see cref="T:BagoumLib.Functional.Either`2"/>.
            </summary>
            <param name="left">Left value.</param>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.#ctor(`1)">
            <summary>
            Create a right-<see cref="T:BagoumLib.Functional.Either`2"/>.
            </summary>
            <param name="right">Right value.</param>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.TryL(`0@)">
            <summary>
            Get the left value if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is true.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.TryR(`1@)">
            <summary>
            Get the right value if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is false.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.Map``1(System.Func{`0,``0},System.Func{`1,``0})">
            <summary>
            Get a value T by applying the left function to the left value if <see cref="P:BagoumLib.Functional.Either`2.IsLeft"/> is true,
            otherwise applying the right function to the right value.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.FMapL``1(System.Func{`0,``0})">
            <summary>
            Functor map for type-constructor Either * R.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.FMapR``1(System.Func{`1,``0})">
            <summary>
            Functor map for type-constructor Either L *.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.BindL``1(System.Func{`0,BagoumLib.Functional.Either{``0,`1}})">
            <summary>
            Monadic bind for type-constructor Either * R.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.BindR``1(System.Func{`1,BagoumLib.Functional.Either{`0,``0}})">
            <summary>
            Monadic bind for type-constructor Either L *.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.ApplyL``1(BagoumLib.Functional.Either{System.Func{`0,``0},`1}@)">
            <summary>
            Applicative apply for type-constructor Either * R.
            <br/>x.Apply(f) = apply f x
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.ApplyR``1(BagoumLib.Functional.Either{`0,System.Func{`1,``0}}@)">
            <summary>
            Applicative apply for type-constructor Either L *.
            <br/>x.Apply(f) = apply f x
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.Equals(BagoumLib.Functional.Either{`0,`1})">
            <summary>
            Equality operator. Tests that both objects have the same left/right orientation, and that their valid values are the same.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.op_Equality(BagoumLib.Functional.Either{`0,`1}@,BagoumLib.Functional.Either{`0,`1}@)">
            <inheritdoc cref="M:BagoumLib.Functional.Either`2.Equals(BagoumLib.Functional.Either{`0,`1})"/>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.op_Inequality(BagoumLib.Functional.Either{`0,`1}@,BagoumLib.Functional.Either{`0,`1}@)">
            <summary>
            Inverted equality operator.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.op_Implicit(`0)~BagoumLib.Functional.Either{`0,`1}">
            <inheritdoc cref="M:BagoumLib.Functional.Either`2.#ctor(`0)"/>
        </member>
        <member name="M:BagoumLib.Functional.Either`2.op_Implicit(`1)~BagoumLib.Functional.Either{`0,`1}">
            <inheritdoc cref="M:BagoumLib.Functional.Either`2.#ctor(`1)"/>
        </member>
        <member name="T:BagoumLib.Functional.Helpers">
            <summary>
            Helpers and extensions for functional types.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.Resolve``1(BagoumLib.Functional.Either{``0,System.Func{``0}})">
            <summary>
            If the Either is a value (left), return it. If the Either is a delayed value (right), resolve it.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.LeftOrRight``3(BagoumLib.Functional.Either{``0,``1})">
            <summary>
            When both sides of an Either derive from a base type, return the left or right value as the base type.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.ValueOrSNull``1(BagoumLib.Functional.Maybe{``0})">
            <summary>
            Get the value if it is present, otherwise get null.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.ValueOrNull``1(BagoumLib.Functional.Maybe{``0})">
            <summary>
            Get the value if it is present, otherwise get null.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.SequenceL``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,BagoumLib.Functional.Either{``1,``2}})">
            <summary>
            Accumulate many results of a selection over a failable function together.
            If at least one Either is Right, then the result will short-circuit and return that Right.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.SequenceL``2(System.Collections.Generic.IEnumerable{BagoumLib.Functional.Either{``0,``1}})">
            <summary>
            Accumulate many Eithers together.
            If at least one Either is Right, then the result will short-circuit and return that Right.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.AccFailToR``2(System.Collections.Generic.IEnumerable{BagoumLib.Functional.Either{``0,``1}})">
            <summary>
            Accumulate many Eithers together.
            If at least one Either is Right, then the result will be Right.
            Else the result will be a Left (including in the case when no arguments are provided.)
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.AccFailToR``2(System.Collections.Generic.IEnumerable{BagoumLib.Functional.Either{``0,System.Collections.Generic.List{``1}}})">
            <summary>
            Accumulate many Eithers together.
            If at least one Either is Right, then the result will be Right.
            Else the result will be a Left (including in the case when no arguments are provided.)
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.Select``2(BagoumLib.Functional.Maybe{``0},System.Func{``0,``1})">
            <summary>
            Alias for <see cref="M:BagoumLib.Functional.Maybe`1.FMap``1(System.Func{`0,``0})"/> for LINQ compatibility.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.SelectMany``3(BagoumLib.Functional.Maybe{``0},System.Func{``0,BagoumLib.Functional.Maybe{``1}},System.Func{``0,``1,``2})">
            <summary>
            LINQ implementation for SelectMany.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Helpers.ReplaceEntries``1(System.Boolean,System.Collections.Generic.List{``0},System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <summary>
            Replace entries in `replaceIn` when they pass `replaceFilter` with entries in `replaceFrom`.
            If `allowFewer` is true, then won't replace arguments if there are no more entries in `replaceFrom`.
            All replacements must be consumed.
            </summary>
        </member>
        <member name="T:BagoumLib.Functional.Maybe`1">
            <summary>
            A value of type T that may or may not exist.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Maybe`1.Value">
            <summary>
            The underlying value. Undefined if <see cref="P:BagoumLib.Functional.Maybe`1.Valid"/> is false.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.Maybe`1.Valid">
            <summary>
            True iff the value exists.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.#ctor(System.Boolean,`0)">
            <summary>
            Create a <see cref="T:BagoumLib.Functional.Maybe`1"/>.
            </summary>
            <param name="valid">True iff the value is present.</param>
            <param name="value">The underlying value.</param>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.#ctor(`0)">
            <summary>
            Create a <see cref="T:BagoumLib.Functional.Maybe`1"/> with a value that exists.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.Of(`0)">
            <summary>
            Create a <see cref="T:BagoumLib.Functional.Maybe`1"/> with a value that exists.
            </summary>
        </member>
        <member name="F:BagoumLib.Functional.Maybe`1.None">
            <summary>
            Create a <see cref="T:BagoumLib.Functional.Maybe`1"/> representing no existing value.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.FMap``1(System.Func{`0,``0})">
            <summary>
            Functor map.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.RApply``1(BagoumLib.Functional.Maybe{System.Func{`0,``0}})">
            <summary>
            Applicative apply.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.Bind``1(System.Func{`0,BagoumLib.Functional.Maybe{``0}})">
            <summary>
            Monadic bind.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.Or(`0)">
            <summary>
            Get the underlying value if it exists, otherwise return dflt.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.Try(`0@)">
            <summary>
            Get the underlying value if it exists.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.Equals(BagoumLib.Functional.Maybe{`0})">
            <summary>
            Equality operator. Checks that either both maybes are valid and contain the same underlying value,
            or that they are both invalid.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.op_Equality(BagoumLib.Functional.Maybe{`0},BagoumLib.Functional.Maybe{`0})">
            <inheritdoc cref="M:BagoumLib.Functional.Maybe`1.Equals(BagoumLib.Functional.Maybe{`0})"/>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.op_Inequality(BagoumLib.Functional.Maybe{`0},BagoumLib.Functional.Maybe{`0})">
            <summary>
            Inequality operator.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.Maybe`1.op_Implicit(`0)~BagoumLib.Functional.Maybe{`0}">
            <inheritdoc cref="M:BagoumLib.Functional.Maybe`1.Of(`0)"/>
        </member>
        <member name="T:BagoumLib.Functional.OneOf`3">
            <summary>
            A value that is one of three possible types.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.OneOf`3.ValA">
            <summary>
            The A-value of this type. Only valid if <see cref="P:BagoumLib.Functional.OneOf`3.IsA"/> is true.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.OneOf`3.ValB">
            <summary>
            The B-value of this type. Only valid if <see cref="P:BagoumLib.Functional.OneOf`3.IsB"/> is true.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.OneOf`3.ValC">
            <summary>
            The C-value of this type. Only valid if <see cref="P:BagoumLib.Functional.OneOf`3.IsC"/> is true.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.OneOf`3.Index">
            <summary>
            The index of the correct type (0=A, 1=B, 2=C).
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.OneOf`3.IsA">
            <summary>
            True iff the value is of type A.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.OneOf`3.IsB">
            <summary>
            True iff the value is of type B.
            </summary>
        </member>
        <member name="P:BagoumLib.Functional.OneOf`3.IsC">
            <summary>
            True iff the value is of type C.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.#ctor(`0)">
            <summary>
            Create a <see cref="T:BagoumLib.Functional.OneOf`3"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.#ctor(`1)">
            <summary>
            Create a <see cref="T:BagoumLib.Functional.OneOf`3"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.#ctor(`2)">
            <summary>
            Create a <see cref="T:BagoumLib.Functional.OneOf`3"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.Equals(BagoumLib.Functional.OneOf{`0,`1,`2})">
            <summary>
            Equality operator. Tests that both objects have the same left/right orientation, and that their valid values are the same.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.op_Equality(BagoumLib.Functional.OneOf{`0,`1,`2}@,BagoumLib.Functional.OneOf{`0,`1,`2}@)">
            <inheritdoc cref="M:BagoumLib.Functional.OneOf`3.Equals(BagoumLib.Functional.OneOf{`0,`1,`2})"/>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.op_Inequality(BagoumLib.Functional.OneOf{`0,`1,`2}@,BagoumLib.Functional.OneOf{`0,`1,`2}@)">
            <summary>
            Inverted equality operator.
            </summary>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.ToString">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.op_Implicit(`0)~BagoumLib.Functional.OneOf{`0,`1,`2}">
            <inheritdoc cref="M:BagoumLib.Functional.OneOf`3.#ctor(`0)"/>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.op_Implicit(`1)~BagoumLib.Functional.OneOf{`0,`1,`2}">
            <inheritdoc cref="M:BagoumLib.Functional.OneOf`3.#ctor(`1)"/>
        </member>
        <member name="M:BagoumLib.Functional.OneOf`3.op_Implicit(`2)~BagoumLib.Functional.OneOf{`0,`1,`2}">
            <inheritdoc cref="M:BagoumLib.Functional.OneOf`3.#ctor(`2)"/>
        </member>
        <member name="T:BagoumLib.LogLevel">
            <summary>
            Logging levels for <see cref="T:BagoumLib.Logging"/>.
            </summary>
        </member>
        <member name="F:BagoumLib.LogLevel.DEBUG1">
            <summary>
            Lowest-priority debug level
            </summary>
        </member>
        <member name="F:BagoumLib.LogLevel.DEBUG2">
            <summary>
            Second-lowest-priority debug level
            </summary>
        </member>
        <member name="F:BagoumLib.LogLevel.DEBUG3">
            <summary>
            Second-highest-priority debug level
            </summary>
        </member>
        <member name="F:BagoumLib.LogLevel.DEBUG4">
            <summary>
            Highest-priority debug level
            </summary>
        </member>
        <member name="F:BagoumLib.LogLevel.INFO">
            <summary>
            Informational logs (default level)
            </summary>
        </member>
        <member name="F:BagoumLib.LogLevel.WARNING">
            <summary>
            Warnings
            </summary>
        </member>
        <member name="F:BagoumLib.LogLevel.ERROR">
            <summary>
            Errors/exceptions
            </summary>
        </member>
        <member name="T:BagoumLib.LogMessage">
            <summary>
            A compiled log message that can be read by log listeners.
            </summary>
        </member>
        <member name="P:BagoumLib.LogMessage.Message">
            <summary>
            The log message.
            </summary>
        </member>
        <member name="P:BagoumLib.LogMessage.ShowStackTrace">
            <summary>
            Whether or not the stack trace should be shown (null if the listener should determine automatically).
            </summary>
        </member>
        <member name="P:BagoumLib.LogMessage.Level">
            <summary>
            The severity of the message.
            </summary>
        </member>
        <member name="P:BagoumLib.LogMessage.Exception">
            <summary>
            An exception that may be associated with the message.
            </summary>
        </member>
        <member name="M:BagoumLib.LogMessage.#ctor(System.String,BagoumLib.LogLevel,System.Exception,System.Nullable{System.Boolean})">
            <inheritdoc cref="T:BagoumLib.LogMessage"/>
        </member>
        <member name="M:BagoumLib.LogMessage.Info(System.String,BagoumLib.LogLevel)">
            <summary>
            Create a <see cref="T:BagoumLib.LogMessage"/> with a default level of <see cref="F:BagoumLib.LogLevel.INFO"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.LogMessage.Warning(System.String)">
            <summary>
            Create a warning log.
            </summary>
        </member>
        <member name="M:BagoumLib.LogMessage.Error(System.Exception,System.String)">
            <summary>
            Create an error log.
            </summary>
        </member>
        <member name="M:BagoumLib.LogMessage.op_Implicit(System.String)~BagoumLib.LogMessage">
            <summary>
            Convert a string to an info log.
            </summary>
        </member>
        <member name="M:BagoumLib.LogMessage.op_Implicit(System.Exception)~BagoumLib.LogMessage">
            <summary>
            Convert an exception to an error log.
            </summary>
        </member>
        <member name="M:BagoumLib.LogMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Logging">
            <summary>
            A static class containing a singleton logger.
            </summary>
        </member>
        <member name="F:BagoumLib.Logging.Logs">
            <summary>
            Singleton logger.
            </summary>
        </member>
        <member name="M:BagoumLib.Logging.ToFileLink(System.String,System.Int32,System.String)">
            <summary>
            Create a file link (clickable in some IDEs) linking to a line in a specific file
            </summary>
            <param name="filename">Path to file</param>
            <param name="line">Line in file</param>
            <param name="content">Message to put in the link text (defaults to filename:line)</param>
            <returns></returns>
        </member>
        <member name="T:BagoumLib.LogStringFmt">
            <summary>
            Helper struct for printing format strings in logging.
            </summary>
        </member>
        <member name="M:BagoumLib.LogStringFmt.#ctor(System.String,System.Object[])">
            <inheritdoc cref="T:BagoumLib.LogStringFmt"/>
        </member>
        <member name="M:BagoumLib.LogStringFmt.Realize">
            <summary>
            Use string.Format to construct an output string.
            </summary>
        </member>
        <member name="T:BagoumLib.Logger">
            <summary>
            An entity that receives logging messages and dispatches them to multiple <see cref="T:BagoumLib.ILogListener"/>s.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.CanSkipMessage(BagoumLib.LogLevel,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Logger.RegisterListener(BagoumLib.ILogListener)">
            <summary>
            Register a listener to receive messages from this logger through the <see cref="T:System.IObserver`1"/> interface.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.Log(System.String,BagoumLib.LogLevel,System.Nullable{System.Boolean})">
            <summary>
            Log a message.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.Log(System.String,System.Object,BagoumLib.LogLevel,System.Nullable{System.Boolean})">
            <summary>
            Log a string-format message in one argument.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.Log(System.String,System.Object,System.Object,BagoumLib.LogLevel,System.Nullable{System.Boolean})">
            <summary>
            Log a string-format message in two arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.Log(System.String,System.Object,System.Object,System.Object,BagoumLib.LogLevel,System.Nullable{System.Boolean})">
            <summary>
            Log a string-format message in three arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.Log(BagoumLib.LogStringFmt,BagoumLib.LogLevel,System.Nullable{System.Boolean})">
            <summary>
            Log a string-format message in many arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.Warning(System.String,System.Nullable{System.Boolean})">
            <summary>
            Log a warning.
            </summary>
        </member>
        <member name="M:BagoumLib.Logger.Error(System.Exception,System.String)">
            <summary>
            Log an error.
            </summary>
        </member>
        <member name="T:BagoumLib.ILogListener">
            <summary>
            An entity that listens to published logging messages.
            </summary>
        </member>
        <member name="M:BagoumLib.ILogListener.CanSkipMessage(BagoumLib.LogLevel,System.Exception)">
            <summary>
            Returns true iff a message of a specified severity and exception will be no-oped by this listener.
            </summary>
        </member>
        <member name="T:BagoumLib.TrivialLogListener">
            <summary>
            A log listener that acts on any log messages, similar to using a callback as an IObserver.
            </summary>
        </member>
        <member name="M:BagoumLib.TrivialLogListener.#ctor(System.Action{BagoumLib.LogMessage})">
            <summary>
            A log listener that acts on any log messages, similar to using a callback as an IObserver.
            </summary>
        </member>
        <member name="M:BagoumLib.TrivialLogListener.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.TrivialLogListener.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.TrivialLogListener.OnNext(BagoumLib.LogMessage)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.TrivialLogListener.CanSkipMessage(BagoumLib.LogLevel,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Reflection.NamedParam">
            <summary>
            A simplified description of a method parameter.
            </summary>
            <param name="Type">Parameter type</param>
            <param name="Name">Parameter name</param>
        </member>
        <member name="M:BagoumLib.Reflection.NamedParam.#ctor(System.Type,System.String)">
            <summary>
            A simplified description of a method parameter.
            </summary>
            <param name="Type">Parameter type</param>
            <param name="Name">Parameter name</param>
        </member>
        <member name="P:BagoumLib.Reflection.NamedParam.Type">
            <summary>Parameter type</summary>
        </member>
        <member name="P:BagoumLib.Reflection.NamedParam.Name">
            <summary>Parameter name</summary>
        </member>
        <member name="M:BagoumLib.Reflection.NamedParam.op_Implicit(System.Reflection.ParameterInfo)~BagoumLib.Reflection.NamedParam">
            <summary>
            Implicit conversion of ParameterInfo to <see cref="T:BagoumLib.Reflection.NamedParam"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.NamedParam.AsParameter">
            <summary>
            Description of this type in the format "TYPE NAME", where TYPE is simplified.
            </summary>
        </member>
        <member name="T:BagoumLib.Reflection.ReflectionUtils">
            <summary>
            Helpers for reflection and type handling.
            </summary>
        </member>
        <member name="F:BagoumLib.Reflection.ReflectionUtils.FuncTypesByArity">
            <summary>
            The types Func{}, Func{,}, Func{,,}, etc.
            </summary>
        </member>
        <member name="F:BagoumLib.Reflection.ReflectionUtils.TupleTypesByArity">
            <summary>
            The types (), (,), (,,), etc.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.GetFuncType(System.Int32)">
            <summary>
            Get the func type typeof(Func&lt;,,,,...&gt;), where arity is the number of generic arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.GetActionType(System.Int32)">
            <summary>
            Get the action type typeof(Action&lt;,,,,...&gt;), where arity is the number of generic arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.MakeFuncType(System.Type[])">
            <summary>
            Make the func type typeof(Func&lt;A,B,C,...&gt;).
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.GetTupleType(System.Int32)">
            <summary>
            Get the func type typeof(ValueTuple&lt;,,,,...&gt;), where arity is the number of generic arguments.
            </summary>
            <param name="arity"></param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.RName(System.Type)">
            <summary>
            Alias for CSharpTypePrinter.Default.Print(t), which prints the type as close to the native
            C# description as possible without namespaces.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.SimpRName(System.Type)">
            <summary>
            Alias for CSharpTypePrinter.Default.Print(t), which simplifies the type according to runtime rules
             and then prints it type as close to the native C# description as possible without namespaces.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.IsWeakSubclassOf(System.Type,System.Type)">
            <summary>
            Returns true iff either t is equal to parent, or t is a strict subclass of parent.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.ConstructedGenericTypeMatch(System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type}@)">
            <summary>
            Check if a realized type (eg. List&lt;List&lt;int&gt;&gt;)
            and a generic type (eg. List&lt;List&lt;T&gt;&gt;, where T is a generic method type)
            match. If they do, also get a dictionary mapping each generic type to its realized type.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.MakeGeneric(System.Reflection.MethodInfo,System.Collections.Generic.Dictionary{System.Type,System.Type})">
            <summary>
            Create a concrete method from a generic method provided a dictionary mapping generic types to concrete types.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.ConstructedGenericTypeMatch(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Type,System.Type}},System.Collections.Generic.Dictionary{System.Type,System.Type}@)">
            <inheritdoc cref="M:BagoumLib.Reflection.ReflectionUtils.ConstructedGenericTypeMatch(System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type}@)"/>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.CreateInstance``1(System.Object[])">
            <summary>
            Create an instance of type T using its constructor.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.PropertyInfo(System.Type,System.String,System.Boolean)">
            <summary>
            Find a property.
            </summary>
            <param name="t">Type containing the property</param>
            <param name="prop">Property name</param>
            <param name="instance">True if this is an instance property</param>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.FieldInfo(System.Type,System.String,System.Boolean)">
            <summary>
            Find a field.
            </summary>
            <param name="t">Type containing the field</param>
            <param name="field">Field name</param>
            <param name="instance">True if this is an instance field</param>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils._Property``1(System.Object,System.String)">
            <summary>
            Get the value of a property by name.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils._StaticProperty``1(System.Type,System.String)">
            <summary>
            Get the value of a static property by name.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils._Field``1(System.Object,System.String)">
            <summary>
            Get the value of a field by name.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils._StaticField``1(System.Type,System.String)">
            <summary>
            Get the value of a static field by name.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.ReflectionUtils.GetEnumVals``1">
            <summary>
            Get all the values of the enum `T`.
            </summary>
        </member>
        <member name="T:BagoumLib.Reflection.SimplifiedExprPrinter">
            <summary>
            Type printer allowing injection of type simplifiers before printing.
            </summary>
        </member>
        <member name="F:BagoumLib.Reflection.SimplifiedExprPrinter.Default">
            <summary>
            Default instance.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.SimplifiedExprPrinter.InjectSimplifier(System.Func{System.Type,System.Type})">
            <summary>
            Add a simplifier which will be used to recursively convert any type before printing it.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.SimplifiedExprPrinter.Print(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Reflection.TypeMember">
            <summary>
            Abstraction over class members (methods, constructors, fields, properties).
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Params">
            <summary>
            The parameters to this member. If this is an instance member (eg. string.Length), then the first
             element is the instance parameter.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.ReturnType">
            <summary>
            Return type of this member.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Static">
            <summary>
            Whether or not this member is static.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.BaseMi">
            <summary>
            The base <see cref="T:System.Reflection.MemberInfo"/> that this abstraction describes.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.TypeName">
            <summary>
            The simplified name of the type containing this member.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.GetAttribute``1">
            <summary>
            <see cref="P:BagoumLib.Reflection.TypeMember.BaseMi"/>.GetCustomAttribute
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.InvokeInst(System.Object,System.Object[])">
            <summary>
            Invoke this member. If this is an instance member, then `instance` must be provided as an instance
             on which to invoke the member; if this is a static member, then `instance` must be null.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Invoke(System.Object[])">
            <summary>
            Invoke this member. If this is an instance member, then the first element in `args` must be the instance.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.InvokeExInst(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <summary>
            Creates an expression representing the invocation of this member.
            If this is an instance member, then `instance` must be provided as an instance
             on which to invoke the member; if this is a static member, then `instance` must be null.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.InvokeEx(System.Linq.Expressions.Expression[])">
            <summary>
            Creates an expression representing the invocation of this member.
            If this is an instance member, then the first element in `args` must be the instance.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.TypeOnlySignature">
            <summary>
            The signature of this method without any parameter names.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.AsSignature(System.Func{BagoumLib.Reflection.NamedParam,System.Int32,System.String})">
            <summary>
            The signature of this method, where the representation of each parameter is defined by `paramMod`.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Make(System.Reflection.MemberInfo)">
            <summary>
            Create a <see cref="T:BagoumLib.Reflection.TypeMember"/> representing a <see cref="T:System.Reflection.MemberInfo"/>, or throw an exception.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.MakeWriteable(System.Reflection.MemberInfo)">
            <summary>
            Create a <see cref="T:BagoumLib.Reflection.TypeMember"/> representing a <see cref="T:System.Reflection.MemberInfo"/>
             that is a field or property, or throw an exception.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.MaybeMake(System.Reflection.MemberInfo)">
            <summary>
            Attempt to create a <see cref="T:BagoumLib.Reflection.TypeMember"/> representing a <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Reflection.TypeMember.Method">
            <summary>
            A <see cref="T:BagoumLib.Reflection.TypeMember"/> representing a class method.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Method.Mi">
            <inheritdoc cref="P:BagoumLib.Reflection.TypeMember.Method.BaseMi"/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Method.BaseMi">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Method.Params">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Method.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Method.Static">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Method.IsExtension">
            <summary>
            True iff this is an extension method.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Method.#ctor(System.Reflection.MethodInfo)">
            <inheritdoc cref="T:BagoumLib.Reflection.TypeMember.Method"/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Method.ParamsForMethod(System.Reflection.MethodInfo)">
            <summary>
            Converts the parameters of this method, including the instance if applicable, to
            an array of <see cref="T:BagoumLib.Reflection.NamedParam"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Method.InvokeInst(System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Method.InvokeExInst(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Method.TypeOnlySignature">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Method.AsSignature(System.Func{BagoumLib.Reflection.NamedParam,System.Int32,System.String})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Reflection.TypeMember.Constructor">
            <summary>
            A <see cref="T:BagoumLib.Reflection.TypeMember"/> representing a constructor.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Constructor.Cons">
            <inheritdoc cref="P:BagoumLib.Reflection.TypeMember.Constructor.BaseMi"/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Constructor.BaseMi">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Constructor.Params">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Constructor.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Constructor.Static">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Constructor.#ctor(System.Reflection.ConstructorInfo)">
            <inheritdoc cref="T:BagoumLib.Reflection.TypeMember.Constructor"/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Constructor.InvokeInst(System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Constructor.InvokeExInst(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Constructor.TypeOnlySignature">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Constructor.AsSignature(System.Func{BagoumLib.Reflection.NamedParam,System.Int32,System.String})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Reflection.TypeMember.Writeable">
            <summary>
            Base class for <see cref="T:BagoumLib.Reflection.TypeMember"/>s that are writeable (ie. fields and properties).
            </summary>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Writeable.SetInst(System.Object,System.Object,System.Object[])">
            <summary>
            Set the value of this member.
            If this is an instance member, then `instance` must be provided as an instance
             on which to invoke the member; if this is a static member, then `instance` must be null.
            </summary>
        </member>
        <member name="T:BagoumLib.Reflection.TypeMember.Property">
            <summary>
            A <see cref="T:BagoumLib.Reflection.TypeMember"/> representing a property.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Property.Prop">
            <inheritdoc cref="P:BagoumLib.Reflection.TypeMember.Property.BaseMi"/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Property.BaseMi">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Property.Params">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Property.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Property.Static">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Property.#ctor(System.Reflection.PropertyInfo)">
            <inheritdoc cref="T:BagoumLib.Reflection.TypeMember.Property"/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Property.InvokeInst(System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Property.SetInst(System.Object,System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Property.InvokeExInst(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Property.TypeOnlySignature">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Property.AsSignature(System.Func{BagoumLib.Reflection.NamedParam,System.Int32,System.String})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Reflection.TypeMember.Field">
            <summary>
            A <see cref="T:BagoumLib.Reflection.TypeMember"/> representing a field.
            </summary>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Field.Fi">
            <inheritdoc cref="P:BagoumLib.Reflection.TypeMember.Field.BaseMi"/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Field.BaseMi">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Field.Params">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Field.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Reflection.TypeMember.Field.Static">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Field.#ctor(System.Reflection.FieldInfo)">
            <inheritdoc cref="T:BagoumLib.Reflection.TypeMember.Field"/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Field.InvokeInst(System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Field.SetInst(System.Object,System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Field.InvokeExInst(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Field.TypeOnlySignature">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Reflection.TypeMember.Field.AsSignature(System.Func{BagoumLib.Reflection.NamedParam,System.Int32,System.String})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.ServiceLocator">
            <summary>
            A store that allows registering and locating services at runtime.
            </summary>
        </member>
        <member name="T:BagoumLib.ServiceLocator.ServiceOptions">
            <summary>
            Options configuring the usage of a specific service type that may be realized by multiple providers.
            </summary>
        </member>
        <member name="M:BagoumLib.ServiceLocator.ServiceOptions.#ctor">
            <summary>
            Options configuring the usage of a specific service type that may be realized by multiple providers.
            </summary>
        </member>
        <member name="P:BagoumLib.ServiceLocator.ServiceOptions.Unique">
            <summary>
            True iff at most one provider can realize the service at a time. Default false.
            </summary>
        </member>
        <member name="M:BagoumLib.ServiceLocator.Register``1(``0,System.Nullable{BagoumLib.ServiceLocator.ServiceOptions})">
            <summary>
            Register a service that can be reached globally via service location.
            <br/>The caller must dispose the disposable when the registered service is no longer available
             (eg. due to object deletion).
            <br/>TODO send alerts to consumers when the service is disposed
            </summary>
        </member>
        <member name="M:BagoumLib.ServiceLocator.FindOrNull``1">
            <summary>
            Find a service of type T, or return null.
            </summary>
        </member>
        <member name="M:BagoumLib.ServiceLocator.MaybeFind``1">
            <summary>
            Find a service of type T, or return null.
            </summary>
        </member>
        <member name="M:BagoumLib.ServiceLocator.FindAll``1">
            <summary>
            Find all services of type T. The returned array may be empty.
            </summary>
        </member>
        <member name="M:BagoumLib.ServiceLocator.Find``1">
            <summary>
            Find a service of type T, or throw an exception.
            </summary>
        </member>
        <member name="T:BagoumLib.SignalProcessing.IBand">
            <summary>
            A frequency band in a beat detector.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.IBand.Src">
            <summary>
            Beat detector containing this band.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.IBand.LowLimit">
            <summary>
            Lower frequency limit of the band.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.IBand.HighLimit">
            <summary>
            Higher frequency limit of the band.
            </summary>
        </member>
        <member name="T:BagoumLib.SignalProcessing.PowerBand">
            <summary>
            Data for a frequency band that reads instantaneous power data and smears/derivates it.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.PowerBand.LogPowerHistory">
            <summary>
            History of log-power signals. Note that the sampling rate of this stream is <see cref="P:BagoumLib.SignalProcessing.BeatDetector.PowerSampleRate"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.PowerBand.SmoothLogPowerHistory">
            <summary>
            History of log-power signals passed through a Hann filter.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.PowerBand.DerivativeHistory">
            <summary>
            History of d/dt of log-power. Note that the sampling rate of this stream is <see cref="P:BagoumLib.SignalProcessing.BeatDetector.PowerSampleRate"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.PowerBand.PowerN">
            <summary>
            Size of each convolution block for power signal analysis.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.PowerBand.Src">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.SignalProcessing.PowerBand.LowLimit">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.SignalProcessing.PowerBand.HighLimit">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.PowerBand.#ctor(BagoumLib.SignalProcessing.BeatDetector,System.Double,System.Double)">
            <inheritdoc cref="T:BagoumLib.SignalProcessing.PowerBand"/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.PowerBand.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.PowerBand.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.PowerBand.OnNext(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.PowerBand.LogPower(System.Double)">
            <summary>
            Get the logarithm of a power. This function is adjusted to return 0 for low powers.
            </summary>
        </member>
        <member name="T:BagoumLib.SignalProcessing.SignalBand">
            <summary>
            Data for a frequency band that reads amplitude signals from the time domain and smears them.
             New data can be provided via OnNext, then read from either <see cref="P:BagoumLib.SignalProcessing.SignalBand.History"/>
            or <see cref="P:BagoumLib.SignalProcessing.SignalBand.DerivativeHistory"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.SignalBand.History">
            <summary>
            History of smeared amplitude signals.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.SignalBand.DerivativeHistory">
            <summary>
            History of amplitude derivatives.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.SignalBand.Src">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.SignalProcessing.SignalBand.LowLimit">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.SignalProcessing.SignalBand.HighLimit">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.SignalBand.#ctor(BagoumLib.SignalProcessing.BeatDetector,System.Double,System.Double)">
            <inheritdoc cref="T:BagoumLib.SignalProcessing.SignalBand"/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.SignalBand.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.SignalBand.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.SignalBand.OnNext(System.Numerics.Complex[])">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.SampleRate">
            <summary>
            Sample rate of the original audio file.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.PowerSampleRate">
            <summary>
            Sampling rate of power signals. This is much lower than the raw audio sampling rate
            (eg. for 44100Hz audio, N=2048, this sampling rate is in the range 20-100.)
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.NSignal">
            <summary>
            Number of samples taken from the original audio stream for each <see cref="T:BagoumLib.SignalProcessing.SignalBand"/> input.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.HzPerSignalBucket">
            <summary>
            Width of each FFT bucket in hertz for each <see cref="T:BagoumLib.SignalProcessing.SignalBand"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.NPower">
            <summary>
            Number of samples taken from the original audio stream for each <see cref="T:BagoumLib.SignalProcessing.PowerBand"/> input.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.HzPerPowerBucket">
            <summary>
            Width of each FFT bucket in hertz for each <see cref="T:BagoumLib.SignalProcessing.PowerBand"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.NSignalBands">
            <summary>
            Number of <see cref="T:BagoumLib.SignalProcessing.SignalBand"/>s.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.NPowerBands">
            <summary>
            Number of <see cref="T:BagoumLib.SignalProcessing.PowerBand"/>s.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.PowerOverlapFactor">
            <summary>
            Where x is the amount of overlap between successive power samples, this is 1/(1-x).
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.NHistory">
            <summary>
            Number of historical records kept for energy comparison in <see cref="T:BagoumLib.SignalProcessing.SignalBand"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.SigBands">
            <summary>
            Signal bands.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.PowerBands">
            <summary>
            Power bands.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.FFT">
            <summary>
            FFT provider.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.LastReadSignalSample">
            <summary>
            The index of the last read sample from the sample data for <see cref="T:BagoumLib.SignalProcessing.SignalBand"/>.
            <br/>Note that this may be greater than any band-specific convolution data since convolutions are delayed.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.BeatDetector.LastReadPowerSample">
            <summary>
            The index of the last read sample from the sample data for <see cref="T:BagoumLib.SignalProcessing.PowerBand"/>.
            <br/>Note that this may be greater than any band-specific convolution data since convolutions are delayed.
            </summary>
        </member>
        <member name="F:BagoumLib.SignalProcessing.BeatDetector.MaxHz">
            <summary>
            Maximum parsed frequency.
            </summary>
        </member>
        <member name="F:BagoumLib.SignalProcessing.BeatDetector.MinHz">
            <summary>
            Minimum parsed frequency.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.BeatDetector.Update(System.Collections.Generic.IReadOnlyList{System.Single},System.Int32,System.Double[])">
            <summary>
            Update the beat detector with new samples.
            </summary>
            <param name="dataProvider">Provider of sample data.</param>
            <param name="maxIndex">Max index (exclusive) that can be sampled.</param>
            <param name="powers">Array in which to store the most recent power data (of length NPower).</param>
            <returns>True iff samples were read from the provider.</returns>
        </member>
        <member name="T:BagoumLib.SignalProcessing.ChunkConvolver">
            <summary>
            Convolve two sequences in the time domain together, where the first sequence is a series of chunks.
            <br/>Extra information at the start and end of the resulting convolution is discarded.
            <br/>Note: the Subscribe repeatedly yields the same underlying array. The yielded array must be processed
             before calling OnNext.
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.ChunkConvolver.Completion">
            <summary>
            Task that can be used in place of subscribing to <see cref="M:BagoumLib.SignalProcessing.ChunkConvolver.OnCompleted"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.ChunkConvolver.#ctor(BagoumLib.SignalProcessing.IFFT,System.Int32,System.Numerics.Complex[],System.Boolean)">
            <summary>
            </summary>
            <param name="fft">FFT provider.</param>
            <param name="srcChunkLen">The length of each block provided by <see cref="M:BagoumLib.SignalProcessing.ChunkConvolver.OnNext(System.Numerics.Complex[])"/>.</param>
            <param name="resp">Response filter. The length must be a power of two.</param>
            <param name="useCorrelation">If true, computes a correlation instead of a convolution.
            (Note that a convolution is symmetric, but a correlation is not. This computes src*resp^.)</param>
            <returns>A series of chunks of convolved data, each of length <see cref="F:BagoumLib.SignalProcessing.ChunkConvolver.srcChunkLen"/>.</returns>
        </member>
        <member name="M:BagoumLib.SignalProcessing.ChunkConvolver.OnNext(System.Numerics.Complex[])">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.ChunkConvolver.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.ChunkConvolver.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.SignalProcessing.ChunkConvolver.Subscribe(System.IObserver{System.Numerics.Complex[]})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.SignalProcessing.FastFourierTransform">
            <summary>
            Performs fast Fourier transform (FFT).
            </summary>
        </member>
        <member name="P:BagoumLib.SignalProcessing.FastFourierTransform.Length">
            <summary>
            The length of the FFT.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FastFourierTransform.#ctor(System.Int32)">
            <summary>
            Initializes the FFT with the given length.
            </summary>
            <param name="length">The length of the FFT.</param>
            <remarks>
            The FFT length must be a power of two.
            </remarks>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FastFourierTransform.Forward(System.Span{System.Numerics.Complex})">
            <summary>
            Performs forward FFT in-place.
            </summary>
            <param name="samples">The samples to be transformed.</param>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FastFourierTransform.InverseScaled(System.Span{System.Numerics.Complex})">
            <summary>
            Performs inverse FFT in-place.
            </summary>
            <param name="spectrum">The spectrum to be transformed.</param>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FastFourierTransform.Inverse(System.Span{System.Numerics.Complex})">
            <summary>
            Performs inverse FFT in-place.
            </summary>
            <param name="spectrum">The spectrum to be transformed.</param>
        </member>
        <member name="T:BagoumLib.SignalProcessing.IFFT">
            <summary>
            An algorithm providing an FFT implementation.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.IFFT.DoFFT(System.Numerics.Complex[],System.Int32)">
            <summary>
            Given a set of data in bit-reversed order,
            find the FFT of that data in proper order in-place.
            <br/>Note that sign=-1 is the forward FFT and sign=1 is the inverse FFT.
            </summary>
        </member>
        <member name="T:BagoumLib.SignalProcessing.OouraFFT">
            <summary>
            FFT implementation based on Takuya Ooura's FFT library.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.OouraFFT.DoFFT(System.Numerics.Complex[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.SignalProcessing.CombFFT">
            <summary>
            Comb-based implementation of FFT.
            (Demonstration purposes only; this is significantly slower than <see cref="T:BagoumLib.SignalProcessing.OouraFFT"/>.)
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.CombFFT.DoFFT(System.Numerics.Complex[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.SignalProcessing.RecursiveFFT">
            <summary>
            Recursion-based implementation of FFT.
            (Demonstration purposes only; this is significantly slower than <see cref="T:BagoumLib.SignalProcessing.OouraFFT"/>.)
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.RecursiveFFT.DoFFT(System.Numerics.Complex[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.SignalProcessing.FFTHelpers">
            <summary>
            Helper functions for Fast Fourier Transforms.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.DivideByN(System.Numerics.Complex[])">
            <summary>
            Divide each element by the length of the array. Required for FFT normalization.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.Conjugate(System.Numerics.Complex[])">
            <summary>
            Replace each element in the array with its complex conjuate.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.FFTToFreq(BagoumLib.SignalProcessing.IFFT,System.Numerics.Complex[],System.Boolean)">
            <summary>
            Perform an in-place FFT from a sequence of values into a set of frequencies.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.RemoveAliasing(System.Numerics.Complex[])">
            <summary>
            Remove aliased frequencies in the second half of the array (frequencies greater than the folding frequency).
            <br/>Since DFT is symmetric around the folding frequency, we assume that the true frequencies are the lower
             frequencies and the higher frequencies are aliasing artifacts.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.AddAliasing(System.Numerics.Complex[])">
            <summary>
            Re-add aliased frequencies removed by <see cref="M:BagoumLib.SignalProcessing.FFTHelpers.RemoveAliasing(System.Numerics.Complex[])"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.FFTFromFreq(BagoumLib.SignalProcessing.IFFT,System.Numerics.Complex[],System.Boolean)">
            <summary>
            Perform an in-place FFT from a set of frequencies into a sequence of values. Also divide by N.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.NormalizeReals(System.Numerics.Complex[])">
            <summary>
            Normalizes the real components only of a data stream in-place, so that the real components to 1.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.Normalize(System.Numerics.Complex[])">
            <summary>
            Normalize the values of a data stream in-place, such that their magnitudes sum to 1.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.NormalizeEnergy(System.Numerics.Complex[])">
            <summary>
            Normalizes a vector such that the square of square magnitudes sums to 1.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.DataForFnOverPeriod(System.Func{System.Double,System.Numerics.Complex},System.Double,System.Int32)">
            <summary>
            Create an array of complex numbers whose values are the values of `fn` evaluated between 0 and `period`.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.DataForFnAtRate(System.Func{System.Double,System.Numerics.Complex},System.Double,System.Int32)">
            <summary>
            Create an array of complex numbers whose values are values of `fn` evaluated between 0 and `samples/samplingRate`.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.DataForFn(System.Func{System.Int32,System.Numerics.Complex},System.Int32)">
            <summary>
            Create an array of complex numbers whose values are the values of `fn` evaluated between 0 and `samples`.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.WrapIndex(System.Int32,System.Int32)">
            <summary>
            Remap the range [ptN/2, ptN) to [-ptN/2,0).
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.DataForFilter(System.Func{System.Int32,System.Numerics.Complex},System.Int32)">
            <summary>
            Create an array of complex numbers whose values are the values of `fn` evaluated between 0 and `samples`,
            and the indices are passed to the provided function as follows:
            <br/>0 1 2 3... (N/2-2) (N/2-1) -N/2 -N/2+1 ... -3 -2 -1
            <br/>ie. The first half of the array is nonnegative, and the second half is negative.
            <br/>This function should be used for the filters in <see cref="T:BagoumLib.SignalProcessing.Filters"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.Convolve(BagoumLib.SignalProcessing.IFFT,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Convolve two periodic sequences in the time domain together.
            <br/>The arrays must be the same length, and this length must be a power of two.
            <br/>Overwrites both arrays and returns data1.
            <br/>Note that convolution is commutative (Convolve(a,b) = Convolve(b,a)).
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.Correlate(BagoumLib.SignalProcessing.IFFT,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Correlates two periodic sequences in the time domain together.
            <br/>The arrays must be the same length, and this length must be a power of two.
            <br/>Overwrites both arrays and returns data1.
            <br/>Note that Correlate(x, y) = Convolve(x, Conjugate(y)).
            Correlation is not commutative, but convolution is.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.GetFilterLength(System.Numerics.Complex[])">
            <summary>
            Get the forward and backward length of a response filter.
            <br/>Note: for this to work, elements in the middle of the array must be zeroed out correctly.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.PadFilterToLength(System.Numerics.Complex[],System.Int32)">
            <summary>
            Pad a response filter in the center so its length is `reqLen`. (If the filter is already of this length,
             then does nothing.)
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.ConvolveFilters(BagoumLib.SignalProcessing.IFFT,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Convolve two response filters together. If they are not of the same size, will pad them in the center.
            <br/>Convolving two response filters of size N and M results in a filter of size N+M. If this size
             is greater than the size of the array, then pollution will occur. To avoid this, this function
             will check the filter sizes and create a longer array if required. It will also zero out
             elements in the middle of the result array after convolution.
            <br/>May overwrite both arrays and return data1. Alternatively, may return a longer array.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.ConvolveOnFreq(BagoumLib.SignalProcessing.IFFT,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Convolve two periodic sequences together, where the first is in the time domain
             and the second is in the frequency domain.
            <br/>The arrays must be the same length, and this length must be a power of two.
            <br/>Overwrites and returns data1.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.Pad``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Pad an array of data with default values on the left, middle, and right.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.PointwiseMultiply(System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Do a pointwise multiplication of two arrays, storing the output in-place in the first array.
            <br/>If these arrays are the output of a forward FFT, then this represents a convolution.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.IsPowerOfTwo(System.Int32)">
            <summary>
            Return true if x is a power of two.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.NextPowerOfTwo(System.Int32)">
            <summary>
            Return the first power of 2 greater than or equal to x.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.BitReverseIndices(System.Numerics.Complex[])">
            <summary>
            Reorder the elements of the array by placing each element at its bit-reversed index.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.BitReverse(System.Int32,System.Int32)">
            <summary>
            Reverse the last `bits` bits of the integer `x`.
            <br/>eg. BitReverse(3, 4) = BitReverse(0b0011, 4) = 0b1100 = 12
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.FFTHelpers.IExp(System.Double)">
            <summary>
            Return e^(ix).
            </summary>
        </member>
        <member name="T:BagoumLib.SignalProcessing.Filters">
            <summary>
            Reference filters for audio processing.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.Hann(System.Double,System.Int32)">
            <summary>
            Hann windowing over the range [-(N-1)/2, (N-1)/2]. Any outside elements will be zeroed.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.HalfHann(System.Double,System.Int32)">
            <summary>
            Normalized half-Hann windowing over the range [0, N/2). Any outside elements will be zeroed.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.Identity(System.Int32)">
            <summary>
            A filter that returns the same source data.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.Tukey(System.Int32,System.Int32,System.Double)">
            <summary>
            The symmetric Tukey window over the range [-(N-1)/2,(N-1)/2]. Any outside elements will be zeroed.
            <br/>The tail `falloff` ratios have a cosine lobe, and the center area is 1.
            </summary>
            <param name="i">Sample index in the range [-N/2,N/2).</param>
            <param name="N">Total number of samples. Should be odd.</param>
            <param name="falloff">Falloff ratio (in the range [0,1]).</param>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.Gaussian(System.Int32,System.Int32,System.Double)">
            <summary>
            Gaussian filter centered at 0. (Has an inbuilt Tukey filter to zero out elements outside the range.)
            </summary>
            <param name="i">Sample index in the range [-N/2,N/2).</param>
            <param name="N">Total number of samples for the filter duration. Should be odd.</param>
            <param name="sigma">Standard deviation in number of samples. For best results, should be less than N/8.</param>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.DGaussian(System.Int32,System.Int32,System.Double)">
            <summary>
            Derivative Gaussian filter centered at 0. (Has an inbuilt Tukey filter to zero out elements outside the range.)
            <br/>Note that this is a d/di filter (derivate w.r.t sample index).
            <br/>For a d/dt filter (derivative w.r.t time), multiply the output of this function by
            the sampling rate (=di/dt).
            </summary>
            <param name="i">Sample index in the range [-N/2,N/2).</param>
            <param name="N">Total number of samples for the filter duration. Should be odd.</param>
            <param name="sigma">Standard deviation in number of samples. For best results, should be less than N/8.</param>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.Morlet(System.Int32,System.Int32,System.Double)">
            <summary>
            Create a Morlet wavelet with a normalized energy of 1.
            </summary>
            <param name="i">Sample index in the range [-N/2,N/2).</param>
            <param name="N">Total number of samples for the filter duration. The standard deviation of the Gaussian will be one-eighth of this.</param>
            <param name="freq">Frequency of the wave as a fraction of sampling rate.</param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.LowPass(System.Int32,System.Int32,System.Double)">
            <summary>
            Low-pass filter.
            </summary>
            <param name="i">Sample index in the range [-N/2,N/2).</param>
            <param name="N">Number of samples for the filter duration. Should be odd.</param>
            <param name="cutoff">Frequency cutoff as a fraction of sampling rate. Has a rolloff of 4*SR/N Hz.</param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.HighPass(System.Int32,System.Int32,System.Double)">
            <summary>
            High-pass filter.
            </summary>
            <param name="i">Sample index [0, ptN).</param>
            <param name="N">Number of samples for the filter duration. Should be odd.</param>
            <param name="cutoff">Frequency cutoff as a fraction of sampling rate. Has a rolloff of 4*SR/N Hz.</param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.SignalProcessing.Filters.BandPass(BagoumLib.SignalProcessing.IFFT,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Band-pass filter.
            </summary>
            <param name="fft">FFT provider.</param>
            <param name="N">Number of samples for the filter duration. Should be odd.</param>
            <param name="ptN">Total number of samples to put in the array. Should be a value 2^k >= N.</param>
            <param name="cutoff1">Lower frequency cutoff as a fraction of sampling rate.</param>
            <param name="cutoff2">Higher frequency cutoff as a fraction of sampling rate.</param>
            <returns></returns>
        </member>
        <member name="T:BagoumLib.SignalProcessing.IWindower">
            <summary>
            A windowing function.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.IWindower.WindowMultiplier(System.Int32,System.Int32)">
            <summary>
            Return the 0-1 multiplier for index `i` out of a data array of length `N`.
            </summary>
        </member>
        <member name="T:BagoumLib.SignalProcessing.NoWindow">
            <summary>
            No windowing.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.NoWindow.WindowMultiplier(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.SignalProcessing.HannWindow">
            <summary>
            Hann windowing.
            </summary>
        </member>
        <member name="M:BagoumLib.SignalProcessing.HannWindow.WindowMultiplier(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Sorting.AlternatingMergeSorter`1">
            <summary>
            An implementation of merge sort that sorts elements back and forth from the buffer
            in order to minimize buffer copies.
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.AlternatingMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])">
            <summary>
            Sort an array using mergesort.
            </summary>
            <param name="array">Array to sort</param>
            <param name="start">Starting index for sort (inclusive)</param>
            <param name="end">Ending index for sort (exclusive)</param>
            <param name="comp">Sort comparer</param>
            <param name="buffer">Working buffer. Must have at least (end-start)/2 capacity</param>
        </member>
        <member name="M:BagoumLib.Sorting.AlternatingMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0})">
            <summary>
            See <see cref="M:BagoumLib.Sorting.AlternatingMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.AlternatingMergeSorter`1.Sort(`0[],BagoumLib.Sorting.LeqCompare{`0})">
            <summary>
            See <see cref="M:BagoumLib.Sorting.AlternatingMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])"/>
            </summary>
        </member>
        <member name="T:BagoumLib.Sorting.CombMergeSorter`1">
            <summary>
            Merge sort that uses a bottom-up combing method.
            <br/>Best for when the array is mostly sorted.
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.CombMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])">
            <summary>
            Sort an array using bottom-up mergesort.
            </summary>
            <param name="array">Array to sort</param>
            <param name="start">Starting index for sort (inclusive)</param>
            <param name="end">Ending index for sort (exclusive)</param>
            <param name="comp">Sort comparer</param>
            <param name="buffer">Working buffer. Must have at least (end-start)/2 capacity</param>
        </member>
        <member name="M:BagoumLib.Sorting.CombMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0})">
            <summary>
            See <see cref="M:BagoumLib.Sorting.CombMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.CombMergeSorter`1.Sort(`0[],BagoumLib.Sorting.LeqCompare{`0})">
            <summary>
            See <see cref="M:BagoumLib.Sorting.CombMergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])"/>
            </summary>
        </member>
        <member name="T:BagoumLib.Sorting.InsertionSort`1">
            <summary>
            Implementation of insertion sort.
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.InsertionSort`1.Sort(`0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the provided range of the array.
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.InsertionSort`1.Sort_(`0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:BagoumLib.Sorting.InsertionSort`1.Sort(`0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="T:BagoumLib.Sorting.LeqCompare`1">
            <summary>
            Returns true iff a is less than or equal to b.
            </summary>
        </member>
        <member name="T:BagoumLib.Sorting.MergeSorter`1">
            <summary>
            An implementation of mergesort that uses a buffer for extra space.
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.MergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])">
            <summary>
            Sort an array using mergesort.
            </summary>
            <param name="array">Array to sort</param>
            <param name="start">Starting index for sort (inclusive)</param>
            <param name="end">Ending index for sort (exclusive)</param>
            <param name="comp">Sort comparer</param>
            <param name="buffer">Working buffer. Must have at least (end-start)/2 capacity</param>
        </member>
        <member name="M:BagoumLib.Sorting.MergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0})">
            <summary>
            See <see cref="M:BagoumLib.Sorting.MergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])"/>
            </summary>
        </member>
        <member name="M:BagoumLib.Sorting.MergeSorter`1.Sort(`0[],BagoumLib.Sorting.LeqCompare{`0})">
            <summary>
            See <see cref="M:BagoumLib.Sorting.MergeSorter`1.Sort(`0[],System.Int32,System.Int32,BagoumLib.Sorting.LeqCompare{`0},`0[])"/>
            </summary>
        </member>
        <member name="T:BagoumLib.Tasks.TaskQueue">
            <summary>
            A container that queues tasks for sequential execution.
            </summary>
        </member>
        <member name="P:BagoumLib.Tasks.TaskQueue.CurrentTask">
            <summary>
            The currently executing task.
            </summary>
        </member>
        <member name="P:BagoumLib.Tasks.TaskQueue.IsExecuting">
            <summary>
            True when a task is being executed.
            </summary>
        </member>
        <member name="P:BagoumLib.Tasks.TaskQueue.AllowOnlyOneQueued">
            <summary>
            If true, then only one task can be queued up at a time.
            Queued tasks will be cleared when a new task is added.
            True by default.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.TaskQueue.EnqueueTask(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Enqueue a task for execution.
            </summary>
            <returns>A task that is completed when the provided task is run to completion.</returns>
        </member>
        <member name="T:BagoumLib.Tasks.Utilities">
            <summary>
            Task-related helpers.
            </summary>
        </member>
        <member name="F:BagoumLib.Tasks.Utilities.TaskWhenAll">
            <summary>
            Calls Task.InternalWhenAll, skipping array reallocation.
            <br/>DO NOT pass null tasks to this!
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.And(System.Threading.Tasks.Task,System.Threading.Tasks.Task)">
            <summary>
            Return a task that is completed when both provided tasks are completed.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.Then(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Run two tasks in sequence.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.AsTask``1(System.Action)">
            <summary>
            Return a Func that calls the provided action and then returns a null task.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.AsTask``1(System.Action{``0})">
            <inheritdoc cref="M:BagoumLib.Tasks.Utilities.AsTask``1(System.Action)"/>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.All``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Runs the map function on all items in the list and returns a Task.WhenAll.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.All(System.Collections.Generic.List{System.Threading.Tasks.Task})">
            <summary>
            Removes completed or null tasks from the list, and then calls WhenAll.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.All(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            Removes completed or null tasks from the list, and then calls WhenAll.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.DontReportCancellation(System.Threading.Tasks.Task)">
            <summary>
            Return a task that is completed successfully if the original task
             is completed successfully or cancelled, and fails if the original task fails.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.ContinueWithSync(System.Threading.Tasks.Task,System.Action,System.Nullable{System.Boolean})">
            <summary>
            Runs a continuation after a task and logs exceptions from the task or the continuation.
            <br/>The continuation runs even if the task is cancelled/hits an exception.
            <br/>If the continuation hits an exception,
             the task result will contain that exception (with the original task exception nested within it).
            <br/>It is useful to use this on unawaited tasks with a null continuation, as it logs exceptions.
            <br/>If `logOnCancelled` is true or `done` is null, then will also log cancellations.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.Log(System.Threading.Tasks.Task)">
            <summary>
            Logs exceptions or cancellation from the task.
            <br/>Use on unawaited tasks to report errors.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.ContinueSuccessWithSync``1(System.Threading.Tasks.Task{``0},System.Action{``0})">
            <summary>
            Runs a continuation and logs errors from the task or the continuation.
            <br/>Note that this only executes the continuation if the task completes successfully.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.Pipe``1(System.Threading.Tasks.Task{``0},System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Put the result of this task into a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.Utilities.Pipe(System.Threading.Tasks.Task,System.Threading.Tasks.TaskCompletionSource{System.Reactive.Unit})">
            <summary>
            Put the result of this task into a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Tasks.WaitingUtils">
            <summary>
            Helpers for awaiting tasks.
            </summary>
        </member>
        <member name="F:BagoumLib.Tasks.WaitingUtils.NoOp">
            <summary>
            An Action that does nothing.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.GetAwaiter(System.Threading.Tasks.Task@)">
            <summary>
            Get an action that completes a task.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.GetUnitAwaiter(System.Threading.Tasks.Task{System.Reactive.Unit}@)">
            <summary>
            Get an action that completes a task.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.GetManyAwaiter(System.Int32,System.Threading.Tasks.Task@)">
            <summary>
            Get an action that must be called `ct` times to complete a task.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.GetCompletionAwaiter(System.Threading.Tasks.Task{BagoumLib.Completion}@)">
            <summary>
            Get an action that completes a task.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.GetCondition(System.Func{System.Boolean}@)">
            <summary>
            Get an action that sets a boolean value (returned by `cond`) to true.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.GetManyCallback(System.Int32,System.Action)">
            <summary>
            Get a callback that must be called `ct` times in order to invoke `whenAll`.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.WaitFor(System.Single,System.Action{BagoumLib.Completion},BagoumLib.Cancellation.ICancellee,System.Func{System.Single})">
            <summary>
            Waits for the given amount of time, but can be cancelled early by the cT.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.WaitFor(System.Func{System.Boolean},System.Action{BagoumLib.Completion},BagoumLib.Cancellation.ICancellee)">
            <summary>
            Waits until the condition is satisfied, but can be cancelled early by the cT.
            </summary>
        </member>
        <member name="M:BagoumLib.Tasks.WaitingUtils.Spin(System.Action{BagoumLib.Completion},BagoumLib.Cancellation.ICancellee)">
            <summary>
            Waits until the cT is cancelled.
            </summary>
        </member>
        <member name="T:BagoumLib.Transitions.ITransition">
            <summary>
            Interface for transitions that execute via <see cref="T:BagoumLib.DataStructures.Coroutines"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.ITransition.Run(BagoumLib.DataStructures.ICoroutineRunner,BagoumLib.DataStructures.CoroutineOptions)">
            <summary>
            Runs the transition.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.ITransition.With(BagoumLib.Cancellation.ICancellee,System.Func{System.Single})">
            <summary>
            Nondestructively modify all nested transitions.
            </summary>
        </member>
        <member name="T:BagoumLib.Transitions.TransitionBase`1">
            <summary>
            Base class for <see cref="T:BagoumLib.Transitions.ITransition"/>s over type T.
            </summary>
            <typeparam name="T">Type of the value that is being modified</typeparam>
        </member>
        <member name="P:BagoumLib.Transitions.TransitionBase`1.Time">
            <summary>
            Amount of time over which to perform tweening.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.TransitionBase`1.CToken">
            <summary>
            Cancellation token used to stop execution.
            If set to null, then will use the RunDroppable interface on the executing coroutine manager.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.TransitionBase`1.DeltaTimeProvider">
            <summary>
            Method to retrieve the delta-time of the current frame. Preferably set this via Tween.DefaultDeltaTimeProvider.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.TransitionBase`1.Apply">
            <summary>
            Method to apply an updated tweened value. (Required during initialization.)
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.TransitionBase`1.Ease">
            <summary>
            Easing method used to smooth the tweening process. By default, set to IOSine (not Linear).
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionBase`1.ApplyStart">
            <summary>
            Apply the initial value of the transition.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionBase`1.ApplyStep(`0,System.Single)">
            <summary>
            Apply the value of the transition at a given time.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionBase`1.ApplyEnd(`0)">
            <summary>
            Apply the final value of the transition.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionBase`1.Run(BagoumLib.DataStructures.ICoroutineRunner,BagoumLib.DataStructures.CoroutineOptions)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionBase`1.With(BagoumLib.Cancellation.ICancellee,System.Func{System.Single})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Transitions.TransitionHelpers">
            <summary>
            Helpers for creating transitions.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.TransitionHelpers.DefaultDeltaTimeProvider">
            <summary>
            Default provider for transition deltaTime. Should be provided by consuming libraries.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.Apply``1(System.Func{System.Single,``0},System.Single,System.Action{``0},System.Func{``0},BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a transition that applies a value provided by `eval` at every time step.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.TweenTo``1(``0,``0,System.Single,System.Action{``0},BagoumLib.Mathematics.Easer,BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a transition that lerps from `start` to `end`.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.TweenDelta``1(``0,``0,System.Single,System.Action{``0},BagoumLib.Mathematics.Easer,BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a transition that lerps from `start` to `start+delta`.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.TweenBy``1(``0,System.Single,System.Single,System.Action{``0},BagoumLib.Mathematics.Easer,BagoumLib.Cancellation.ICancellee)">
            <summary>
            Create a transition that lerps from `start` to `start*by`.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.Then(BagoumLib.Transitions.ITransition,BagoumLib.Transitions.ITransition)">
            <summary>
            Run two transitions in sequence.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.Then(BagoumLib.Transitions.ITransition,System.Func{BagoumLib.Transitions.ITransition})">
            <inheritdoc cref="M:BagoumLib.Transitions.TransitionHelpers.Then(BagoumLib.Transitions.ITransition,BagoumLib.Transitions.ITransition)"/>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.Parallel(BagoumLib.Transitions.ITransition[])">
            <summary>
            Run multiple transitions in parallel.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.Parallel(BagoumLib.Transitions.ITransition,BagoumLib.Transitions.ITransition[])">
            <summary>
            Run multiple transitions in parallel.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.TransitionHelpers.Loop(BagoumLib.Transitions.ITransition,System.Nullable{System.Int32})">
            <summary>
            Loop a transition.
            </summary>
        </member>
        <member name="T:BagoumLib.Transitions.StatusApplier`1">
            <summary>
            A transition that sets a value based on a function of time (<see cref="P:BagoumLib.Transitions.StatusApplier`1.Valuer"/>).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BagoumLib.Transitions.StatusApplier`1.Valuer">
            <summary>
            Value to apply given time T.
            If <see cref="F:BagoumLib.Transitions.StatusApplier`1.InitialValue"/> is defined, this will be added to it.
            </summary>
        </member>
        <member name="F:BagoumLib.Transitions.StatusApplier`1.InitialValue">
            <summary>
            If present, will be used as an offset for Valuer.
            Evaluated when the transition is run.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.StatusApplier`1.#ctor(System.Func{System.Single,`0},System.Single,System.Action{`0},BagoumLib.Cancellation.ICancellee)">
            <inheritdoc cref="T:BagoumLib.Transitions.StatusApplier`1"/>
        </member>
        <member name="M:BagoumLib.Transitions.StatusApplier`1.ApplyStart">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.StatusApplier`1.ApplyStep(`0,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.StatusApplier`1.ApplyEnd(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Transitions.Tweener`1">
            <summary>
            A transition that lerps a value from <see cref="P:BagoumLib.Transitions.Tweener`1.Start"/> to <see cref="P:BagoumLib.Transitions.Tweener`1.End"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.Tweener`1.Start">
            <summary>
            Initial value of tweening.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.Tweener`1.End">
            <summary>
            Final value of tweening.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.Tweener`1.Lerp">
            <summary>
            Lerp function specific to type T (unclamped). Add handling for types via Tween.RegisterLerper.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.Tweener`1.#ctor(BagoumLib.Functional.Either{`0,System.Func{`0}},BagoumLib.Functional.Either{`0,System.Func{`0}},System.Single,System.Action{`0},BagoumLib.Mathematics.Easer,BagoumLib.Cancellation.ICancellee)">
            <inheritdoc cref="T:BagoumLib.Transitions.Tweener`1"/>
        </member>
        <member name="M:BagoumLib.Transitions.Tweener`1.ApplyStart">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.Tweener`1.ApplyStep(`0,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.Tweener`1.ApplyEnd(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.Tweener`1.Reverse(System.Boolean)">
            <summary>
            TODO a delayed invocation uses startgetter, and should pass that to Reverse, but Reverse won't work with the same startgetter.
            TODO Reverse is probably better defined with a "delta" field instead.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.Tweener`1.Yoyo(System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Create a yoyo transition from this transition; ie. a transition that runs this, runs this in reverse, and then repeats.
            </summary>
            <param name="reverseEase">True if the easing function should be reversed for the reverse section.</param>
            <param name="times">Number of times to repeat the joined transition; null for indefinite.</param>
        </member>
        <member name="T:BagoumLib.Transitions.NoopTweener">
            <summary>
            A tweener that does nothing for the provided amount of time.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.NoopTweener.#ctor(System.Single,BagoumLib.Cancellation.ICancellee)">
            <inheritdoc cref="T:BagoumLib.Transitions.NoopTweener"/>
        </member>
        <member name="M:BagoumLib.Transitions.NoopTweener.ApplyStart">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.NoopTweener.ApplyStep(System.Reactive.Unit,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.NoopTweener.ApplyEnd(System.Reactive.Unit)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Transitions.ScaleInTweener`1">
            <summary>
            A transition that scales in a value using scalar multiplication.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.ScaleInTweener`1.Target">
            <summary>
            The value to be scaled in by the tweener.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.ScaleInTweener`1.Scaler">
            <summary>
            Multiplier function specific to type T. Add handling for types via Tween.RegisterMultiplier.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.ScaleInTweener`1.#ctor(`0,System.Single,System.Action{`0},BagoumLib.Mathematics.Easer,BagoumLib.Cancellation.ICancellee)">
            <inheritdoc cref="T:BagoumLib.Transitions.ScaleInTweener`1"/>
        </member>
        <member name="M:BagoumLib.Transitions.ScaleInTweener`1.ApplyStart">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.ScaleInTweener`1.ApplyStep(`0,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.ScaleInTweener`1.ApplyEnd(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Transitions.DeltaTweener`1">
            <summary>
            A transition that gradually adds a delta to a value.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.DeltaTweener`1.Start">
            <summary>
            Initial value of tweening.
            </summary>
        </member>
        <member name="P:BagoumLib.Transitions.DeltaTweener`1.Delta">
            <summary>
            Delta to apply to initial value.
            </summary>
        </member>
        <member name="F:BagoumLib.Transitions.DeltaTweener`1.Lerp">
            <summary>
            Lerp function specific to type T. Add handling for types via Tween.RegisterLerper.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.DeltaTweener`1.#ctor(BagoumLib.Functional.Either{`0,System.Func{`0}},`0,System.Single,System.Action{`0},BagoumLib.Mathematics.Easer,BagoumLib.Cancellation.ICancellee)">
            <inheritdoc cref="T:BagoumLib.Transitions.DeltaTweener`1"/>
        </member>
        <member name="M:BagoumLib.Transitions.DeltaTweener`1.ApplyStart">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.DeltaTweener`1.ApplyStep(`0,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.DeltaTweener`1.ApplyEnd(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Transitions.SequentialTransition">
            <summary>
            A transition that runs multiple transitions in sequence.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.SequentialTransition.#ctor(BagoumLib.Functional.Delayed{BagoumLib.Transitions.ITransition}[])">
            <summary>
            A transition that runs multiple transitions in sequence.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.SequentialTransition.Run(BagoumLib.DataStructures.ICoroutineRunner,BagoumLib.DataStructures.CoroutineOptions)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.SequentialTransition.With(BagoumLib.Cancellation.ICancellee,System.Func{System.Single})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Transitions.ParallelTransition">
            <summary>
            A transition that runs multiple transitions in parallel.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.ParallelTransition.#ctor(BagoumLib.Transitions.ITransition[])">
            <summary>
            A transition that runs multiple transitions in parallel.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.ParallelTransition.Run(BagoumLib.DataStructures.ICoroutineRunner,BagoumLib.DataStructures.CoroutineOptions)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.ParallelTransition.With(BagoumLib.Cancellation.ICancellee,System.Func{System.Single})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Transitions.LoopTransition">
            <summary>
            A transition that loops a child transition.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.LoopTransition.#ctor(BagoumLib.Transitions.ITransition,System.Nullable{System.Int32})">
            <summary>
            A transition that loops a child transition.
            </summary>
        </member>
        <member name="M:BagoumLib.Transitions.LoopTransition.Run(BagoumLib.DataStructures.ICoroutineRunner,BagoumLib.DataStructures.CoroutineOptions)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Transitions.LoopTransition.With(BagoumLib.Cancellation.ICancellee,System.Func{System.Single})">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Unification.ITypeTree">
            <summary>
            An AST representing a program that can be used for two-pass type unification with overloading and implicit cast support.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.ITypeTree.PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)">
            <summary>
            First pass, bottom-up: recursively determine all possible types for all operands,
            then return the return types of all overloadings that satisfy at least one of the entries
             in the Cartesian product of possible operand sets.
            <br/>Implicit casts should be investigated at the *method* level, not the parameter level.
            <br/>By default, a method may only check its parameters for implicit casts if required, unless alwaysCheckImplicitCasts is set.
            <br/>Note that it is possible to have some outputs that do not actually work, as this may skip some
              parent-child alignment checks for efficiency.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)">
            <summary>
            Second pass, top-down: After determining one final type for the entire type tree,
            find the one overloading that satisfies that type (if there are 0 or 2+, then return an error),
            and unify it with any tree children.
            <br/>Implicit casts should be realized at the *parameter* level, not the method level.
            <br/>This overloading should be saved locally and its return type must be provided as <see cref="P:BagoumLib.Unification.ITypeTree.SelectedOverloadReturnType"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/>
        </member>
        <member name="M:BagoumLib.Unification.ITypeTree.FinalizeUnifiers(BagoumLib.Unification.Unifier)">
            <summary>
            Third pass, readonly: Finalize the types of <see cref="P:BagoumLib.Unification.ITypeTree.SelectedOverloadReturnType"/>, <see cref="P:BagoumLib.Unification.ITypeTree.ImplicitCast"/>,
             and any other information that may have been further specified by unification in other parts of the tree.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.ITypeTree.SelectedOverloadReturnType">
            <summary>
            The return type of the overloading that was selected for this AST.
            <br/>Note that for a method call, this must be the return type of the method.
            <br/>This should be overriden by <see cref="P:BagoumLib.Unification.ITypeTree.ImplicitCast"/> if it is present.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.ITypeTree.SelectedOverloadReturnTypeNoCast">
            <summary>
            The return type of the overloading that was selected for this AST.
            <br/>Note that for a method call, this must be the return type of the method.
            <br/>This should *not* be overriden by <see cref="P:BagoumLib.Unification.ITypeTree.ImplicitCast"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.ITypeTree.ImplicitCast">
            <summary>
            The type to which the return type of this AST is implicitly cast.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.ITypeTree.IsFullyResolved">
            <summary>
            True iff the type of this tree and all its components are fully determined.
            <br/>This should only be called after <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.ITypeTree.UnresolvedVariables">
            <summary>
            Yields all the unbound variables in the selected overload.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.ITypeTree.UnresolvedVariablesInReturnType(BagoumLib.Unification.ITypeTree)">
            <summary>
            Yields all the unbound variables in the return type of the selected overload.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.IMethodDesignation">
            <summary>
            A proxy for a <see cref="T:BagoumLib.Unification.TypeDesignation"/> on a method.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IMethodDesignation.Method">
            <summary>
            The type designation for this method.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.IMethodTypeTree">
            <summary>
            Non-generic base interface for <see cref="T:BagoumLib.Unification.IMethodTypeTree`1"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.IMethodTypeTree`1">
            <summary>
            Interface that auto-implements part of <see cref="T:BagoumLib.Unification.ITypeTree"/> for overloaded method call ASTs.
            </summary>
            <typeparam name="T">Implementation type for <see cref="T:BagoumLib.Unification.IMethodDesignation"/>, which specifies the type of each method overload.</typeparam>
        </member>
        <member name="P:BagoumLib.Unification.IMethodTypeTree`1.Overloads">
            <summary>
            The set of method overloads. All overloads must have the same number of arguments.
            <br/>This may be dependent on argument types (such as in the case of member access),
             in which case it can be filled out in <see cref="M:BagoumLib.Unification.IMethodTypeTree`1.GenerateOverloads(System.Collections.Generic.List{System.ValueTuple{BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.Unifier}}[])"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IMethodTypeTree`1.GenerateOverloads(System.Collections.Generic.List{System.ValueTuple{BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.Unifier}}[])">
            <summary>
            If this method's overloads are dependent on argument types (such as in the case of member access),
             set <see cref="P:BagoumLib.Unification.IMethodTypeTree`1.Overloads"/> based on the possible argument types.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IMethodTypeTree`1.ImplicitParameterCast(`0,System.Int32)">
            <summary>
            Whether or not the parameter at `index` can receive implicit casts for the given overload.
            <br/>Left: The parameter must match exactly or use the given implicit cast.
            <br/>Right: The parameter is allowed or not allowed to use any implicit casts at its level.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IMethodTypeTree`1.OverloadsAreInterchangeable">
            <summary>
            Set this to true when overlapping overloads all do the same thing.
             For example, the overloads for multiplication are { (float, T)->T, (T, float)->T }.
             These two overloads overlap when T=float, in which case the overloads are equivalent.
            <br/>This will cause typechecking in <see cref="M:BagoumLib.Unification.ITypeTree.PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)"/> and 
             <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/> to complete as soon as a single valid overload is found.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IMethodTypeTree`1.RealizableOverloads">
            <summary>
            The subset of <see cref="P:BagoumLib.Unification.IMethodTypeTree`1.Overloads"/> that can be realized given an initial parse of the provided arguments (ignoring the return type).
            Set in <see cref="M:BagoumLib.Unification.ITypeTree.PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IMethodTypeTree`1.Arguments">
            <summary>
            The set of arguments to the method, whichever of the overloads is selected.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IMethodTypeTree`1.SelectedOverload">
            <summary>
            The method overload selected by <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IMethodTypeTree`1.WillSelectOverload(`0,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)">
            <summary>
            Called in <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/> when the overload is selected,
             and before arguments are unified against the overload.
            <br/>This generally requires no implementation, except when overloads or casts carry implicit
             variable declarations.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IMethodTypeTree`1._PossibleUnifiers(BagoumLib.Unification.IMethodTypeTree{`0},BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)">
            <inheritdoc cref="M:BagoumLib.Unification.ITypeTree.PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)"/>
        </member>
        <member name="M:BagoumLib.Unification.IMethodTypeTree`1._ResolveUnifiers(BagoumLib.Unification.IMethodTypeTree{`0},BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)">
            <inheritdoc cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/>
        </member>
        <member name="M:BagoumLib.Unification.IMethodTypeTree`1._FinalizeUnifiers(BagoumLib.Unification.IMethodTypeTree{`0},BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.ITypeTree.FinalizeUnifiers(BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="T:BagoumLib.Unification.IAtomicTypeTree">
            <summary>
            Interface that auto-implements part of <see cref="T:BagoumLib.Unification.ITypeTree"/> for ASTs that are not method calls.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IAtomicTypeTree.PossibleTypes">
            <summary>
            The set of overloads that this object's type can possibly be.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IAtomicTypeTree.SelectedOverload">
            <summary>
            The type overload selected after <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IAtomicTypeTree.WillSelectOverload(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)">
            <summary>
            Called in <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/> when the overload is selected.
            <br/>This generally requires no implementation, except when overloads or casts carry implicit
             variable declarations.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IAtomicTypeTree._PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.ITypeTree.PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)"/>
        </member>
        <member name="M:BagoumLib.Unification.IAtomicTypeTree._ResolveUnifiers(BagoumLib.Unification.IAtomicTypeTree,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)">
            <inheritdoc cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,BagoumLib.Functional.Either{BagoumLib.Unification.IImplicitTypeConverter,System.Boolean},System.Boolean)"/>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr">
            <summary>
            A failure in type unification for <see cref="T:BagoumLib.Unification.TypeDesignation"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.NotEqual">
            <summary>
            Two type designations were expected to be equal, but were not.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.NotEqual.#ctor(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Two type designations were expected to be equal, but were not.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.IntersectionFailure">
            <summary>
            Two type designations were expected to be equal, but they resolved to variables with misaligned restrictions.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.IntersectionFailure.#ctor(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable)">
            <summary>
            Two type designations were expected to be equal, but they resolved to variables with misaligned restrictions.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.RestrictionFailure">
            <summary>
            Two type designations were expected to be equal, but one resolved to a variable whose restrictions
             were not satisfied by the other.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.RestrictionFailure.#ctor(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Known)">
            <summary>
            Two type designations were expected to be equal, but one resolved to a variable whose restrictions
             were not satisfied by the other.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.NotEqual`1">
            <summary>
            Two type designations were expected to be equal, but were not.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.NotEqual`1.#ctor(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,`0,`0)">
            <summary>
            Two type designations were expected to be equal, but were not.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.ArityNotEqual">
            <summary>
            Two resolved type constructors are of different arity.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.ArityNotEqual.#ctor(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Two resolved type constructors are of different arity.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.UnboundRestr">
            <summary>
            A variable type was never bound to a concrete type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.UnboundRestr.#ctor(BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.ITypeTree)">
            <summary>
            A variable type was never bound to a concrete type.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.RecursionBinding">
            <summary>
            A recursive binding was found, where `LResolved` occurred in `RResolved`.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.RecursionBinding.#ctor(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation)">
            <summary>
            A recursive binding was found, where `LResolved` occurred in `RResolved`.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.NoPossibleOverload">
            <summary>
            During the <see cref="M:BagoumLib.Unification.ITypeTree.PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)"/> stage, no overload was found that could
             possibly match the parameters.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.NoPossibleOverload.#ctor(BagoumLib.Unification.IMethodTypeTree,System.Collections.Generic.IList{System.Collections.Generic.List{System.ValueTuple{BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.Unifier}}})">
            <summary>
            During the <see cref="M:BagoumLib.Unification.ITypeTree.PossibleUnifiers(BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier,System.Boolean)"/> stage, no overload was found that could
             possibly match the parameters.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.NoResolvableOverload">
            <summary>
            During the <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier)"/> stage,
             no overload could be found that unified correctly with the parameters and return type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.NoResolvableOverload.#ctor(BagoumLib.Unification.ITypeTree,BagoumLib.Unification.TypeDesignation,System.Collections.Generic.IReadOnlyList{System.ValueTuple{BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeUnifyErr}})">
            <summary>
            During the <see cref="M:BagoumLib.Unification.ITypeTree.ResolveUnifiers(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeResolver,BagoumLib.Unification.Unifier)"/> stage,
             no overload could be found that unified correctly with the parameters and return type.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.MultipleOverloads">
            <summary>
            Two overloads were found that satisfy the required result type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.MultipleOverloads.#ctor(BagoumLib.Unification.ITypeTree,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Two overloads were found that satisfy the required result type.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.MultipleImplicits">
            <summary>
            Two implicit casts were found that satisfy the required result type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.MultipleImplicits.#ctor(BagoumLib.Unification.ITypeTree,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Two implicit casts were found that satisfy the required result type.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeUnifyErr.TooManyPossibleTypes">
            <summary>
            AST type-checking returned more than 1 possible top-level type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeUnifyErr.TooManyPossibleTypes.#ctor(BagoumLib.Unification.ITypeTree,System.Collections.Generic.List{BagoumLib.Unification.TypeDesignation})">
            <summary>
            AST type-checking returned more than 1 possible top-level type.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeDesignation">
            <summary>
            A restriction on an atomic type or type constructor
            (where an atomic type is a type that is not the result of a type constructor, ie. int but not List{int})
            that can be used to perform type unification over two type descriptions with
            <see cref="M:BagoumLib.Unification.TypeDesignation.Unify(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.Unifier)"/>.
            <br/>This is a more general form of <see cref="T:BagoumLib.Reflection.ReflectionUtils"/>.ConstructedGenericTypeMatch.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Arguments">
            <summary>
            The arguments provided to this type constructor (if this is a type constructor).
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.IsResolved">
            <summary>
            True iff this type and its arguments are all resolved, and can thus be constructed into a concrete type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.#ctor(System.Boolean,BagoumLib.Unification.TypeDesignation[])">
            <inheritdoc cref="T:BagoumLib.Unification.TypeDesignation"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Unify(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.Unifier)">
            <summary>
            Perform type unification on two type descriptions.
            </summary>
            <returns>(Left/success) type resolutions, (Right/failure) error that prevented unification</returns>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Unify(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.Unify(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Occurs(BagoumLib.Unification.TypeDesignation.Variable)">
            <summary>
            Check if a variable type designation occurs in this type tree.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.OperatorsEqual(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Test whether the operators (the atomic type or type constructors) of two designations are equivalent.
            <br/>Ignores arguments.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Resolve(BagoumLib.Unification.Unifier)">
            <summary>
            Given the resolutions for unbound types, resolve the final type of this type restriction.
            <br/>Note that the return type for a method call or other dummy tree is just its return type/last argument, ignoring its parameters.
            </summary>
            <returns>(Left/success) resolved type, (Right/failure) error that prevented resolution</returns>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Resolve">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.Resolve(BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Simplify(BagoumLib.Unification.Unifier)">
            <summary>
            Simplify this type using the unifier.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.OccursInSimplification(BagoumLib.Unification.Unifier,BagoumLib.Unification.TypeDesignation.Variable)">
            <summary>
            Check if a variable would occur in this.Simplify(u).
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.SimplifyArgs(BagoumLib.Unification.Unifier,BagoumLib.Unification.TypeDesignation[])">
            <summary>
            Simplify an array of types using the unifier.
            If no simplifications were made, return null.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.GetVariables">
            <summary>
            Get all the unbound type variables (<see cref="T:BagoumLib.Unification.TypeDesignation.Variable"/>) in this definition.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.RecreateVariables">
            <summary>
            Recreate this type designation with new <see cref="T:BagoumLib.Unification.TypeDesignation.Variable"/>s.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.RecreateVariables(System.Collections.Generic.Dictionary{BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable})">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.RecreateVariables"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.MakeArrayType">
            <summary>
            Make an array type designation for this type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Equals(BagoumLib.Unification.TypeDesignation)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.op_Equality(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Equality operator.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.op_Inequality(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Inequality operator.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeDesignation.Known">
            <summary>
            A known atomic type or type constructor.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Known.ArrayGenericType">
            <summary>
            The type used to represent array generics (which do not exist natively in C#).
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Known.IsArrayTypeConstructor">
            <summary>
            True iff this type is the type constructor for arrays.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Known.Typ">
            <summary>
            The known type or type constructor, as a Type object.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.#ctor(System.Type,BagoumLib.Unification.TypeDesignation[])">
            <summary>
            A known type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.MakeFuncType(BagoumLib.Unification.TypeDesignation[])">
            <summary>
            Create the type Func&lt;a,b,c,d,e...&gt;.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.MakeTupleType(BagoumLib.Unification.TypeDesignation[])">
            <summary>
            Create the type (a,b,c,d,e...).
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.Simplify(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.RecreateVariables(System.Collections.Generic.Dictionary{BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.Resolve(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Known.ToString">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Unification.TypeDesignation.Dummy">
            <summary>
            A dummy type for nesting multiple restriction trees, such as 'method'. The effective return type is the last argument.
            </summary>
        </member>
        <member name="F:BagoumLib.Unification.TypeDesignation.Dummy.METHOD_KEY">
            <summary>
            ="method"
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Dummy.Typ">
            <summary>
            The string marking the type of aggregated type this is. By default, this is "method".
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Dummy.Last">
            <summary>
            The last of the aggregated types (also considered the effective return type).
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.#ctor(System.String,BagoumLib.Unification.TypeDesignation[])">
            <summary>
            A dummy type for nesting multiple restriction trees, such as 'method'.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.Method(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation[])">
            <summary>
            Create a type designation representing a method call.
            </summary>
            <param name="returnTyp">Method return type</param>
            <param name="argTyps">Method parameter types, preceded by the instance type if this is an instance method</param>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.Method(BagoumLib.Unification.TypeDesignation,System.Collections.Generic.IEnumerable{BagoumLib.Unification.TypeDesignation})">
            <summary>
            Create a type designation representing a method call.
            </summary>
            <param name="returnTyp">Method return type</param>
            <param name="argTyps">Method parameter types, preceded by the instance type if this is an instance method</param>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.PartialApplyToFunc(System.Int32)">
            <summary>
            For a method tree (a,b,c,d,e)->f, convert it to eg. (a,b)->Func&lt;c,d,e,f&gt; (for args=2).
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.Simplify(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.SimplifyDummy(BagoumLib.Unification.Unifier)">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.Dummy.Simplify(BagoumLib.Unification.Unifier)"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.Resolve(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.RecreateVariables(System.Collections.Generic.Dictionary{BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.RecreateVariablesD(System.Collections.Generic.Dictionary{BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable})">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.Dummy.RecreateVariables(System.Collections.Generic.Dictionary{BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable})"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.RecreateVariablesD">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.Dummy.RecreateVariables(System.Collections.Generic.Dictionary{BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable})"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Dummy.ToString">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Unification.TypeDesignation.Variable">
            <summary>
            An unbound type.
            <br/>Note that we currently do not support unification over type constructors, so this cannot take arguments.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Variable.Ident">
            <summary>
            A random identifier to identify unique unbound types. This is for debugging use only.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeDesignation.Variable.RestrictedTypes">
            <summary>
            When Variable represents a literal such as `5`, then RestrictedTypes contains the
             set of types that this variable may take (in this case the set of numeric types).
            <br/>Note: The reason why this exists in addition to <see cref="T:BagoumLib.Unification.ITypeTree"/> overload handling
             is that overloads on atomic literals (such as `5` possibly being any numeric type) can cause an exponential
             growth in the number of possible unifiers. Consider the case where we have a block statement
                { 1; 2; 3; 4; 5; return 6; }
             and each numeric literal can be `int`, `float`, or `double`. There are 3^6 = 729 possible unifiers!
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Variable.#ctor">
            <inheritdoc cref="T:BagoumLib.Unification.TypeDesignation.Variable"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Variable.Simplify(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Variable.Resolve(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Variable.GetVariables">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Variable.ToString">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.Variable.RecreateVariables(System.Collections.Generic.Dictionary{BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation.Variable})">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.FromType(System.Type)">
            <summary>
            Create a type designation from a type object.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.FromMethod(System.Reflection.MethodInfo)">
            <summary>
            Create a type designation from a method.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.FromMethod(System.Reflection.MethodInfo,System.Collections.Generic.Dictionary{System.Type,BagoumLib.Unification.TypeDesignation.Variable}@)">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.FromMethod(System.Reflection.MethodInfo)"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.FromMethod(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.Dictionary{System.Type,BagoumLib.Unification.TypeDesignation.Variable}@)">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.FromMethod(System.Reflection.MethodInfo)"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.FromMethod(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.Dictionary{System.Type,BagoumLib.Unification.TypeDesignation.Variable})">
            <inheritdoc cref="M:BagoumLib.Unification.TypeDesignation.FromMethod(System.Reflection.MethodInfo)"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeDesignation.FromType(System.Type,System.Collections.Generic.Dictionary{System.Type,BagoumLib.Unification.TypeDesignation.Variable})">
            <summary>
            Create a type designation from a type object.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.Unifier">
            <summary>
            A wrapper around a dictionary containing type bindings.
            <br/>The binding dictionary is immutable.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.Unifier.TypeVarBindings">
            <summary>
            Binding set.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.Unifier.Count">
            <summary>
            Number of bindings.
            </summary>
        </member>
        <member name="F:BagoumLib.Unification.Unifier.Empty">
            <summary>
            A unifier with no bindings.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.Unifier.Without(BagoumLib.Unification.TypeDesignation.Variable)">
            <summary>
            Return a unifier that does not have any bindings with the given variable.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.Unifier.Item(BagoumLib.Unification.TypeDesignation)">
            <summary>
            Get the ultimate binding of a variable type designation, or the designation itself if it is not variable.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.Unifier.IsYetUnbound(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation.Variable@)">
            <summary>
            Returns true iff `d` is a variable designation that currently has no binding in this unifier.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.Unifier.Bind(BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation,BagoumLib.Unification.TypeDesignation.Variable,BagoumLib.Unification.TypeDesignation)">
            <summary>
            Bind a variable designation to a target.
            <br/>Throws if already bound, or the target is the same.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.TypeResolver">
            <summary>
            Information required to resolve unified types, or to disambiguate overloads, implicit casts, and other
             supplementary unification features.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeResolver.ResolutionCache">
            <summary>
            The cache for resolved types.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeResolver.RewriteRules">
            <summary>
            A dictionary mapping a atomic type or type definition to a list of rewrite rules
             that can cast it into another type.
            <br/>eg. The rewrite rule for compiling a GCXF from an expression is (Func(TExArgCtx, TEx(_)), GCXF(_)).
            <br/>eg. The rewrite rule for getting a float from an int is (int, float).
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.TypeResolver.ReverseRewriteRules">
            <summary>
            A dictionary mapping a atomic type or type definition to a list of rewrite rules
             that can produce it from another type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeResolver.#ctor(System.Collections.Generic.Dictionary{System.Type,System.Type[]})">
            <inheritdoc cref="T:BagoumLib.Unification.TypeResolver"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeResolver.#ctor(BagoumLib.Unification.IImplicitTypeConverter[])">
            <inheritdoc cref="T:BagoumLib.Unification.TypeResolver"/>
        </member>
        <member name="M:BagoumLib.Unification.TypeResolver.GetImplicitCasts(BagoumLib.Unification.TypeDesignation,System.Collections.Generic.IEnumerable{BagoumLib.Unification.IImplicitTypeConverter}@)">
            <summary>
            Return the set of type conversions where `source` is converted into another type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeResolver.GetImplicitSources(BagoumLib.Unification.TypeDesignation,System.Collections.Generic.IEnumerable{BagoumLib.Unification.IImplicitTypeConverter}@)">
            <summary>
            Return the set of type conversions where `target` is constructed from another type.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.TypeResolver.GetImplicitSourcesList(BagoumLib.Unification.TypeDesignation,System.Collections.Generic.List{BagoumLib.Unification.IImplicitTypeConverter}@)">
            <summary>
            Return the set of type conversions where `target` is constructed from another type.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.IImplicitTypeConverter">
            <summary>
            Interface for instructions on constructing an implicit type conversions in <see cref="T:BagoumLib.Unification.TypeResolver"/>.
            <br/>This allows for generic type conversion when <see cref="P:BagoumLib.Unification.IImplicitTypeConverterInstance.Generic"/> is non-empty.
             For example, if <see cref="P:BagoumLib.Unification.IImplicitTypeConverterInstance.MethodType"/> represents the method
             Foo(Var1) -> Bar(Var1), and Generic contains Var1, then this represents a generic cast from Foo{T} to Bar{T}.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IImplicitTypeConverter.NextInstance">
            <summary>
            An instance of this type conversion which has not yet been consumed in a unifier.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IImplicitTypeConverter.SourceAllowed(BagoumLib.Unification.TypeDesignation)">
            <summary>
            If false, then the source type will not be converted by this converter, even if it
             matches the converter's required form.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.IImplicitTypeConverterInstance">
            <summary>
            An instance of <see cref="T:BagoumLib.Unification.IImplicitTypeConverter"/> that does not share generic variables with other instances,
             in order to prevent cross-pollution of generic conversion variables between multiple areas in a type tree.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IImplicitTypeConverterInstance.Converter">
            <summary>
            The converter definition.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IImplicitTypeConverterInstance.MethodType">
            <summary>
            A method definition in one argument defining the conversion.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IImplicitTypeConverterInstance.Generic">
            <summary>
            Generic type variables in the method definition. Not sorted.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IImplicitTypeConverterInstance.SimplifyVariables(BagoumLib.Unification.Unifier)">
            <summary>
            Get the type definitions for each of the generic type variables when this conversion is used
             in the context of the provided unifier.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IImplicitTypeConverterInstance.Realize(BagoumLib.Unification.Unifier)">
            <summary>
            Create a <see cref="T:BagoumLib.Unification.IRealizedImplicitCast"/> representing the application of this converter.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IImplicitTypeConverterInstance.MarkUsed">
            <summary>
            The consumer must call this method when this instance is consumed,
             and the generating <see cref="T:BagoumLib.Unification.IImplicitTypeConverter"/> will
             recompute <see cref="P:BagoumLib.Unification.IImplicitTypeConverter.NextInstance"/> in order to avoid cross-pollution.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.IRealizedImplicitCast">
            <summary>
            Interface for information about a succesful implicit type conversion in <see cref="T:BagoumLib.Unification.TypeResolver"/>.
            <br/>Note that when this is constructed, the result type may not be fully finished, ie. it may still have
             unbound type variables in it.
            Call <see cref="M:BagoumLib.Unification.IRealizedImplicitCast.Simplify(BagoumLib.Unification.Unifier)"/> to update this object if further unification is found.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IRealizedImplicitCast.Converter">
            <summary>
            The converter that made the conversion.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IRealizedImplicitCast.ResultType">
            <summary>
            The type to which the object was cast.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.IRealizedImplicitCast.Variables">
            <summary>
            The realized types mapped to the <see cref="P:BagoumLib.Unification.IImplicitTypeConverterInstance.Generic"/> variables of the type conversion.
            </summary>
        </member>
        <member name="M:BagoumLib.Unification.IRealizedImplicitCast.Simplify(BagoumLib.Unification.Unifier)">
            <summary>
            Update the type designations (<see cref="P:BagoumLib.Unification.IRealizedImplicitCast.ResultType"/> and <see cref="P:BagoumLib.Unification.IRealizedImplicitCast.Variables"/>) with more unification information.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.ImplicitTypeConverter">
            <summary>
            Basic implementation for <see cref="T:BagoumLib.Unification.IImplicitTypeConverter"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.ImplicitTypeConverter.NextInstance">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.ImplicitTypeConverter.#ctor(System.Type,System.Type)">
            <inheritdoc cref="T:BagoumLib.Unification.ImplicitTypeConverter"/>
        </member>
        <member name="M:BagoumLib.Unification.ImplicitTypeConverter.#ctor(BagoumLib.Unification.TypeDesignation.Dummy)">
            <summary>
            Basic implementation for <see cref="T:BagoumLib.Unification.IImplicitTypeConverter"/>.
            </summary>
        </member>
        <member name="T:BagoumLib.Unification.ImplicitTypeConverter.Instance">
            <summary>
            Basic implementation for <see cref="T:BagoumLib.Unification.IImplicitTypeConverterInstance"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.ImplicitTypeConverter.Instance.Converter">
            <inheritdoc cref="P:BagoumLib.Unification.IImplicitTypeConverterInstance.Converter"/>
        </member>
        <member name="P:BagoumLib.Unification.ImplicitTypeConverter.Instance.MethodType">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Unification.ImplicitTypeConverter.Instance.Generic">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.ImplicitTypeConverter.Instance.#ctor(BagoumLib.Unification.ImplicitTypeConverter)">
            <inheritdoc cref="T:BagoumLib.Unification.ImplicitTypeConverter.Instance"/>
        </member>
        <member name="M:BagoumLib.Unification.ImplicitTypeConverter.Instance.Realize(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.ImplicitTypeConverter.Instance.MarkUsed">
            <inheritdoc/>
        </member>
        <member name="T:BagoumLib.Unification.RealizedImplicitCast">
            <summary>
            Basic implementation of <see cref="T:BagoumLib.Unification.IRealizedImplicitCast"/>.
            </summary>
        </member>
        <member name="P:BagoumLib.Unification.RealizedImplicitCast.Converter">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Unification.RealizedImplicitCast.ResultType">
            <inheritdoc/>
        </member>
        <member name="P:BagoumLib.Unification.RealizedImplicitCast.Variables">
            <inheritdoc/>
        </member>
        <member name="M:BagoumLib.Unification.RealizedImplicitCast.#ctor(BagoumLib.Unification.IImplicitTypeConverterInstance,BagoumLib.Unification.Unifier)">
            <inheritdoc cref="T:BagoumLib.Unification.RealizedImplicitCast"/>
        </member>
        <member name="M:BagoumLib.Unification.RealizedImplicitCast.Simplify(BagoumLib.Unification.Unifier)">
            <inheritdoc/>
        </member>
        <member name="T:System.Collections.Generic.PriorityQueue`2">
            <summary>
             Represents a min priority queue.
            </summary>
            <typeparam name="TElement">Specifies the type of elements in the queue.</typeparam>
            <typeparam name="TPriority">Specifies the type of priority associated with enqueued elements.</typeparam>
            <remarks>
             Implements an array-backed quaternary min-heap. Each element is enqueued with an associated priority
             that determines the dequeue order: elements with the lowest priority get dequeued first.
            </remarks>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`2._nodes">
            <summary>
            Represents an implicit heap-ordered complete d-ary tree, stored as an array.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`2._comparer">
            <summary>
            Custom comparer used to order the heap.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`2._unorderedItems">
            <summary>
            Lazily-initialized collection used to expose the contents of the queue.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`2._size">
            <summary>
            The number of nodes in the heap.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`2._version">
            <summary>
            Version updated on mutation to help validate enumerators operate on a consistent state.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`2.Arity">
            <summary>
            Specifies the arity of the d-ary heap, which here is quaternary.
            It is assumed that this value is a power of 2.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`2.Log2Arity">
            <summary>
            The binary logarithm of <see cref="F:System.Collections.Generic.PriorityQueue`2.Arity" />.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.#ctor">
            <summary>
             Initializes a new instance of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> class.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.#ctor(System.Int32)">
            <summary>
             Initializes a new instance of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> class
             with the specified initial capacity.
            </summary>
            <param name="initialCapacity">Initial capacity to allocate in the underlying heap array.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
             The specified <paramref name="initialCapacity"/> was negative.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`1})">
            <summary>
             Initializes a new instance of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> class
             with the specified custom priority comparer.
            </summary>
            <param name="comparer">
             Custom comparer dictating the ordering of elements.
             Uses <see cref="P:System.Collections.Generic.Comparer`1.Default" /> if the argument is <see langword="null"/>.
            </param>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`1})">
            <summary>
             Initializes a new instance of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> class
             with the specified initial capacity and custom priority comparer.
            </summary>
            <param name="initialCapacity">Initial capacity to allocate in the underlying heap array.</param>
            <param name="comparer">
             Custom comparer dictating the ordering of elements.
             Uses <see cref="P:System.Collections.Generic.Comparer`1.Default" /> if the argument is <see langword="null"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
             The specified <paramref name="initialCapacity"/> was negative.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
             Initializes a new instance of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> class
             that is populated with the specified elements and priorities.
            </summary>
            <param name="items">The pairs of elements and priorities with which to populate the queue.</param>
            <exception cref="T:System.ArgumentNullException">
             The specified <paramref name="items"/> argument was <see langword="null"/>.
            </exception>
            <remarks>
             Constructs the heap using a heapify operation,
             which is generally faster than enqueuing individual elements sequentially.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},System.Collections.Generic.IComparer{`1})">
            <summary>
             Initializes a new instance of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> class
             that is populated with the specified elements and priorities,
             and with the specified custom priority comparer.
            </summary>
            <param name="items">The pairs of elements and priorities with which to populate the queue.</param>
            <param name="comparer">
             Custom comparer dictating the ordering of elements.
             Uses <see cref="P:System.Collections.Generic.Comparer`1.Default" /> if the argument is <see langword="null"/>.
            </param>
            <exception cref="T:System.ArgumentNullException">
             The specified <paramref name="items"/> argument was <see langword="null"/>.
            </exception>
            <remarks>
             Constructs the heap using a heapify operation,
             which is generally faster than enqueuing individual elements sequentially.
            </remarks>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`2.Count">
            <summary>
             Gets the number of elements contained in the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`2.Comparer">
            <summary>
             Gets the priority comparer used by the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`2.UnorderedItems">
            <summary>
             Gets a collection that enumerates the elements of the queue in an unordered manner.
            </summary>
            <remarks>
             The enumeration does not order items by priority, since that would require N * log(N) time and N space.
             Items are instead enumerated following the internal array heap layout.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.Enqueue(`0,`1)">
            <summary>
             Adds the specified element with associated priority to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.
            </summary>
            <param name="element">The element to add to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.</param>
            <param name="priority">The priority with which to associate the new element.</param>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.Peek">
            <summary>
             Returns the minimal element from the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> without removing it.
            </summary>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Generic.PriorityQueue`2"/> is empty.</exception>
            <returns>The minimal element of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.Dequeue">
            <summary>
             Removes and returns the minimal element from the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">The queue is empty.</exception>
            <returns>The minimal element of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.DequeueEnqueue(`0,`1)">
            <summary>
             Removes the minimal element and then immediately adds the specified element with associated priority to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>,
            </summary>
            <param name="element">The element to add to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.</param>
            <param name="priority">The priority with which to associate the new element.</param>
            <exception cref="T:System.InvalidOperationException">The queue is empty.</exception>
            <returns>The minimal element removed before performing the enqueue operation.</returns>
            <remarks>
             Implements an extract-then-insert heap operation that is generally more efficient
             than sequencing Dequeue and Enqueue operations: in the worst case scenario only one
             shift-down operation is required.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.TryDequeue(`0@,`1@)">
            <summary>
             Removes the minimal element from the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>,
             and copies it to the <paramref name="element"/> parameter,
             and its associated priority to the <paramref name="priority"/> parameter.
            </summary>
            <param name="element">The removed element.</param>
            <param name="priority">The priority associated with the removed element.</param>
            <returns>
             <see langword="true"/> if the element is successfully removed;
             <see langword="false"/> if the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> is empty.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.TryPeek(`0@,`1@)">
            <summary>
             Returns a value that indicates whether there is a minimal element in the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>,
             and if one is present, copies it to the <paramref name="element"/> parameter,
             and its associated priority to the <paramref name="priority"/> parameter.
             The element is not removed from the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.
            </summary>
            <param name="element">The minimal element in the queue.</param>
            <param name="priority">The priority associated with the minimal element.</param>
            <returns>
             <see langword="true"/> if there is a minimal element;
             <see langword="false"/> if the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> is empty.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.EnqueueDequeue(`0,`1)">
            <summary>
             Adds the specified element with associated priority to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>,
             and immediately removes the minimal element, returning the result.
            </summary>
            <param name="element">The element to add to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.</param>
            <param name="priority">The priority with which to associate the new element.</param>
            <returns>The minimal element removed after the enqueue operation.</returns>
            <remarks>
             Implements an insert-then-extract heap operation that is generally more efficient
             than sequencing Enqueue and Dequeue operations: in the worst case scenario only one
             shift-down operation is required.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.EnqueueRange(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
             Enqueues a sequence of element/priority pairs to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.
            </summary>
            <param name="items">The pairs of elements and priorities to add to the queue.</param>
            <exception cref="T:System.ArgumentNullException">
             The specified <paramref name="items"/> argument was <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.EnqueueRange(System.Collections.Generic.IEnumerable{`0},`1)">
            <summary>
             Enqueues a sequence of elements pairs to the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>,
             all associated with the specified priority.
            </summary>
            <param name="elements">The elements to add to the queue.</param>
            <param name="priority">The priority to associate with the new elements.</param>
            <exception cref="T:System.ArgumentNullException">
             The specified <paramref name="elements"/> argument was <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.Clear">
            <summary>
             Removes all items from the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.EnsureCapacity(System.Int32)">
            <summary>
             Ensures that the <see cref="T:System.Collections.Generic.PriorityQueue`2"/> can hold up to
             <paramref name="capacity"/> items without further expansion of its backing storage.
            </summary>
            <param name="capacity">The minimum capacity to be used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
             The specified <paramref name="capacity"/> is negative.
            </exception>
            <returns>The current capacity of the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.TrimExcess">
            <summary>
             Sets the capacity to the actual number of items in the <see cref="T:System.Collections.Generic.PriorityQueue`2"/>,
             if that is less than 90 percent of current capacity.
            </summary>
            <remarks>
             This method can be used to minimize a collection's memory overhead
             if no new elements will be added to the collection.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.Grow(System.Int32)">
            <summary>
            Grows the priority queue to match the specified min capacity.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.RemoveRootNode">
            <summary>
            Removes the node from the root of the heap
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.GetParentIndex(System.Int32)">
            <summary>
            Gets the index of an element's parent.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.GetFirstChildIndex(System.Int32)">
            <summary>
            Gets the index of the first child of an element.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.Heapify">
            <summary>
            Converts an unordered list into a heap.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.MoveUpDefaultComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
            Moves a node up in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.MoveUpCustomComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
            Moves a node up in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.MoveDownDefaultComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
            Moves a node down in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.MoveDownCustomComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
            Moves a node down in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.InitializeComparer(System.Collections.Generic.IComparer{`1})">
            <summary>
            Initializes the custom comparer to be used internally by the heap.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection">
            <summary>
             Enumerates the contents of a <see cref="T:System.Collections.Generic.PriorityQueue`2"/>, without any ordering guarantees.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection.Enumerator">
            <summary>
             Enumerates the element and priority pairs of a <see cref="T:System.Collections.Generic.PriorityQueue`2"/>,
             without any ordering guarantees.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection.Enumerator.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection.Enumerator"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the <see cref="P:System.Collections.Generic.PriorityQueue`2.UnorderedItems"/>.
            </summary>
            <returns><see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="P:System.Collections.Generic.PriorityQueue`2.UnorderedItems"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.PriorityQueue`2.UnorderedItemsCollection.Enumerator"/> for the <see cref="P:System.Collections.Generic.PriorityQueue`2.UnorderedItems"/>.</returns>
        </member>
    </members>
</doc>
